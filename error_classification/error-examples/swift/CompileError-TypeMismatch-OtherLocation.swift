// ----------- problem HumanEval_137_compare_one, completion 15 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_140_fix_spaces, completion 143 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpjftpzs9v.swift:26:24: error: cannot assign value of type 'Character' to type 'String'
            previous = char
                       ^~~~

*/
/* stdout = 

*/


/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(text: " Example")
/// "Example"
/// >>> fix_spaces(text: " Example 1")
/// "Example_1"
/// >>> fix_spaces(text: " Example 2")
/// "_Example_2"
/// >>> fix_spaces(text: " Example 3")
/// "_Example-3"
func fix_spaces(text: String) -> String {
    var result = ""
    var previous = ""
    var count = 0
    for char in text {
        if char == " " {
            if previous == " " {
                count += 1
            } else {
                count = 1
            }
            previous = " "
        } else {
            previous = char
            count = 0
        }
        if count == 1 {
            result += "_"
        } else if count == 2 {
            result += "-"
        } else {
            result += String(char)
        }
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: "Example") == "Example")
assert(fix_spaces(text: "Mudasir Hanif ") == "Mudasir_Hanif_")
assert(fix_spaces(text: "Yellow Yellow  Dirty  Fellow") == "Yellow_Yellow__Dirty__Fellow")
assert(fix_spaces(text: "Exa   mple") == "Exa-mple")
assert(fix_spaces(text: "   Exa 1 2 2 mple") == "-Exa_1_2_2_mple")



// ----------- problem HumanEval_137_compare_one, completion 185 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 194 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqvnis_b6.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmpqvnis_b6.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmpqvnis_b6.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmpqvnis_b6.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    if area.isNaN {
        return -1
    }
    return area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_27_flip_case, completion 94 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpltli3v31.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        $0.isUppercase ? $0.lowercased() : $0.uppercased()
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 192 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp21p3b2hl.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^
/tmp/tmp21p3b2hl.swift:18:39: error: value of type 'Character' has no member 'isUppercased'
            let isUppercased = letter.isUppercased
                               ~~~~~~ ^~~~~~~~~~~~

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            let isUppercased = letter.isUppercased
            let newLetter = alphabet[alphabet.index(index, offsetBy: 2)]
            encodedMessage += isUppercased ? newLetter.uppercased() : newLetter
        } else {
            encodedMessage += String(letter)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 45 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpa2ixildu.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(char)
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 44 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 149 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpyxi_vrfl.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            let newIndex = (index + 2) % letters.count
            encoded.append(letters[newIndex])
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 10 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 197 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 131 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp9nl3aw5w.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(letters[letters.index(index, offsetBy: 2)])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 114 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 93 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp0_iggg13.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = letters.index(index, offsetBy: 2)
                encoded.append(letters[newIndex])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 108 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 114 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 103 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdghtrdhl.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 158 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 169 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 30 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpu3njmdwo.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmpu3njmdwo.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmpu3njmdwo.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmpu3njmdwo.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area > 0 ? area : -1
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_137_compare_one, completion 166 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 57 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpye22d95r.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggle() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpye22d95r.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggle'
    return s.map { $0.isLetter ? $0.toggle() : $0 }
                                 ~~ ^~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggle() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 173 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 45 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 31 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_48_is_palindrome, completion 109 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpgmgk25yl.swift:18:26: error: cannot convert value of type '[Character]' to expected argument type 'Substring'
    return first == last.reversed()
                         ^

*/
/* stdout = 

*/


/// Checks if given string is a palindrome
/// >>> is_palindrome(text: "")
/// true
/// >>> is_palindrome(text: "aba")
/// true
/// >>> is_palindrome(text: "aaaaa")
/// true
/// >>> is_palindrome(text: "zbcd")
/// false
func is_palindrome(text: String) -> Bool {
    let length = text.count
    let half = length / 2
    let start = text.index(text.startIndex, offsetBy: 0)
    let end = text.index(text.startIndex, offsetBy: half)
    let first = text[start..<end]
    let last = text[text.index(text.endIndex, offsetBy: -half)..<text.endIndex]
    return first == last.reversed()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: "") == true)
assert(is_palindrome(text: "aba") == true)
assert(is_palindrome(text: "aaaaa") == true)
assert(is_palindrome(text: "zbcd") == false)
assert(is_palindrome(text: "xywyx") == true)
assert(is_palindrome(text: "xywyz") == false)
assert(is_palindrome(text: "xywzx") == false)



// ----------- problem HumanEval_137_compare_one, completion 70 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_48_is_palindrome, completion 195 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpnbht5xl3.swift:17:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an integer range, use a String.Index range instead.
    let left = text[..<mid]
               ^~~~~~~~~~~~
Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable here
    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int { get }
           ^
/tmp/tmpnbht5xl3.swift:18:17: error: 'subscript(_:)' is unavailable: cannot subscript String with an integer range, use a String.Index range instead.
    let right = text[mid...]
                ^~~~~~~~~~~~
Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable here
    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int { get }
           ^
/tmp/tmpnbht5xl3.swift:19:17: error: binary operator '==' cannot be applied to operands of type 'String' and '[String.Element]' (aka 'Array<Character>')
    return left == right.reversed()
           ~~~~ ^  ~~~~~~~~~~~~~~~~
/tmp/tmpnbht5xl3.swift:19:17: note: overloads for '==' exist with these partially matching parameter lists: (String, String)
    return left == right.reversed()
                ^

*/
/* stdout = 

*/


/// Checks if given string is a palindrome
/// >>> is_palindrome(text: "")
/// true
/// >>> is_palindrome(text: "aba")
/// true
/// >>> is_palindrome(text: "aaaaa")
/// true
/// >>> is_palindrome(text: "zbcd")
/// false
func is_palindrome(text: String) -> Bool {
    let text_len = text.count
    if text_len < 2 {
        return true
    }
    let mid = text_len / 2
    let left = text[..<mid]
    let right = text[mid...]
    return left == right.reversed()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: "") == true)
assert(is_palindrome(text: "aba") == true)
assert(is_palindrome(text: "aaaaa") == true)
assert(is_palindrome(text: "zbcd") == false)
assert(is_palindrome(text: "xywyx") == true)
assert(is_palindrome(text: "xywyz") == false)
assert(is_palindrome(text: "xywzx") == false)



// ----------- problem HumanEval_93_encode, completion 158 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1benokn4.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 79 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 33 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_140_fix_spaces, completion 110 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpyjvm5we6.swift:32:20: error: cannot assign value of type 'Character' to type 'String'
        lastChar = char
                   ^~~~

*/
/* stdout = 

*/


/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(text: " Example")
/// "Example"
/// >>> fix_spaces(text: " Example 1")
/// "Example_1"
/// >>> fix_spaces(text: " Example 2")
/// "_Example_2"
/// >>> fix_spaces(text: " Example 3")
/// "_Example-3"
func fix_spaces(text: String) -> String {
    var result = ""
    var lastChar = ""
    var spaceCount = 0
    for char in text {
        if char == " " {
            spaceCount += 1
            if spaceCount > 2 {
                continue
            }
        } else {
            spaceCount = 0
        }
        if char == " " && lastChar == " " {
            result.removeLast()
            result.append("-")
        } else {
            result.append(char)
        }
        lastChar = char
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: "Example") == "Example")
assert(fix_spaces(text: "Mudasir Hanif ") == "Mudasir_Hanif_")
assert(fix_spaces(text: "Yellow Yellow  Dirty  Fellow") == "Yellow_Yellow__Dirty__Fellow")
assert(fix_spaces(text: "Exa   mple") == "Exa-mple")
assert(fix_spaces(text: "   Exa 1 2 2 mple") == "-Exa_1_2_2_mple")



// ----------- problem HumanEval_66_digitSum, completion 0 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 55 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 38 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 105 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_78_hex_key, completion 164 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmphn8g3uue.swift:26:63: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
    return num.filter { primes.contains(hex.firstIndex(of: $0)! + 1) }.count
                                                              ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hex = "0123456789ABCDEF"
    let primes = [2, 3, 5, 7, 11, 13]
    return num.filter { primes.contains(hex.firstIndex(of: $0)! + 1) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_137_compare_one, completion 52 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 23 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 40 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_161_solve, completion 12 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpye22d95r.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggle() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpye22d95r.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggle'
    return s.map { $0.isLetter ? $0.toggle() : $0 }
                                 ~~ ^~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggle() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_93_encode, completion 22 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpuq8nzcw1.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encoded.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encoded.append(alphabet[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 128 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 27 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_113_odd_count, completion 155 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7zp9g8jx.swift:15:22: error: cannot convert value of type 'Character' to expected argument type 'Int'
            if lst[i][j] % 2 != 0 {
                     ^

*/
/* stdout = 

*/


/// Given an array of strings, where each string consists of only digits, return an array.
/// Each element i of the output should be "the number of odd elements in the
/// string i of the input." where all the i's should be replaced by the number
/// of odd digits in the i'th string of the input.
/// >>> odd_count(lst: ["1234567"])
/// ["the number of odd elements 4n the str4ng 4 of the 4nput."]
/// >>> odd_count(lst: ["3", "11111111"])
/// ["the number of odd elements 1n the str1ng 1 of the 1nput.", "the number of odd elements 8n the str8ng 8 of the 8nput."]
func odd_count(lst: [String]) -> [String] {
    var result = [String]()
    for i in 0..<lst.count {
        var oddCount = 0
        for j in 0..<lst[i].count {
            if lst[i][j] % 2 != 0 {
                oddCount += 1
            }
        }
        result.append("the number of odd elements \(oddCount)n the str\(oddCount)ng \(oddCount) of the \(oddCount)nput.")
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(odd_count(lst: ["1234567"]) == ["the number of odd elements 4n the str4ng 4 of the 4nput."])
assert(odd_count(lst: ["3", "11111111"]) == ["the number of odd elements 1n the str1ng 1 of the 1nput.", "the number of odd elements 8n the str8ng 8 of the 8nput."])
assert(odd_count(lst: ["271", "137", "314"]) == ["the number of odd elements 2n the str2ng 2 of the 2nput.", "the number of odd elements 3n the str3ng 3 of the 3nput.", "the number of odd elements 2n the str2ng 2 of the 2nput."])



// ----------- problem HumanEval_66_digitSum, completion 111 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 158 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 120 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 86 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 74 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 140 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_14_all_prefixes, completion 24 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpaow8jwz9.swift:6:44: error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to closure result type 'String'
    return (1...string.count).map { string.prefix($0) }
                                    ~~~~~~~^~~~~~~~~~
                                    String(          )

*/
/* stdout = 

*/


/// Return array of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(string: "abc")
/// ["a", "ab", "abc"]
func all_prefixes(string: String) -> [String] {
    return (1...string.count).map { string.prefix($0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: "") == [] as [String])
assert(all_prefixes(string: "asdfgh") == ["a", "as", "asd", "asdf", "asdfg", "asdfgh"])
assert(all_prefixes(string: "WWW") == ["W", "WW", "WWW"])



// ----------- problem HumanEval_78_hex_key, completion 186 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6f0psfkj.swift:25:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hexPrimes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_27_flip_case, completion 48 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 191 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_140_fix_spaces, completion 147 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpgad_g2bn.swift:21:17: error: binary operator '==' cannot be applied to operands of type 'Character' and 'String'
        if char == space {
           ~~~~ ^  ~~~~~
/tmp/tmpgad_g2bn.swift:21:17: note: overloads for '==' exist with these partially matching parameter lists: (Character, Character), (String, String)
        if char == space {
                ^
/tmp/tmpgad_g2bn.swift:26:33: error: value of type 'String' has no member 'replacingOccurrences'
                result = result.replacingOccurrences(of: space, with: dash)
                         ~~~~~~ ^~~~~~~~~~~~~~~~~~~~
/tmp/tmpgad_g2bn.swift:28:33: error: value of type 'String' has no member 'replacingOccurrences'
                result = result.replacingOccurrences(of: space, with: underscore)
                         ~~~~~~ ^~~~~~~~~~~~~~~~~~~~
/tmp/tmpgad_g2bn.swift:31:21: error: cannot assign value of type 'Character' to type 'String'
        last_char = char
                    ^~~~

*/
/* stdout = 

*/


/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(text: " Example")
/// "Example"
/// >>> fix_spaces(text: " Example 1")
/// "Example_1"
/// >>> fix_spaces(text: " Example 2")
/// "_Example_2"
/// >>> fix_spaces(text: " Example 3")
/// "_Example-3"
func fix_spaces(text: String) -> String {
    let space = " "
    let underscore = "_"
    let dash = "-"
    var result = text
    var last_char = space
    var consecutive_spaces = 0
    for char in text {
        if char == space {
            if last_char == space {
                consecutive_spaces += 1
            }
            if consecutive_spaces > 2 {
                result = result.replacingOccurrences(of: space, with: dash)
            } else {
                result = result.replacingOccurrences(of: space, with: underscore)
            }
        }
        last_char = char
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: "Example") == "Example")
assert(fix_spaces(text: "Mudasir Hanif ") == "Mudasir_Hanif_")
assert(fix_spaces(text: "Yellow Yellow  Dirty  Fellow") == "Yellow_Yellow__Dirty__Fellow")
assert(fix_spaces(text: "Exa   mple") == "Exa-mple")
assert(fix_spaces(text: "   Exa 1 2 2 mple") == "-Exa_1_2_2_mple")



// ----------- problem HumanEval_11_string_xor, completion 20 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let xor = zip(a, b).map { $0 ^ $1 }
    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_93_encode, completion 50 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp5vszpgwa.swift:18:59: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                          ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for letter in message {
        if letter.isLetter {
            if let index = alphabet.firstIndex(of: letter.lowercased()) {
                if vowels.contains(letter.lowercased()) {
                    let nextIndex = alphabet.index(index, offsetBy: 2)
                    encodedMessage.append(alphabet[nextIndex].uppercased())
                } else {
                    encodedMessage.append(alphabet[index].uppercased())
                }
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 2 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 172 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 198 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 174 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 79 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 59 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 110 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 84 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_17_parse_music, completion 40 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqs3wcyrc.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpqs3wcyrc.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            continue
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_93_encode, completion 183 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1benokn4.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 124 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_11_string_xor, completion 34 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_137_compare_one, completion 182 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 28 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_78_hex_key, completion 183 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_93_encode, completion 14 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmtt5qxuy.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 162 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 105 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_11_string_xor, completion 143 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_27_flip_case, completion 143 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 126 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpt2qkd78g.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 172 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp36quf7v1.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index].uppercased())
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_125_split_words, completion 195 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpwtnuxrey.swift:20:137: error: cannot convert value of type 'UInt8' to closure result type 'Int'
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~
                                                                                                                 Int(                       )

*/
/* stdout = 

*/


extension Int: Error {}
        
/// Given a string of words, return an array of words split on whitespace, if no whitespaces exists in the text you
/// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
/// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
/// Examples
/// >>> split_words(txt: "Hello world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "Hello,world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "abcdef")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains(" ") {
        return .success(txt.split(separator: " ").map { String($0) })
    } else if txt.contains(",") {
        return .success(txt.split(separator: ",").map { String($0) })
    } else {
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: "Hello world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello,world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello world,!") == .success(["Hello", "world,!"]))
assert(split_words(txt: "Hello,Hello,world !") == .success(["Hello,Hello,world", "!"]))
assert(split_words(txt: "abcdef") == .failure(3))
assert(split_words(txt: "aaabb") == .failure(2))
assert(split_words(txt: "aaaBb") == .failure(1))
assert(split_words(txt: "") == .failure(0))



// ----------- problem HumanEval_66_digitSum, completion 72 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 16 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 193 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_78_hex_key, completion 4 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_137_compare_one, completion 142 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 116 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpyo1ab66s.swift:16:34: error: incorrect argument label in call (have 'char:', expected 'message:')
            encoded.append(encode(char: char))
                                 ^~~~~
                                  message
/tmp/tmpyo1ab66s.swift:16:41: error: cannot convert value of type 'Character' to expected argument type 'String'
            encoded.append(encode(char: char))
                                        ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    for char in message {
        if char.isLetter {
            encoded.append(encode(char: char))
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 64 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_89_encrypt, completion 110 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf_9zjnub.swift:22:56: error: cannot convert return expression of type 'UnicodeScalar' (aka 'Unicode.Scalar') to return type 'String.Element' (aka 'Character')
                    return UnicodeScalar(newValue - 26)!
                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^

*/
/* stdout = 

*/


/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(s: "hi")
/// "lm"
/// >>> encrypt(s: "asdfghjkl")
/// "ewhjklnop"
/// >>> encrypt(s: "gf")
/// "kj"
/// >>> encrypt(s: "et")
/// "ix"
func encrypt(s: String) -> String {
    var result = ""
    for char in s {
        result += String(char).unicodeScalars.map {
            if $0.value >= 97 && $0.value <= 122 {
                let newValue = $0.value + (2 * 2)
                if newValue > 122 {
                    return UnicodeScalar(newValue - 26)!
                } else {
                    return UnicodeScalar(newValue)!
                }
            } else {
                return $0
            }
        }
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: "hi") == "lm")
assert(encrypt(s: "asdfghjkl") == "ewhjklnop")
assert(encrypt(s: "gf") == "kj")
assert(encrypt(s: "et") == "ix")
assert(encrypt(s: "faewfawefaewg") == "jeiajeaijeiak")
assert(encrypt(s: "hellomyfriend") == "lippsqcjvmirh")
assert(encrypt(s: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
assert(encrypt(s: "a") == "e")



// ----------- problem HumanEval_66_digitSum, completion 76 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 88 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 28 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpvpqfqq8f.swift:18:49: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            let index = alphabet.index(of: char.lowercased())!
                                                ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if vowels.contains(char.lowercased()) {
            let index = alphabet.index(of: char.lowercased())!
            let nextIndex = alphabet.index(index, offsetBy: 2)
            encoded.append(alphabet[nextIndex])
        } else {
            encoded.append(char.lowercased())
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 128 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp07935uvg.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var result = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = letters.index(index, offsetBy: 2)
                result.append(letters[newIndex])
            } else {
                result.append(letters[index])
            }
        }
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 153 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 3 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_137_compare_one, completion 116 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 86 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_93_encode, completion 2 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp125m_vyf.swift:20:52: error: result values in '? :' expression have mismatching types 'Character' and 'String'
            encoded.append(vowels.contains(char) ? nextChar : nextChar.uppercased())
                                                   ^~~~~~~~

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    let alphabet: [Character] = Array("abcdefghijklmnopqrstuvwxyz")
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char) {
            let nextIndex = index + 2
            let nextChar = alphabet[nextIndex % alphabet.count]
            encoded.append(vowels.contains(char) ? nextChar : nextChar.uppercased())
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 197 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 189 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 188 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 157 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 178 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 141 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_17_parse_music, completion 36 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf7ewcezh.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpf7ewcezh.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            break
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_137_compare_one, completion 7 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 87 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 151 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp03xcqq8e.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 89 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_71_triangle_area, completion 140 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmph_4276ba.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmph_4276ba.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmph_4276ba.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmph_4276ba.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    if area > 0 {
        return area
    } else {
        return -1
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_137_compare_one, completion 143 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_118_get_closest_vowel, completion 113 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdwry1nu3.swift:22:22: error: 'characters' is unavailable: Please use String directly
    for char in word.characters {
                     ^~~~~~~~~~
Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0
    public var characters: String { get set }
               ^
/tmp/tmpdwry1nu3.swift:24:59: error: cannot assign value of type 'String.Index' to type 'Int'
            indexOfVowel = word.characters.index(of: char)!
                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
/tmp/tmpdwry1nu3.swift:27:63: error: cannot assign value of type 'String.Index' to type 'Int'
            indexOfConsonant = word.characters.index(of: char)!
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^

*/
/* stdout = 

*/


/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(word: "yogurt")
/// "u"
/// >>> get_closest_vowel(word: "FULL")
/// "U"
/// >>> get_closest_vowel(word: "quick")
/// ""
/// >>> get_closest_vowel(word: "ab")
/// ""
func get_closest_vowel(word: String) -> String {
    let vowels = "aeiou"
    let consonants = "bcdfghjklmnpqrstvwxyz"
    var closestVowel = ""
    var indexOfVowel = 0
    var indexOfConsonant = 0
    for char in word.characters {
        if vowels.contains(String(char)) {
            indexOfVowel = word.characters.index(of: char)!
        }
        if consonants.contains(String(char)) {
            indexOfConsonant = word.characters.index(of: char)!
            if indexOfConsonant > indexOfVowel {
                closestVowel = String(char)
            }
        }
    }
    return closestVowel
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: "yogurt") == "u")
assert(get_closest_vowel(word: "full") == "u")
assert(get_closest_vowel(word: "easy") == "")
assert(get_closest_vowel(word: "eAsy") == "")
assert(get_closest_vowel(word: "ali") == "")
assert(get_closest_vowel(word: "bad") == "a")
assert(get_closest_vowel(word: "most") == "o")
assert(get_closest_vowel(word: "ab") == "")
assert(get_closest_vowel(word: "ba") == "")
assert(get_closest_vowel(word: "quick") == "")
assert(get_closest_vowel(word: "anime") == "i")
assert(get_closest_vowel(word: "Asia") == "")
assert(get_closest_vowel(word: "Above") == "o")



// ----------- problem HumanEval_137_compare_one, completion 5 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 7 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpwoei_vio.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_71_triangle_area, completion 175 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_93_encode, completion 67 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpwoei_vio.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 17 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 45 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 26 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 163 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_78_hex_key, completion 72 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_66_digitSum, completion 17 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 72 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 140 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 170 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_161_solve, completion 90 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_66_digitSum, completion 36 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 182 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 152 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpd5m0hlyn.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let nextIndex = letters.index(index, offsetBy: 2)
                encoded.append(letters[nextIndex])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 190 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp2jmkq09a.swift:17:48: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.index(of: char.lowercased()) {
                                               ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.index(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 95 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_17_parse_music, completion 25 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqs3wcyrc.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpqs3wcyrc.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            continue
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_93_encode, completion 142 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpbdzqrqlf.swift:18:103: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            let index = alphabet.index(alphabet.startIndex, offsetBy: alphabet.index(of: String(char).lowercased())! + 2)
                                                                                                      ^
/tmp/tmpbdzqrqlf.swift:18:116: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let index = alphabet.index(alphabet.startIndex, offsetBy: alphabet.index(of: String(char).lowercased())! + 2)
                                                                                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if vowels.contains(String(char).lowercased()) {
            let index = alphabet.index(alphabet.startIndex, offsetBy: alphabet.index(of: String(char).lowercased())! + 2)
            encodedMessage += String(alphabet[index]).uppercased()
        } else {
            encodedMessage += String(char).uppercased()
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 67 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 151 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 147 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 52 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_66_digitSum, completion 50 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 88 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp8cybbik6.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = alphabet.index(index, offsetBy: 2)
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[newIndex].uppercased())
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 56 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 92 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 141 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpn4xh_kmc.swift:63:9: error: expected pattern
    case
        ^
/tmp/tmpn4xh_kmc.swift:63:9: error: expected ':' after 'case'
    case
        ^
/tmp/tmpn4xh_kmc.swift:86:66: error: expected '}' at end of brace statement
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)
                                                                 ^
/tmp/tmpn4xh_kmc.swift:21:48: note: to match this opening '{'
func compare_one(a: Value, b: Value) -> Value? {
                                               ^
/tmp/tmpn4xh_kmc.swift:29:54: error: binary operator '==' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a == b:
                                                   ~ ^  ~
/tmp/tmpn4xh_kmc.swift:29:54: note: overloads for '==' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a == b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:31:54: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                   ~ ^ ~
/tmp/tmpn4xh_kmc.swift:31:54: note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:33:54: error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                   ~ ^ ~
/tmp/tmpn4xh_kmc.swift:33:54: note: overloads for '<' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:35:54: error: binary operator '==' cannot be applied to operands of type 'Int' and 'String'
    case let (.intValue(a)
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case let (.intValue(a), .intValue(b)) where a == b:
        return nil
    case let (.intValue(a), .intValue(b)) where a > b:
        return a
    case let (.intValue(a), .intValue(b)) where a < b:
        return b
    case let (.intValue(a), .doubleValue(b)) where a == b:
        return nil
    case let (.intValue(a), .doubleValue(b)) where a > b:
        return a
    case let (.intValue(a), .doubleValue(b)) where a < b:
        return b
    case let (.intValue(a), .stringValue(b)) where a == b:
        return nil
    case let (.intValue(a), .stringValue(b)) where a > b:
        return a
    case let (.intValue(a), .stringValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .intValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .intValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .intValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .doubleValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .doubleValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .doubleValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .stringValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .stringValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .stringValue(b)) where a < b:
        return b
    case let (.stringValue(a), .intValue(b)) where a == b:
        return nil
    case let (.stringValue(a), .intValue(b)) where a > b:
        return a
    case
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 139 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 2 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 99 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 81 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 2 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 43 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 15 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 181 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 138 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 69 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_11_string_xor, completion 7 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpzp7rk339.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpzp7rk339.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let c = zip(a, b).map { $0 ^ $1 }
    return c.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_27_flip_case, completion 68 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 90 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 84 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_66_digitSum, completion 75 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 188 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 83 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 7 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 39 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 196 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpyxi_vrfl.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            let newIndex = (index + 2) % letters.count
            encoded.append(letters[newIndex])
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_125_split_words, completion 61 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmptmpei409.swift:20:115: error: cannot convert value of type 'UInt8' to closure result type 'Int'
        return .failure(txt.lowercased().enumerated().filter({ $0.offset % 2 == 0 }).map({ $0.element.asciiValue! - 97 }).reduce(0, +))
                                                                                           ~~~~~~~~~~~~~~~~~~~~~~~^~~~
                                                                                           Int(                       )

*/
/* stdout = 

*/


extension Int: Error {}
        
/// Given a string of words, return an array of words split on whitespace, if no whitespaces exists in the text you
/// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
/// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
/// Examples
/// >>> split_words(txt: "Hello world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "Hello,world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "abcdef")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains(" ") {
        return .success(txt.split(separator: " ").map(String.init))
    } else if txt.contains(",") {
        return .success(txt.split(separator: ",").map(String.init))
    } else {
        return .failure(txt.lowercased().enumerated().filter({ $0.offset % 2 == 0 }).map({ $0.element.asciiValue! - 97 }).reduce(0, +))
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: "Hello world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello,world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello world,!") == .success(["Hello", "world,!"]))
assert(split_words(txt: "Hello,Hello,world !") == .success(["Hello,Hello,world", "!"]))
assert(split_words(txt: "abcdef") == .failure(3))
assert(split_words(txt: "aaabb") == .failure(2))
assert(split_words(txt: "aaaBb") == .failure(1))
assert(split_words(txt: "") == .failure(0))



// ----------- problem HumanEval_66_digitSum, completion 140 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_89_encrypt, completion 142 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpswbsmydo.swift:20:28: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = index + 2 * 2
                           ^

*/
/* stdout = 

*/


/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(s: "hi")
/// "lm"
/// >>> encrypt(s: "asdfghjkl")
/// "ewhjklnop"
/// >>> encrypt(s: "gf")
/// "kj"
/// >>> encrypt(s: "et")
/// "ix"
func encrypt(s: String) -> String {
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encrypted = ""
    for letter in s {
        if let index = alphabet.firstIndex(of: letter) {
            let newIndex = index + 2 * 2
            if newIndex < alphabet.count {
                encrypted.append(alphabet[newIndex])
            } else {
                encrypted.append(alphabet[newIndex - alphabet.count])
            }
        }
    }
    return encrypted
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: "hi") == "lm")
assert(encrypt(s: "asdfghjkl") == "ewhjklnop")
assert(encrypt(s: "gf") == "kj")
assert(encrypt(s: "et") == "ix")
assert(encrypt(s: "faewfawefaewg") == "jeiajeaijeiak")
assert(encrypt(s: "hellomyfriend") == "lippsqcjvmirh")
assert(encrypt(s: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
assert(encrypt(s: "a") == "e")



// ----------- problem HumanEval_137_compare_one, completion 13 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 170 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1e_r5z9l.swift:18:28: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = index + 2
                           ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    var vowels = "aeiou"
    for char in message {
        if vowels.contains(char) {
            let index = vowels.firstIndex(of: char)!
            let newIndex = index + 2
            encodedMessage.append(vowels[newIndex])
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 121 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 52 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_89_encrypt, completion 94 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpjw1lent1.swift:21:28: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = index + 2
                           ^

*/
/* stdout = 

*/


/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(s: "hi")
/// "lm"
/// >>> encrypt(s: "asdfghjkl")
/// "ewhjklnop"
/// >>> encrypt(s: "gf")
/// "kj"
/// >>> encrypt(s: "et")
/// "ix"
func encrypt(s: String) -> String {
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    let lowercaseS = s.lowercased()
    var encrypted = ""
    for char in lowercaseS {
        if let index = alphabet.firstIndex(of: char) {
            let newIndex = index + 2
            if newIndex > 25 {
                let remainder = newIndex - 26
                encrypted.append(alphabet[remainder])
            } else {
                encrypted.append(alphabet[newIndex])
            }
        }
    }
    return encrypted
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: "hi") == "lm")
assert(encrypt(s: "asdfghjkl") == "ewhjklnop")
assert(encrypt(s: "gf") == "kj")
assert(encrypt(s: "et") == "ix")
assert(encrypt(s: "faewfawefaewg") == "jeiajeaijeiak")
assert(encrypt(s: "hellomyfriend") == "lippsqcjvmirh")
assert(encrypt(s: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
assert(encrypt(s: "a") == "e")



// ----------- problem HumanEval_137_compare_one, completion 53 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 47 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 157 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpw9wuupe9.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = (index + 2) % letters.count
                encodedMessage.append(letters[newIndex].uppercased())
            } else {
                encodedMessage.append(letters[index].uppercased())
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 60 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 98 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 164 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_78_hex_key, completion 68 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_137_compare_one, completion 136 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 37 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 164 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_140_fix_spaces, completion 148 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf1rsqq9s.swift:24:23: error: cannot convert value of type 'Character' to expected argument type 'String'
            result += c
                      ^

*/
/* stdout = 

*/


/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(text: " Example")
/// "Example"
/// >>> fix_spaces(text: " Example 1")
/// "Example_1"
/// >>> fix_spaces(text: " Example 2")
/// "_Example_2"
/// >>> fix_spaces(text: " Example 3")
/// "_Example-3"
func fix_spaces(text: String) -> String {
    var result = ""
    var space_count = 0
    for c in text {
        if c == " " {
            space_count += 1
            if space_count >= 2 {
                result += "-"
                space_count = 0
            }
        } else {
            result += c
            space_count = 0
        }
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: "Example") == "Example")
assert(fix_spaces(text: "Mudasir Hanif ") == "Mudasir_Hanif_")
assert(fix_spaces(text: "Yellow Yellow  Dirty  Fellow") == "Yellow_Yellow__Dirty__Fellow")
assert(fix_spaces(text: "Exa   mple") == "Exa-mple")
assert(fix_spaces(text: "   Exa 1 2 2 mple") == "-Exa_1_2_2_mple")



// ----------- problem HumanEval_66_digitSum, completion 30 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 37 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 122 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp9nl3aw5w.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(letters[letters.index(index, offsetBy: 2)])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 107 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 164 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 80 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqvnis_b6.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmpqvnis_b6.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmpqvnis_b6.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmpqvnis_b6.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    if area.isNaN {
        return -1
    }
    return area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_66_digitSum, completion 128 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 63 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 103 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 23 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf_s5tcnw.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index].uppercased())
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 115 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 55 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 122 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 24 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp9nl3aw5w.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(letters[letters.index(index, offsetBy: 2)])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 141 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmxv2s6mq.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = index + 2
                encodedMessage.append(letters[newIndex % letters.count])
            } else {
                encodedMessage.append(letters[index].uppercased())
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 70 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp0wqox0so.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = (index + 2) % alphabet.count
            let newChar = alphabet[newIndex]
            encoded.append(vowels.contains(char.lowercased()) ? newChar : newChar.uppercased())
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 136 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp22mm_n00.swift:21:29: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = (index + 2) % 5
                            ^
/tmp/tmp22mm_n00.swift:25:29: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = (index + 2) % 5
                            ^
/tmp/tmp22mm_n00.swift:29:29: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = (index + 2) % 26
                            ^
/tmp/tmp22mm_n00.swift:33:29: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = (index + 2) % 26
                            ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let vowelsUpper = "AEIOU"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    let lettersUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    var encoded = ""
    for char in message {
        if vowels.contains(char) {
            let index = vowels.firstIndex(of: char)!
            let newIndex = (index + 2) % 5
            encoded.append(vowels[newIndex])
        } else if vowelsUpper.contains(char) {
            let index = vowelsUpper.firstIndex(of: char)!
            let newIndex = (index + 2) % 5
            encoded.append(vowelsUpper[newIndex])
        } else if letters.contains(char) {
            let index = letters.firstIndex(of: char)!
            let newIndex = (index + 2) % 26
            encoded.append(letters[newIndex])
        } else if lettersUpper.contains(char) {
            let index = lettersUpper.firstIndex(of: char)!
            let newIndex = (index + 2) % 26
            encoded.append(lettersUpper[newIndex])
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 135 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 1 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 88 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 32 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_89_encrypt, completion 84 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpz41oz6xl.swift:20:28: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = index + 2
                           ^

*/
/* stdout = 

*/


/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(s: "hi")
/// "lm"
/// >>> encrypt(s: "asdfghjkl")
/// "ewhjklnop"
/// >>> encrypt(s: "gf")
/// "kj"
/// >>> encrypt(s: "et")
/// "ix"
func encrypt(s: String) -> String {
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encryptedString = ""
    for letter in s {
        if let index = alphabet.firstIndex(of: letter) {
            let newIndex = index + 2
            if newIndex > alphabet.count - 1 {
                let newIndex = newIndex - alphabet.count
                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)])
            } else {
                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)])
            }
        }
    }
    return encryptedString
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: "hi") == "lm")
assert(encrypt(s: "asdfghjkl") == "ewhjklnop")
assert(encrypt(s: "gf") == "kj")
assert(encrypt(s: "et") == "ix")
assert(encrypt(s: "faewfawefaewg") == "jeiajeaijeiak")
assert(encrypt(s: "hellomyfriend") == "lippsqcjvmirh")
assert(encrypt(s: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
assert(encrypt(s: "a") == "e")



// ----------- problem HumanEval_66_digitSum, completion 73 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 43 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 5 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_161_solve, completion 67 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_78_hex_key, completion 28 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6f0psfkj.swift:25:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hexPrimes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_66_digitSum, completion 106 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 124 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 11 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 192 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 105 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 92 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_125_split_words, completion 132 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpzbnw1q_a.swift:23:20: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
                if index % 2 == 1 {
                   ^

*/
/* stdout = 

*/


extension Int: Error {}
        
/// Given a string of words, return an array of words split on whitespace, if no whitespaces exists in the text you
/// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
/// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
/// Examples
/// >>> split_words(txt: "Hello world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "Hello,world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "abcdef")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains(" ") {
        return .success(txt.split(separator: " ").map{String($0)})
    } else if txt.contains(",") {
        return .success(txt.split(separator: ",").map{String($0)})
    } else {
        var count = 0
        for char in txt {
            if let index = "abcdefghijklmnopqrstuvwxyz".firstIndex(of: char) {
                if index % 2 == 1 {
                    count += 1
                }
            }
        }
        return .failure(count)
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: "Hello world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello,world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello world,!") == .success(["Hello", "world,!"]))
assert(split_words(txt: "Hello,Hello,world !") == .success(["Hello,Hello,world", "!"]))
assert(split_words(txt: "abcdef") == .failure(3))
assert(split_words(txt: "aaabb") == .failure(2))
assert(split_words(txt: "aaaBb") == .failure(1))
assert(split_words(txt: "") == .failure(0))



// ----------- problem HumanEval_27_flip_case, completion 124 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_118_get_closest_vowel, completion 195 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmptwar4nye.swift:23:26: error: cannot assign value of type 'String.Index' to type 'Int'
            index = word.index(after: i)
                    ~~~~~^~~~~~~~~~~~~~~
/tmp/tmptwar4nye.swift:28:28: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.
        if vowels.contains(word[i]) {
                           ^~~~~~~
Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here
    public subscript(i: Int) -> Character { get }
           ^
/tmp/tmptwar4nye.swift:29:28: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.
            vowel = String(word[i])
                           ^~~~~~~
Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here
    public subscript(i: Int) -> Character { get }
           ^

*/
/* stdout = 

*/


/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(word: "yogurt")
/// "u"
/// >>> get_closest_vowel(word: "FULL")
/// "U"
/// >>> get_closest_vowel(word: "quick")
/// ""
/// >>> get_closest_vowel(word: "ab")
/// ""
func get_closest_vowel(word: String) -> String {
    let vowels = "aeiouAEIOU"
    let consonants = "bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"
    var vowel = ""
    var index = 0
    for i in word.indices.reversed() {
        if consonants.contains(word[i]) {
            index = word.index(after: i)
            break
        }
    }
    for i in index..<word.count {
        if vowels.contains(word[i]) {
            vowel = String(word[i])
            break
        }
    }
    return vowel
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: "yogurt") == "u")
assert(get_closest_vowel(word: "full") == "u")
assert(get_closest_vowel(word: "easy") == "")
assert(get_closest_vowel(word: "eAsy") == "")
assert(get_closest_vowel(word: "ali") == "")
assert(get_closest_vowel(word: "bad") == "a")
assert(get_closest_vowel(word: "most") == "o")
assert(get_closest_vowel(word: "ab") == "")
assert(get_closest_vowel(word: "ba") == "")
assert(get_closest_vowel(word: "quick") == "")
assert(get_closest_vowel(word: "anime") == "i")
assert(get_closest_vowel(word: "Asia") == "")
assert(get_closest_vowel(word: "Above") == "o")



// ----------- problem HumanEval_137_compare_one, completion 123 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 68 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpn4xh_kmc.swift:63:9: error: expected pattern
    case
        ^
/tmp/tmpn4xh_kmc.swift:63:9: error: expected ':' after 'case'
    case
        ^
/tmp/tmpn4xh_kmc.swift:86:66: error: expected '}' at end of brace statement
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)
                                                                 ^
/tmp/tmpn4xh_kmc.swift:21:48: note: to match this opening '{'
func compare_one(a: Value, b: Value) -> Value? {
                                               ^
/tmp/tmpn4xh_kmc.swift:29:54: error: binary operator '==' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a == b:
                                                   ~ ^  ~
/tmp/tmpn4xh_kmc.swift:29:54: note: overloads for '==' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a == b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:31:54: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                   ~ ^ ~
/tmp/tmpn4xh_kmc.swift:31:54: note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:33:54: error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                   ~ ^ ~
/tmp/tmpn4xh_kmc.swift:33:54: note: overloads for '<' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:35:54: error: binary operator '==' cannot be applied to operands of type 'Int' and 'String'
    case let (.intValue(a)
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case let (.intValue(a), .intValue(b)) where a == b:
        return nil
    case let (.intValue(a), .intValue(b)) where a > b:
        return a
    case let (.intValue(a), .intValue(b)) where a < b:
        return b
    case let (.intValue(a), .doubleValue(b)) where a == b:
        return nil
    case let (.intValue(a), .doubleValue(b)) where a > b:
        return a
    case let (.intValue(a), .doubleValue(b)) where a < b:
        return b
    case let (.intValue(a), .stringValue(b)) where a == b:
        return nil
    case let (.intValue(a), .stringValue(b)) where a > b:
        return a
    case let (.intValue(a), .stringValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .intValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .intValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .intValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .doubleValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .doubleValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .doubleValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .stringValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .stringValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .stringValue(b)) where a < b:
        return b
    case let (.stringValue(a), .intValue(b)) where a == b:
        return nil
    case let (.stringValue(a), .intValue(b)) where a > b:
        return a
    case
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 150 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 148 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 151 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 179 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 91 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_125_split_words, completion 18 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpcvjo0n2j.swift:20:137: error: cannot convert value of type 'UInt8' to closure result type 'Int'
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~
                                                                                                                 Int(                       )

*/
/* stdout = 

*/


extension Int: Error {}
        
/// Given a string of words, return an array of words split on whitespace, if no whitespaces exists in the text you
/// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
/// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
/// Examples
/// >>> split_words(txt: "Hello world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "Hello,world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "abcdef")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains(" ") {
        return .success(txt.split(separator: " ").map(String.init))
    } else if txt.contains(",") {
        return .success(txt.split(separator: ",").map(String.init))
    } else {
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: "Hello world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello,world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello world,!") == .success(["Hello", "world,!"]))
assert(split_words(txt: "Hello,Hello,world !") == .success(["Hello,Hello,world", "!"]))
assert(split_words(txt: "abcdef") == .failure(3))
assert(split_words(txt: "aaabb") == .failure(2))
assert(split_words(txt: "aaaBb") == .failure(1))
assert(split_words(txt: "") == .failure(0))



// ----------- problem HumanEval_137_compare_one, completion 48 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 199 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 61 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_10_make_palindrome, completion 176 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpkgea8pc5.swift:13:25: error: 'characters' is unavailable: Please use String directly
    let string = string.characters.map { String($0) }
                        ^~~~~~~~~~
Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0
    public var characters: String { get set }
               ^
/tmp/tmpkgea8pc5.swift:15:72: error: cannot find 'longest_palindromic_suffix' in scope
    let prefix = reversed.prefix(upTo: reversed.endIndex.advanced(by: -longest_palindromic_suffix(string: string).count))
                                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpkgea8pc5.swift:15:58: error: value of type 'ReversedCollection<[String]>.Index' has no member 'advanced'
    let prefix = reversed.prefix(upTo: reversed.endIndex.advanced(by: -longest_palindromic_suffix(string: string).count))
                                       ~~~~~~~~~~~~~~~~~ ^~~~~~~~
/tmp/tmpkgea8pc5.swift:16:19: error: operator function '+' requires the types 'String.Element' (aka 'Character') and 'String' be equivalent
    return string + prefix.reversed()
                  ^
Swift.RangeReplaceableCollection:3:35: note: where 'Self.Element' = 'String.Element' (aka 'Character'), 'Other.Element' = 'String'
    @inlinable public static func + <Other>(lhs: Other, rhs: Self) -> Self where Other : Sequence, Self.Element == Other.Element
                                  ^

*/
/* stdout = 

*/


/// Find the shortest palindrome that begins with a supplied string.
/// Algorithm idea is simple:
/// - Find the longest postfix of supplied string that is a palindrome.
/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
/// >>> make_palindrome(string: "")
/// ""
/// >>> make_palindrome(string: "cat")
/// "catac"
/// >>> make_palindrome(string: "cata")
/// "catac"
func make_palindrome(string: String) -> String {
    let string = string.characters.map { String($0) }
    let reversed = string.reversed()
    let prefix = reversed.prefix(upTo: reversed.endIndex.advanced(by: -longest_palindromic_suffix(string: string).count))
    return string + prefix.reversed()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_palindrome(string: "") == "")
assert(make_palindrome(string: "x") == "x")
assert(make_palindrome(string: "xyz") == "xyzyx")
assert(make_palindrome(string: "xyx") == "xyx")
assert(make_palindrome(string: "jerry") == "jerryrrej")



// ----------- problem HumanEval_99_closest_integer, completion 38 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmppyxdyz9s.swift:20:31: error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'
    let floorDiff = abs(floor - number)
                        ~~~~~ ^ ~~~~~~
/tmp/tmppyxdyz9s.swift:20:31: note: overloads for '-' exist with these partially matching parameter lists: (Double, Double), (Int, Int)
    let floorDiff = abs(floor - number)
                              ^
/tmp/tmppyxdyz9s.swift:21:29: error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'
    let ceilDiff = abs(ceil - number)
                       ~~~~ ^ ~~~~~~
/tmp/tmppyxdyz9s.swift:21:29: note: overloads for '-' exist with these partially matching parameter lists: (Double, Double), (Int, Int)
    let ceilDiff = abs(ceil - number)
                            ^

*/
/* stdout = 

*/


/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(value: "10")
/// 10
/// >>> closest_integer(value: "15.3")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
func closest_integer(value: String) -> Int {
    let number = Double(value)!
    let rounded = Int(number.rounded())
    let floor = Int(number.rounded(.down))
    let ceil = Int(number.rounded(.up))
    let floorDiff = abs(floor - number)
    let ceilDiff = abs(ceil - number)
    if floorDiff == ceilDiff {
        return floor > 0 ? floor : ceil
    }
    return floorDiff < ceilDiff ? floor : ceil
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: "10") == 10)
assert(closest_integer(value: "14.5") == 15)
assert(closest_integer(value: "-15.5") == -16)
assert(closest_integer(value: "15.3") == 15)
assert(closest_integer(value: "0") == 0)



// ----------- problem HumanEval_93_encode, completion 20 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpimzr0vow.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var result = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                if let nextIndex = alphabet.index(index, offsetBy: 2, limitedBy: alphabet.endIndex) {
                    result.append(alphabet[nextIndex])
                } else {
                    result.append(alphabet[alphabet.startIndex])
                }
            } else {
                result.append(char)
            }
        } else {
            result.append(char)
        }
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 61 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 128 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 139 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 73 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpiw2027q5.swift:55:1: error: expected ')' in expression list
}
^
/tmp/tmpiw2027q5.swift:54:28: note: to match this opening '('
        return .doubleValue(b
                           ^
/tmp/tmpiw2027q5.swift:77:66: error: expected '}' at end of brace statement
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)
                                                                 ^
/tmp/tmpiw2027q5.swift:21:48: note: to match this opening '{'
func compare_one(a: Value, b: Value) -> Value? {
                                               ^
/tmp/tmpiw2027q5.swift:27:54: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                   ~ ^ ~
/tmp/tmpiw2027q5.swift:27:54: note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                     ^
/tmp/tmpiw2027q5.swift:29:54: error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                   ~ ^ ~
/tmp/tmpiw2027q5.swift:29:54: note: overloads for '<' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                     ^
/tmp/tmpiw2027q5.swift:31:65: error: cannot convert value of type 'Double' to expected argument type 'Int'
    case let (.intValue(a), .stringValue(b)) where a > Double(b)!:
                                                                ^
                                                       Int(      )
/tmp/tmpiw2027q5.swift:33:65: error: cannot convert value of type 'Double' to expected argument type 'Int'
    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:
                                                                ^
                   
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case let (.intValue(a), .intValue(b)) where a > b:
        return .intValue(a)
    case let (.intValue(a), .intValue(b)) where a < b:
        return .intValue(b)
    case let (.intValue(a), .doubleValue(b)) where a > b:
        return .intValue(a)
    case let (.intValue(a), .doubleValue(b)) where a < b:
        return .doubleValue(b)
    case let (.intValue(a), .stringValue(b)) where a > Double(b)!:
        return .intValue(a)
    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:
        return .stringValue(b)
    case let (.doubleValue(a), .intValue(b)) where a > b:
        return .doubleValue(a)
    case let (.doubleValue(a), .intValue(b)) where a < b:
        return .intValue(b)
    case let (.doubleValue(a), .doubleValue(b)) where a > b:
        return .doubleValue(a)
    case let (.doubleValue(a), .doubleValue(b)) where a < b:
        return .doubleValue(b)
    case let (.doubleValue(a), .stringValue(b)) where a > Double(b)!:
        return .doubleValue(a)
    case let (.doubleValue(a), .stringValue(b)) where a < Double(b)!:
        return .stringValue(b)
    case let (.stringValue(a), .intValue(b)) where Double(a)! > b:
        return .stringValue(a)
    case let (.stringValue(a), .intValue(b)) where Double(a)! < b:
        return .intValue(b)
    case let (.stringValue(a), .doubleValue(b)) where Double(a)! > b:
        return .stringValue(a)
    case let (.stringValue(a), .doubleValue(b)) where Double(a)! < b:
        return .doubleValue(b
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 107 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp8g22rqq_.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 154 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 69 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 113 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp3zst758o.swift:19:73: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + (65...90 ~= $1.asciiValue! ? $1.asciiValue! : 0) }
                                                           ~~~~~~~~~~~~~^
                                                           Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + (65...90 ~= $1.asciiValue! ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 71 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6jwuw36t.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(letter)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_11_string_xor, completion 3 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let xor = zip(a, b).map { $0 ^ $1 }
    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_27_flip_case, completion 113 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 109 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 127 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 10 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp9nl3aw5w.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(letters[letters.index(index, offsetBy: 2)])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 61 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpydwf9ohy.swift:17:58: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: character.lowercased()) {
                                                         ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for character in message {
        if let index = alphabet.firstIndex(of: character.lowercased()) {
            if vowels.contains(character.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(character)
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 54 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_125_split_words, completion 102 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpwtnuxrey.swift:20:137: error: cannot convert value of type 'UInt8' to closure result type 'Int'
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~
                                                                                                                 Int(                       )

*/
/* stdout = 

*/


extension Int: Error {}
        
/// Given a string of words, return an array of words split on whitespace, if no whitespaces exists in the text you
/// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
/// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
/// Examples
/// >>> split_words(txt: "Hello world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "Hello,world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "abcdef")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains(" ") {
        return .success(txt.split(separator: " ").map { String($0) })
    } else if txt.contains(",") {
        return .success(txt.split(separator: ",").map { String($0) })
    } else {
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: "Hello world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello,world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello world,!") == .success(["Hello", "world,!"]))
assert(split_words(txt: "Hello,Hello,world !") == .success(["Hello,Hello,world", "!"]))
assert(split_words(txt: "abcdef") == .failure(3))
assert(split_words(txt: "aaabb") == .failure(2))
assert(split_words(txt: "aaaBb") == .failure(1))
assert(split_words(txt: "") == .failure(0))



// ----------- problem HumanEval_27_flip_case, completion 174 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 41 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 133 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpn3pdch7_.swift:13:20: error: cannot convert return expression of type '[String]' to return type 'String'
    return message.map {
           ~~~~~~~~^~~~~

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    return message.map {
        switch $0 {
        case "a":
            return "c"
        case "e":
            return "g"
        case "i":
            return "k"
        case "o":
            return "q"
        case "u":
            return "y"
        case "A":
            return "C"
        case "E":
            return "G"
        case "I":
            return "K"
        case "O":
            return "Q"
        case "U":
            return "Y"
        default:
            return $0.isUppercase ? $0.lowercased() : $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 51 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 125 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpub33i_0j.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = index + 2
            let newChar = alphabet[newIndex % alphabet.count]
            encoded.append(vowels.contains(char.lowercased()) ? newChar : newChar.uppercased())
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 131 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 176 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 40 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 87 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 190 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_11_string_xor, completion 25 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let xor = zip(a, b).map { $0 ^ $1 }
    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_27_flip_case, completion 7 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 20 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 193 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 26 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 82 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpklqm5d31.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^
/tmp/tmpklqm5d31.swift:18:60: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            if let vowelIndex = vowels.firstIndex(of: char.lowercased()) {
                                                           ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if let vowelIndex = vowels.firstIndex(of: char.lowercased()) {
                encodedMessage.append(vowels[vowels.index(vowelIndex, offsetBy: 2)])
            } else {
                encodedMessage.append(letters[letters.index(index, offsetBy: 1)])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_161_solve, completion 78 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_137_compare_one, completion 6 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 53 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 198 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 110 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 116 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 108 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 26 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 130 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 186 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 117 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 148 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_17_parse_music, completion 196 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp3804yl3g.swift:18:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmp3804yl3g.swift:20:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    var currentBeat = 0
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            break
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_140_fix_spaces, completion 67 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpttumpz2g.swift:31:21: error: cannot assign value of type 'Character' to type 'String'
        prev_char = char
                    ^~~~

*/
/* stdout = 

*/


/// Given a string text, replace all spaces in it with underscores, 
/// and if a string has more than 2 consecutive spaces, 
/// then replace all consecutive spaces with - 
/// >>> fix_spaces(text: " Example")
/// "Example"
/// >>> fix_spaces(text: " Example 1")
/// "Example_1"
/// >>> fix_spaces(text: " Example 2")
/// "_Example_2"
/// >>> fix_spaces(text: " Example 3")
/// "_Example-3"
func fix_spaces(text: String) -> String {
    var result = ""
    var prev_char = ""
    var space_count = 0
    for char in text {
        if char == " " {
            space_count += 1
            if space_count > 2 {
                continue
            }
        } else {
            space_count = 0
        }
        if prev_char == " " && char == " " {
            result.append("-")
        } else {
            result.append(char)
        }
        prev_char = char
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: "Example") == "Example")
assert(fix_spaces(text: "Mudasir Hanif ") == "Mudasir_Hanif_")
assert(fix_spaces(text: "Yellow Yellow  Dirty  Fellow") == "Yellow_Yellow__Dirty__Fellow")
assert(fix_spaces(text: "Exa   mple") == "Exa-mple")
assert(fix_spaces(text: "   Exa 1 2 2 mple") == "-Exa_1_2_2_mple")



// ----------- problem HumanEval_17_parse_music, completion 134 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp16bfopoh.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmp16bfopoh.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var result: [Int] = []
    for char in music_string {
        switch char {
        case "o":
            result.append(4)
        case "o|":
            result.append(2)
        case ".|":
            result.append(1)
        default:
            break
        }
    }
    return result
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_27_flip_case, completion 156 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 175 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 184 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 23 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 58 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdghtrdhl.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 91 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 96 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 25 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 121 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 121 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 51 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 77 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdghtrdhl.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_161_solve, completion 129 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_66_digitSum, completion 11 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 115 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 138 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 19 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 80 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 41 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 167 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 98 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 101 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpwoei_vio.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 89 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 103 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 70 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 166 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_11_string_xor, completion 105 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_27_flip_case, completion 134 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_14_all_prefixes, completion 152 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpaow8jwz9.swift:6:44: error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to closure result type 'String'
    return (1...string.count).map { string.prefix($0) }
                                    ~~~~~~~^~~~~~~~~~
                                    String(          )

*/
/* stdout = 

*/


/// Return array of all prefixes from shortest to longest of the input string
/// >>> all_prefixes(string: "abc")
/// ["a", "ab", "abc"]
func all_prefixes(string: String) -> [String] {
    return (1...string.count).map { string.prefix($0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: "") == [] as [String])
assert(all_prefixes(string: "asdfgh") == ["a", "as", "asd", "asdf", "asdfg", "asdfgh"])
assert(all_prefixes(string: "WWW") == ["W", "WW", "WWW"])



// ----------- problem HumanEval_93_encode, completion 48 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp0_iggg13.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = letters.index(index, offsetBy: 2)
                encoded.append(letters[newIndex])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 144 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 112 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmfspvc39.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map({ $0.isUppercase ? $0.lowercased() : $0.uppercased() })
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map({ $0.isUppercase ? $0.lowercased() : $0.uppercased() })
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_78_hex_key, completion 184 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6f0psfkj.swift:25:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hexPrimes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_93_encode, completion 34 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdghtrdhl.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 119 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 29 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpxm5mtxx0.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = letters.index(index, offsetBy: 2)
                encodedMessage.append(letters[newIndex])
            } else {
                encodedMessage.append(letters[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 146 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 188 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 153 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_161_solve, completion 159 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpt1jbl1om.swift:20:86: error: operator function '+' requires the types 'String.Element' (aka 'Character') and 'String' be equivalent
    return String(letters.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() } + nonLetters.reversed())
                                                                                     ^
Swift.RangeReplaceableCollection:3:35: note: where 'Self.Element' = 'String.Element' (aka 'Character'), 'Other.Element' = 'String'
    @inlinable public static func + <Other>(lhs: Other, rhs: Self) -> Self where Other : Sequence, Self.Element == Other.Element
                                  ^

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    let nonLetters = s.filter { !$0.isLetter }
    if letters.isEmpty {
        return String(nonLetters.reversed())
    }
    return String(letters.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() } + nonLetters.reversed())
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 179 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 85 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_78_hex_key, completion 116 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_66_digitSum, completion 122 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_78_hex_key, completion 32 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6f0psfkj.swift:25:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hexPrimes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_48_is_palindrome, completion 197 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpa60t43r1.swift:21:26: error: cannot convert value of type '[Character]' to expected argument type 'Substring'
    return first == last.reversed()
                         ^

*/
/* stdout = 

*/


/// Checks if given string is a palindrome
/// >>> is_palindrome(text: "")
/// true
/// >>> is_palindrome(text: "aba")
/// true
/// >>> is_palindrome(text: "aaaaa")
/// true
/// >>> is_palindrome(text: "zbcd")
/// false
func is_palindrome(text: String) -> Bool {
    let length = text.count
    if length == 0 {
        return true
    }
    let mid = length / 2
    let start = text.index(text.startIndex, offsetBy: 0)
    let end = text.index(text.startIndex, offsetBy: mid)
    let first = text[start..<end]
    let last = text[text.index(text.endIndex, offsetBy: -mid)..<text.endIndex]
    return first == last.reversed()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: "") == true)
assert(is_palindrome(text: "aba") == true)
assert(is_palindrome(text: "aaaaa") == true)
assert(is_palindrome(text: "zbcd") == false)
assert(is_palindrome(text: "xywyx") == true)
assert(is_palindrome(text: "xywyz") == false)
assert(is_palindrome(text: "xywzx") == false)



// ----------- problem HumanEval_66_digitSum, completion 162 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 21 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 161 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpj0g53ty1.swift:16:37: error: incorrect argument label in call (have 'char:', expected 'message:')
            encodedMessage += encode(char: char)
                                    ^~~~~
                                     message
/tmp/tmpj0g53ty1.swift:16:44: error: cannot convert value of type 'Character' to expected argument type 'String'
            encodedMessage += encode(char: char)
                                           ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    for char in message {
        if char.isLetter {
            encodedMessage += encode(char: char)
        } else {
            encodedMessage += String(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_161_solve, completion 16 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_66_digitSum, completion 71 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 127 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_11_string_xor, completion 52 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_11_string_xor, completion 159 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_161_solve, completion 6 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 49 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 175 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 139 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 19 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 127 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpk3w0lfg5.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmpk3w0lfg5.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmpk3w0lfg5.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmpk3w0lfg5.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpk3w0lfg5.swift:18:19: error: cannot find 'round' in scope
    return Double(round(100 * area) / 100)
                  ^~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    if area.isNaN {
        return -1
    }
    return Double(round(100 * area) / 100)
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_11_string_xor, completion 131 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpzp7rk339.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpzp7rk339.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let c = zip(a, b).map { $0 ^ $1 }
    return c.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_66_digitSum, completion 185 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 93 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 190 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 59 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpd1dl18y7.swift:18:42: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            let index = vowels.index(of: charLower)!
                                         ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    for char in message {
        let charLower = char.lowercased()
        if vowels.contains(charLower) {
            let index = vowels.index(of: charLower)!
            let nextIndex = (index + 2) % 5
            encoded.append(vowels[nextIndex].uppercased())
        } else {
            encoded.append(char.uppercased())
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 149 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_78_hex_key, completion 46 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_118_get_closest_vowel, completion 20 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpz7kjhcsf.swift:23:62: error: cannot convert value of type 'Int' to expected argument type 'String.Index'
                if word[word.index(before: word.index(after: index))] != char && word[word.index(after: word.index(before: index))] != char {
                                                             ^
/tmp/tmpz7kjhcsf.swift:23:124: error: cannot convert value of type 'Int' to expected argument type 'String.Index'
                if word[word.index(before: word.index(after: index))] != char && word[word.index(after: word.index(before: index))] != char {
                                                                                                                           ^

*/
/* stdout = 

*/


/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(word: "yogurt")
/// "u"
/// >>> get_closest_vowel(word: "FULL")
/// "U"
/// >>> get_closest_vowel(word: "quick")
/// ""
/// >>> get_closest_vowel(word: "ab")
/// ""
func get_closest_vowel(word: String) -> String {
    let vowels = "aeiouAEIOU"
    var closest_vowel = ""
    var closest_index = word.count
    for (index, char) in word.enumerated() {
        if vowels.contains(char) {
            if index > 0 && index < word.count - 1 {
                if word[word.index(before: word.index(after: index))] != char && word[word.index(after: word.index(before: index))] != char {
                    if index < closest_index {
                        closest_index = index
                        closest_vowel = String(char)
                    }
                }
            }
        }
    }
    return closest_vowel
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: "yogurt") == "u")
assert(get_closest_vowel(word: "full") == "u")
assert(get_closest_vowel(word: "easy") == "")
assert(get_closest_vowel(word: "eAsy") == "")
assert(get_closest_vowel(word: "ali") == "")
assert(get_closest_vowel(word: "bad") == "a")
assert(get_closest_vowel(word: "most") == "o")
assert(get_closest_vowel(word: "ab") == "")
assert(get_closest_vowel(word: "ba") == "")
assert(get_closest_vowel(word: "quick") == "")
assert(get_closest_vowel(word: "anime") == "i")
assert(get_closest_vowel(word: "Asia") == "")
assert(get_closest_vowel(word: "Above") == "o")



// ----------- problem HumanEval_137_compare_one, completion 1 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpiw2027q5.swift:55:1: error: expected ')' in expression list
}
^
/tmp/tmpiw2027q5.swift:54:28: note: to match this opening '('
        return .doubleValue(b
                           ^
/tmp/tmpiw2027q5.swift:77:66: error: expected '}' at end of brace statement
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)
                                                                 ^
/tmp/tmpiw2027q5.swift:21:48: note: to match this opening '{'
func compare_one(a: Value, b: Value) -> Value? {
                                               ^
/tmp/tmpiw2027q5.swift:27:54: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                   ~ ^ ~
/tmp/tmpiw2027q5.swift:27:54: note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                     ^
/tmp/tmpiw2027q5.swift:29:54: error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                   ~ ^ ~
/tmp/tmpiw2027q5.swift:29:54: note: overloads for '<' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                     ^
/tmp/tmpiw2027q5.swift:31:65: error: cannot convert value of type 'Double' to expected argument type 'Int'
    case let (.intValue(a), .stringValue(b)) where a > Double(b)!:
                                                                ^
                                                       Int(      )
/tmp/tmpiw2027q5.swift:33:65: error: cannot convert value of type 'Double' to expected argument type 'Int'
    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:
                                                                ^
                   
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case let (.intValue(a), .intValue(b)) where a > b:
        return .intValue(a)
    case let (.intValue(a), .intValue(b)) where a < b:
        return .intValue(b)
    case let (.intValue(a), .doubleValue(b)) where a > b:
        return .intValue(a)
    case let (.intValue(a), .doubleValue(b)) where a < b:
        return .doubleValue(b)
    case let (.intValue(a), .stringValue(b)) where a > Double(b)!:
        return .intValue(a)
    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:
        return .stringValue(b)
    case let (.doubleValue(a), .intValue(b)) where a > b:
        return .doubleValue(a)
    case let (.doubleValue(a), .intValue(b)) where a < b:
        return .intValue(b)
    case let (.doubleValue(a), .doubleValue(b)) where a > b:
        return .doubleValue(a)
    case let (.doubleValue(a), .doubleValue(b)) where a < b:
        return .doubleValue(b)
    case let (.doubleValue(a), .stringValue(b)) where a > Double(b)!:
        return .doubleValue(a)
    case let (.doubleValue(a), .stringValue(b)) where a < Double(b)!:
        return .stringValue(b)
    case let (.stringValue(a), .intValue(b)) where Double(a)! > b:
        return .stringValue(a)
    case let (.stringValue(a), .intValue(b)) where Double(a)! < b:
        return .intValue(b)
    case let (.stringValue(a), .doubleValue(b)) where Double(a)! > b:
        return .stringValue(a)
    case let (.stringValue(a), .doubleValue(b)) where Double(a)! < b:
        return .doubleValue(b
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 168 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 194 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1benokn4.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 29 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 11 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 161 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_78_hex_key, completion 166 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_78_hex_key, completion 6 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_27_flip_case, completion 107 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_78_hex_key, completion 106 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpcwx58er0.swift:27:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hex = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"]
    let primes = [2, 3, 5, 7, 11, 13]
    let hexPrimes = Set(primes.map { hex[$0] })
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_161_solve, completion 108 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 38 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 46 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 60 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmping7nz6r.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isLowercase {
            return $0.uppercased()
        } else {
            return $0.lowercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 132 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 137 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_66_digitSum, completion 42 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 123 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 155 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmtt5qxuy.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 35 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_78_hex_key, completion 45 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6f0psfkj.swift:25:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hexPrimes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_89_encrypt, completion 198 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpc6s2xxa_.swift:20:28: error: cannot convert value of type 'String.Index' to expected argument type 'Int'
            let newIndex = index + 2 * 2
                           ^

*/
/* stdout = 

*/


/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(s: "hi")
/// "lm"
/// >>> encrypt(s: "asdfghjkl")
/// "ewhjklnop"
/// >>> encrypt(s: "gf")
/// "kj"
/// >>> encrypt(s: "et")
/// "ix"
func encrypt(s: String) -> String {
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encrypted = ""
    for letter in s {
        if let index = alphabet.firstIndex(of: letter) {
            let newIndex = index + 2 * 2
            if newIndex > alphabet.count - 1 {
                let newIndex = newIndex - alphabet.count
                encrypted.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)])
            } else {
                encrypted.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy: newIndex)])
            }
        }
    }
    return encrypted
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: "hi") == "lm")
assert(encrypt(s: "asdfghjkl") == "ewhjklnop")
assert(encrypt(s: "gf") == "kj")
assert(encrypt(s: "et") == "ix")
assert(encrypt(s: "faewfawefaewg") == "jeiajeaijeiak")
assert(encrypt(s: "hellomyfriend") == "lippsqcjvmirh")
assert(encrypt(s: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
assert(encrypt(s: "a") == "e")



// ----------- problem HumanEval_137_compare_one, completion 104 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 108 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmporg3lqz9.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            let isUpper = letter.isUppercase
            let newLetter = alphabet[alphabet.index(index, offsetBy: 2)]
            if isUpper {
                encoded.append(newLetter.uppercased())
            } else {
                encoded.append(newLetter)
            }
        } else {
            encoded.append(letter)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 67 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_17_parse_music, completion 4 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf7ewcezh.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpf7ewcezh.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            break
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_27_flip_case, completion 161 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 35 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 74 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 102 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 101 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 79 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 54 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 190 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 109 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 100 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 56 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 35 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpt2qkd78g.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 148 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 192 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 62 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_17_parse_music, completion 69 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf7ewcezh.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpf7ewcezh.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            break
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_93_encode, completion 182 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmknqi7c5.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encoded.append(alphabet[index].uppercased())
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 70 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 127 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 18 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 59 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 143 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 187 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 98 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6q_p1086.swift:17:48: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.index(of: char.lowercased()) {
                                               ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.index(of: char.lowercased()) {
            let newIndex = alphabet.index(index, offsetBy: 2)
            let newChar = alphabet[newIndex]
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(newChar)
            } else {
                encodedMessage.append(newChar.uppercased())
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_11_string_xor, completion 61 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpew43g2r7.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpew43g2r7.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpew43g2r7.swift:10:44: error: no exact matches in call to initializer 
    return result.reduce("") { $0 + String(UnicodeScalar(bitPattern: $1)) }
                                           ^
/tmp/tmpew43g2r7.swift:10:44: note: found candidate with type '(UInt8) -> UnicodeScalar' (aka '(UInt8) -> Unicode.Scalar')
    return result.reduce("") { $0 + String(UnicodeScalar(bitPattern: $1)) }
                                           ^
/tmp/tmpew43g2r7.swift:10:44: note: found candidate with type '(Unicode.Scalar) -> UnicodeScalar' (aka '(Unicode.Scalar) -> Unicode.Scalar')
    return result.reduce("") { $0 + String(UnicodeScalar(bitPattern: $1)) }
                                           ^

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(UnicodeScalar(bitPattern: $1)) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_78_hex_key, completion 82 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_27_flip_case, completion 3 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_89_encrypt, completion 158 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpm67jnnin.swift:18:39: error: incorrect argument label in call (have 'char:', expected 's:')
        encryptedString.append(encrypt(char: char))
                                      ^~~~~
                                       s
/tmp/tmpm67jnnin.swift:18:46: error: cannot convert value of type 'Character' to expected argument type 'String'
        encryptedString.append(encrypt(char: char))
                                             ^

*/
/* stdout = 

*/


/// Create a function encrypt that takes a string as an argument and
/// returns a string encrypted with the alphabet being rotated. 
/// The alphabet should be rotated in a manner such that the letters 
/// shift down by two multiplied to two places.
/// For example:
/// >>> encrypt(s: "hi")
/// "lm"
/// >>> encrypt(s: "asdfghjkl")
/// "ewhjklnop"
/// >>> encrypt(s: "gf")
/// "kj"
/// >>> encrypt(s: "et")
/// "ix"
func encrypt(s: String) -> String {
    var encryptedString = ""
    for char in s {
        encryptedString.append(encrypt(char: char))
    }
    return encryptedString
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: "hi") == "lm")
assert(encrypt(s: "asdfghjkl") == "ewhjklnop")
assert(encrypt(s: "gf") == "kj")
assert(encrypt(s: "et") == "ix")
assert(encrypt(s: "faewfawefaewg") == "jeiajeaijeiak")
assert(encrypt(s: "hellomyfriend") == "lippsqcjvmirh")
assert(encrypt(s: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
assert(encrypt(s: "a") == "e")



// ----------- problem HumanEval_161_solve, completion 132 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpxuvwaqep.swift:15:43: error: cannot convert value of type 'String.Element' (aka 'Character') to closure result type 'String'
    return s.reversed().map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }.joined()
                              ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    return s.reversed().map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 182 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmplsmk_9pj.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map {
           ~~~~~~~^~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map {
        if $0.isUppercase {
            return $0.lowercased()
        } else {
            return $0.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 29 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 26 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpaxrf5207.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 10 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 156 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_137_compare_one, completion 16 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 9 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 87 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 186 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 101 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_130_tri, completion 132 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpeqg34tul.swift:25:52: error: cannot convert return expression of type 'Array<Int>' to return type 'Int'
            return tri(n: $0 - 1) + tri(n: $0 - 2) + tri(n: $0 - 3)
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return an array of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
    return [Int](0...n).map {
        switch $0 {
        case 0: return 1
        case 1: return 3
        case 2: return 2
        default:
            return tri(n: $0 - 1) + tri(n: $0 - 2) + tri(n: $0 - 3)
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])



// ----------- problem HumanEval_27_flip_case, completion 51 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 95 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp436ps0f3.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(letters[index.advanced(by: 2)])
            } else {
                encodedMessage.append(letters[index].uppercased())
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 24 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_17_parse_music, completion 95 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpf7ewcezh.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpf7ewcezh.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            break
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_93_encode, completion 115 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp3xe01fm7.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 127 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmptwa036hk.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            let newIndex = index + 2
            let newChar = letters[newIndex % letters.count]
            encoded.append(vowels.contains(char.lowercased()) ? newChar : newChar.uppercased())
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_71_triangle_area, completion 177 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_66_digitSum, completion 150 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_11_string_xor, completion 32 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_93_encode, completion 76 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpexyh3mr0.swift:18:54: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            let index = alphabet.index(of: character.lowercased())!
                                                     ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for character in message {
        if vowels.contains(character.lowercased()) {
            let index = alphabet.index(of: character.lowercased())!
            let newIndex = alphabet.index(index, offsetBy: 2)
            encoded.append(alphabet[newIndex])
        } else {
            encoded.append(character.lowercased())
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 27 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpjaddy4bt.swift:17:63: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: String(letter).lowercased()) {
                                                              ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for letter in message {
        if let index = alphabet.firstIndex(of: String(letter).lowercased()) {
            if vowels.contains(String(letter).lowercased()) {
                encodedMessage += String(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage += String(alphabet[index]).uppercased()
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_78_hex_key, completion 124 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_66_digitSum, completion 119 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 18 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 151 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_161_solve, completion 123 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp2t1h34a9.swift:15:43: error: cannot convert value of type 'String.Element' (aka 'Character') to closure result type 'String'
    return s.reversed().map { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()
                              ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmp2t1h34a9.swift:15:60: error: result values in '? :' expression have mismatching types 'String' and 'String.Element' (aka 'Character')
    return s.reversed().map { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()
                                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    return s.reversed().map { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_93_encode, completion 85 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpyxi_vrfl.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            let newIndex = (index + 2) % letters.count
            encoded.append(letters[newIndex])
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_78_hex_key, completion 61 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_27_flip_case, completion 39 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 117 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 25 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 5 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_130_tri, completion 44 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpeqg34tul.swift:25:52: error: cannot convert return expression of type 'Array<Int>' to return type 'Int'
            return tri(n: $0 - 1) + tri(n: $0 - 2) + tri(n: $0 - 3)
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
/// the last couple centuries. However, what people don't know is Tribonacci sequence.
/// Tribonacci sequence is defined by the recurrence:
/// tri(1) = 3
/// tri(n) = 1 + n / 2, if n is even.
/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
/// For example:
/// tri(2) = 1 + (2 / 2) = 2
/// tri(4) = 3
/// tri(3) = tri(2) + tri(1) + tri(4)
/// = 2 + 3 + 3 = 8 
/// You are given a non-negative integer number n, you have to a return an array of the 
/// first n + 1 numbers of the Tribonacci sequence.
/// Examples:
/// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
    return [Int](0...n).map {
        switch $0 {
        case 0: return 1
        case 1: return 3
        case 2: return 2
        default:
            return tri(n: $0 - 1) + tri(n: $0 - 2) + tri(n: $0 - 3)
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])



// ----------- problem HumanEval_66_digitSum, completion 34 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 181 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 38 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 97 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 112 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 34 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 58 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 155 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_11_string_xor, completion 58 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_27_flip_case, completion 111 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 145 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 162 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp8g22rqq_.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 169 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 6 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 192 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 171 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp20p54_2_.swift:19:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            let index = alphabet.index(of: charString.lowercased())!
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        let charString = String(char)
        if vowels.contains(charString.lowercased()) {
            let index = alphabet.index(of: charString.lowercased())!
            let newIndex = alphabet.index(index, offsetBy: 2)
            encodedMessage += String(alphabet[newIndex]).uppercased()
        } else {
            encodedMessage += charString.uppercased()
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_78_hex_key, completion 128 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_161_solve, completion 196 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_66_digitSum, completion 92 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 102 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 84 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 90 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 52 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 134 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1u9zxijy.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if letter.isUppercase {
                encodedMessage.append(alphabet[index].uppercased())
            } else {
                encodedMessage.append(alphabet[index])
            }
        } else {
            encodedMessage.append(letter)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 76 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_118_get_closest_vowel, completion 145 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqye8xyse.swift:26:22: error: 'characters' is unavailable: Please use String directly
    for char in word.characters {
                     ^~~~~~~~~~
Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0
    public var characters: String { get set }
               ^
/tmp/tmpqye8xyse.swift:28:58: error: cannot assign value of type 'String.Index' to type 'Int'
            vowel_index = word.characters.index(of: char)!
                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
/tmp/tmpqye8xyse.swift:34:62: error: cannot assign value of type 'String.Index' to type 'Int'
            consonant_index = word.characters.index(of: char)!
                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^

*/
/* stdout = 

*/


/// You are given a word. Your task is to find the closest vowel that stands between 
/// two consonants from the right side of the word (case sensitive).
/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't
/// find any vowel met the above condition. 
/// You may assume that the given string contains English letter only.
/// Example:
/// >>> get_closest_vowel(word: "yogurt")
/// "u"
/// >>> get_closest_vowel(word: "FULL")
/// "U"
/// >>> get_closest_vowel(word: "quick")
/// ""
/// >>> get_closest_vowel(word: "ab")
/// ""
func get_closest_vowel(word: String) -> String {
    let vowels = "aeiou"
    let consonants = "bcdfghjklmnpqrstvwxyz"
    var closest_vowel = ""
    var closest_vowel_index = 0
    var closest_consonant_index = 0
    var closest_consonant_index_2 = 0
    var vowel_index = 0
    var consonant_index = 0
    var consonant_index_2 = 0
    for char in word.characters {
        if vowels.contains(String(char)) {
            vowel_index = word.characters.index(of: char)!
            if vowel_index > closest_vowel_index && vowel_index < closest_consonant_index {
                closest_vowel_index = vowel_index
                closest_vowel = String(char)
            }
        } else if consonants.contains(String(char)) {
            consonant_index = word.characters.index(of: char)!
            if consonant_index > closest_consonant_index {
                closest_consonant_index_2 = closest_consonant_index
                closest_consonant_index = consonant_index
            }
        }
    }
    if closest_vowel_index > closest_consonant_index_2 && closest_vowel_index < closest_consonant_index {
        return closest_vowel
    } else {
        return ""
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: "yogurt") == "u")
assert(get_closest_vowel(word: "full") == "u")
assert(get_closest_vowel(word: "easy") == "")
assert(get_closest_vowel(word: "eAsy") == "")
assert(get_closest_vowel(word: "ali") == "")
assert(get_closest_vowel(word: "bad") == "a")
assert(get_closest_vowel(word: "most") == "o")
assert(get_closest_vowel(word: "ab") == "")
assert(get_closest_vowel(word: "ba") == "")
assert(get_closest_vowel(word: "quick") == "")
assert(get_closest_vowel(word: "anime") == "i")
assert(get_closest_vowel(word: "Asia") == "")
assert(get_closest_vowel(word: "Above") == "o")



// ----------- problem HumanEval_66_digitSum, completion 114 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 124 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp4n_2vo0r.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = alphabet.index(index, offsetBy: 2)
            if vowels.contains(char.lowercased()) {
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[newIndex].uppercased())
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 43 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 144 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpbo9zxcql.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_161_solve, completion 127 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_17_parse_music, completion 153 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqs3wcyrc.swift:17:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case "o|":
             ^~~~
/tmp/tmpqs3wcyrc.swift:19:14: error: expression pattern of type 'String' cannot match values of type 'Character'
        case ".|":
             ^~~~

*/
/* stdout = 

*/


/// Input to this function is a string representing musical notes in a special ASCII format.
/// Your task is to parse this string and return array of integers corresponding to how many beats does each
/// not last.
/// Here is a legend:
/// 'o' - whole note, lasts four beats
/// 'o|' - half note, lasts two beats
/// '.|' - quater note, lasts one beat
/// >>> parse_music(music_string: "o o| .| o| o| .| .| .| .| o o")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
    var beats = [Int]()
    for char in music_string {
        switch char {
        case "o":
            beats.append(4)
        case "o|":
            beats.append(2)
        case ".|":
            beats.append(1)
        default:
            continue
        }
    }
    return beats
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: "") == [] as [Int])
assert(parse_music(music_string: "o o o o") == [4, 4, 4, 4])
assert(parse_music(music_string: ".| .| .| .|") == [1, 1, 1, 1])
assert(parse_music(music_string: "o| o| .| .| o o o o") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: "o| .| o| .| o o| o o|") == [2, 1, 2, 1, 4, 2, 4, 2])



// ----------- problem HumanEval_78_hex_key, completion 33 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6f0psfkj.swift:25:44: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { hexPrimes.contains($0) }.count
                                           ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let hexPrimes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { hexPrimes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_137_compare_one, completion 160 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 34 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 43 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp3a5x451f.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                if index + 2 > alphabet.count - 1 {
                    encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2 - alphabet.count)])
                } else {
                    encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
                }
            } else {
                encodedMessage.append(alphabet[index].uppercased())
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 75 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdi0a1f2_.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let alphabet = Array("abcdefghijklmnopqrstuvwxyz")
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage += alphabet[(index + 2) % alphabet.count].uppercased()
            } else {
                encodedMessage += alphabet[index].uppercased()
            }
        } else {
            encodedMessage += String(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 177 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 93 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 32 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp923f6r4b.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            let newIndex = index + 2
            if newIndex > letters.count - 1 {
                encodedMessage.append(letters[letters.index(letters.startIndex, offsetBy: newIndex - letters.count)])
            } else {
                encodedMessage.append(letters[letters.index(letters.startIndex, offsetBy: newIndex)])
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 23 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 37 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_71_triangle_area, completion 197 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpu3njmdwo.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmpu3njmdwo.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmpu3njmdwo.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmpu3njmdwo.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area > 0 ? area : -1
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_93_encode, completion 51 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpt0gwqcun.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^
/tmp/tmpt0gwqcun.swift:22:59: error: binary operator '==' cannot be applied to operands of type 'String' and 'Character'
                encodedMessage.append(letter.lowercased() == letter ? alphabet[index].uppercased() : alphabet[index])
                                      ~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
/tmp/tmpt0gwqcun.swift:22:59: note: overloads for '==' exist with these partially matching parameter lists: (Character, Character), (String, String)
                encodedMessage.append(letter.lowercased() == letter ? alphabet[index].uppercased() : alphabet[index])
                                                          ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(letter.lowercased() == letter ? alphabet[index].uppercased() : alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_146_specialFilter, completion 122 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpqsxt1bbk.swift:16:35: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'Int'
                if numString.first! % 2 != 0 {
                                  ^
/tmp/tmpqsxt1bbk.swift:17:38: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'Int'
                    if numString.last! % 2 != 0 {
                                     ^

*/
/* stdout = 

*/


/// Write a function that takes an array of numbers as input and returns 
/// the number of elements in the array that are greater than 10 and both 
/// first and last digits of a number are odd (1, 3, 5, 7, 9).
/// For example:
/// >>> specialFilter(nums: [15, -73, 14, -15])
/// 1
/// >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])
/// 2
func specialFilter(nums: [Int]) -> Int {
    var count = 0
    for num in nums {
        if num > 10 {
            if num % 2 != 0 {
                let numString = String(num)
                if numString.first! % 2 != 0 {
                    if numString.last! % 2 != 0 {
                        count += 1
                    }
                }
            }
        }
    }
    return count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(specialFilter(nums: [5, -2, 1, -5]) == 0)
assert(specialFilter(nums: [15, -73, 14, -15]) == 1)
assert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)
assert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)
assert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)
assert(specialFilter(nums: [1]) == 0)
assert(specialFilter(nums: [] as [Int]) == 0)



// ----------- problem HumanEval_27_flip_case, completion 162 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 95 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 101 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 171 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpa879whc8.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { char in
           ~~~~~~~^~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { char in
        if char.isUppercase {
            return char.lowercased()
        } else {
            return char.uppercased()
        }
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 137 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6c3hu3g6.swift:17:57: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: character.lowercased()) {
                                                        ^
/tmp/tmp6c3hu3g6.swift:18:42: error: value of type 'Character' has no member 'isUppercased'
            let isUppercased = character.isUppercased
                               ~~~~~~~~~ ^~~~~~~~~~~~

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for character in message {
        if let index = letters.firstIndex(of: character.lowercased()) {
            let isUppercased = character.isUppercased
            let newIndex = (index + 2) % letters.count
            let newCharacter = letters[newIndex]
            encodedMessage += isUppercased ? newCharacter.uppercased() : newCharacter
        } else {
            encodedMessage += String(character)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_161_solve, completion 188 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpquflvm7v.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmpquflvm7v.swift:19:37: error: value of type 'String.Element' (aka 'Character') has no member 'toggleCase'
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
                                 ~~ ^~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.toggleCase() : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 136 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_71_triangle_area, completion 171 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_137_compare_one, completion 106 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpiw2027q5.swift:55:1: error: expected ')' in expression list
}
^
/tmp/tmpiw2027q5.swift:54:28: note: to match this opening '('
        return .doubleValue(b
                           ^
/tmp/tmpiw2027q5.swift:77:66: error: expected '}' at end of brace statement
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)
                                                                 ^
/tmp/tmpiw2027q5.swift:21:48: note: to match this opening '{'
func compare_one(a: Value, b: Value) -> Value? {
                                               ^
/tmp/tmpiw2027q5.swift:27:54: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                   ~ ^ ~
/tmp/tmpiw2027q5.swift:27:54: note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                     ^
/tmp/tmpiw2027q5.swift:29:54: error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                   ~ ^ ~
/tmp/tmpiw2027q5.swift:29:54: note: overloads for '<' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                     ^
/tmp/tmpiw2027q5.swift:31:65: error: cannot convert value of type 'Double' to expected argument type 'Int'
    case let (.intValue(a), .stringValue(b)) where a > Double(b)!:
                                                                ^
                                                       Int(      )
/tmp/tmpiw2027q5.swift:33:65: error: cannot convert value of type 'Double' to expected argument type 'Int'
    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:
                                                                ^
                   
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case let (.intValue(a), .intValue(b)) where a > b:
        return .intValue(a)
    case let (.intValue(a), .intValue(b)) where a < b:
        return .intValue(b)
    case let (.intValue(a), .doubleValue(b)) where a > b:
        return .intValue(a)
    case let (.intValue(a), .doubleValue(b)) where a < b:
        return .doubleValue(b)
    case let (.intValue(a), .stringValue(b)) where a > Double(b)!:
        return .intValue(a)
    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:
        return .stringValue(b)
    case let (.doubleValue(a), .intValue(b)) where a > b:
        return .doubleValue(a)
    case let (.doubleValue(a), .intValue(b)) where a < b:
        return .intValue(b)
    case let (.doubleValue(a), .doubleValue(b)) where a > b:
        return .doubleValue(a)
    case let (.doubleValue(a), .doubleValue(b)) where a < b:
        return .doubleValue(b)
    case let (.doubleValue(a), .stringValue(b)) where a > Double(b)!:
        return .doubleValue(a)
    case let (.doubleValue(a), .stringValue(b)) where a < Double(b)!:
        return .stringValue(b)
    case let (.stringValue(a), .intValue(b)) where Double(a)! > b:
        return .stringValue(a)
    case let (.stringValue(a), .intValue(b)) where Double(a)! < b:
        return .intValue(b)
    case let (.stringValue(a), .doubleValue(b)) where Double(a)! > b:
        return .stringValue(a)
    case let (.stringValue(a), .doubleValue(b)) where Double(a)! < b:
        return .doubleValue(b
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 20 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 29 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 6 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp_vrwik0p.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encoded = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 46 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 0 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 129 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 179 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 137 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpxybj8ym5.swift:15:48: error: cannot convert value of type 'String.Element' (aka 'Character') to closure result type 'String'
    return s.isEmpty ? s : s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }.joined()
                                   ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    return s.isEmpty ? s : s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_99_closest_integer, completion 95 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpbvvgg_el.swift:20:31: error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'
    let floorDiff = abs(floor - number)
                        ~~~~~ ^ ~~~~~~
/tmp/tmpbvvgg_el.swift:20:31: note: overloads for '-' exist with these partially matching parameter lists: (Double, Double), (Int, Int)
    let floorDiff = abs(floor - number)
                              ^
/tmp/tmpbvvgg_el.swift:21:35: error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'
    let ceilingDiff = abs(ceiling - number)
                          ~~~~~~~ ^ ~~~~~~
/tmp/tmpbvvgg_el.swift:21:35: note: overloads for '-' exist with these partially matching parameter lists: (Double, Double), (Int, Int)
    let ceilingDiff = abs(ceiling - number)
                                  ^

*/
/* stdout = 

*/


/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(value: "10")
/// 10
/// >>> closest_integer(value: "15.3")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
func closest_integer(value: String) -> Int {
    let number = Double(value)!
    let rounded = Int(number.rounded())
    let floor = Int(number.rounded(.down))
    let ceiling = Int(number.rounded(.up))
    let floorDiff = abs(floor - number)
    let ceilingDiff = abs(ceiling - number)
    if floorDiff == ceilingDiff {
        return rounded < 0 ? floor : ceiling
    }
    return floorDiff < ceilingDiff ? floor : ceiling
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: "10") == 10)
assert(closest_integer(value: "14.5") == 15)
assert(closest_integer(value: "-15.5") == -16)
assert(closest_integer(value: "15.3") == 15)
assert(closest_integer(value: "0") == 0)



// ----------- problem HumanEval_66_digitSum, completion 152 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_137_compare_one, completion 71 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 137 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 53 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp9nl3aw5w.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encoded.append(letters[letters.index(index, offsetBy: 2)])
            } else {
                encoded.append(letters[index])
            }
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 93 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 116 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_99_closest_integer, completion 6 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6a667esf.swift:19:31: error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'
    let floorDiff = abs(floor - number)
                        ~~~~~ ^ ~~~~~~
/tmp/tmp6a667esf.swift:19:31: note: overloads for '-' exist with these partially matching parameter lists: (Double, Double), (Int, Int)
    let floorDiff = abs(floor - number)
                              ^
/tmp/tmp6a667esf.swift:20:29: error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'
    let ceilDiff = abs(ceil - number)
                       ~~~~ ^ ~~~~~~
/tmp/tmp6a667esf.swift:20:29: note: overloads for '-' exist with these partially matching parameter lists: (Double, Double), (Int, Int)
    let ceilDiff = abs(ceil - number)
                            ^

*/
/* stdout = 

*/


/// Create a function that takes a value (string) representing a number
/// and returns the closest integer to it. If the number is equidistant
/// from two integers, round it away from zero.
/// Examples
/// >>> closest_integer(value: "10")
/// 10
/// >>> closest_integer(value: "15.3")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer("14.5") should
/// return 15 and closest_integer("-14.5") should return -15.
func closest_integer(value: String) -> Int {
    let number = Double(value)!
    let floor = Int(number.rounded(.down))
    let ceil = Int(number.rounded(.up))
    let floorDiff = abs(floor - number)
    let ceilDiff = abs(ceil - number)
    return floorDiff < ceilDiff ? floor : ceil
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: "10") == 10)
assert(closest_integer(value: "14.5") == 15)
assert(closest_integer(value: "-15.5") == -16)
assert(closest_integer(value: "15.3") == 15)
assert(closest_integer(value: "0") == 0)



// ----------- problem HumanEval_66_digitSum, completion 118 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 147 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 144 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_78_hex_key, completion 67 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpq39j_cyq.swift:25:41: error: cannot convert value of type 'String.Element' (aka 'Character') to expected argument type 'String'
    return num.filter { primes.contains($0) }.count
                                        ^

*/
/* stdout = 

*/


/// You have been tasked to write a function that receives 
/// a hexadecimal number as a string and counts the number of hexadecimal 
/// digits that are primes (prime number, or a prime, is a natural number 
/// greater than 1 that is not a product of two smaller natural numbers).
/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
/// So you have to determine a number of the following digits: 2, 3, 5, 7, 
/// B (=decimal 11), D (=decimal 13).
/// Note: you may assume the input is always correct or empty string, 
/// and symbols A,B,C,D,E,F are always uppercase.
/// Examples:
/// >>> hex_key(num: "AB")
/// 1
/// >>> hex_key(num: "1077E")
/// 2
/// >>> hex_key(num: "ABED1A33")
/// 4
/// >>> hex_key(num: "123456789ABCDEF0")
/// 6
/// >>> hex_key(num: "2020")
/// 2
func hex_key(num: String) -> Int {
    let primes = ["2", "3", "5", "7", "B", "D"]
    return num.filter { primes.contains($0) }.count
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: "AB") == 1)
assert(hex_key(num: "1077E") == 2)
assert(hex_key(num: "ABED1A33") == 4)
assert(hex_key(num: "2020") == 2)
assert(hex_key(num: "123456789ABCDEF0") == 6)
assert(hex_key(num: "112233445566778899AABBCCDDEEFF00") == 12)



// ----------- problem HumanEval_27_flip_case, completion 45 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 174 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp37bafzzj.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = ["a", "e", "i", "o", "u"]
    let letters = "abcdefghijklmnopqrstuvwxyz"
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(letters[letters.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(letters[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 165 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpj0g53ty1.swift:16:37: error: incorrect argument label in call (have 'char:', expected 'message:')
            encodedMessage += encode(char: char)
                                    ^~~~~
                                     message
/tmp/tmpj0g53ty1.swift:16:44: error: cannot convert value of type 'Character' to expected argument type 'String'
            encodedMessage += encode(char: char)
                                           ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    for char in message {
        if char.isLetter {
            encodedMessage += encode(char: char)
        } else {
            encodedMessage += String(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 170 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 120 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 187 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 77 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 65 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpwoei_vio.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                encodedMessage.append(alphabet[alphabet.index(index, offsetBy: 2)])
            } else {
                encodedMessage.append(alphabet[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 199 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_27_flip_case, completion 82 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_93_encode, completion 94 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpdxrf4epl.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = index + 2
            if newIndex > alphabet.count - 1 {
                encoded.append(alphabet[newIndex - alphabet.count])
            } else {
                encoded.append(alphabet[newIndex])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_11_string_xor, completion 106 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpmqgnj2ws.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmpmqgnj2ws.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let xor = zip(a, b).map { $0 ^ $1 }
    return xor.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_66_digitSum, completion 138 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 179 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmppupwcdjc.swift:17:54: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: letter.lowercased()) {
                                                     ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = letters.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                let nextIndex = letters.index(index, offsetBy: 2)
                encodedMessage.append(letters[nextIndex])
            } else {
                encodedMessage.append(letters[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 171 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 131 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_93_encode, completion 8 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpilvf79iz.swift:17:54: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: letter.lowercased()) {
                                                     ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for letter in message {
        if let index = letters.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                let newIndex = letters.index(index, offsetBy: 2)
                encodedMessage.append(letters[newIndex])
            } else {
                encodedMessage.append(letters[index])
            }
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 94 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_66_digitSum, completion 62 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 77 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 32 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 175 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_27_flip_case, completion 168 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpo4_7lqjo.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_137_compare_one, completion 174 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 187 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp48r5rqlo.swift:18:54: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
            let index = alphabet.firstIndex(of: char.lowercased())!
                                                     ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encoded = ""
    for char in message {
        if char.isLetter {
            let index = alphabet.firstIndex(of: char.lowercased())!
            let newIndex = alphabet.index(index, offsetBy: 2)
            if vowels.contains(char.lowercased()) {
                encoded.append(alphabet[newIndex])
            } else {
                encoded.append(alphabet[index])
            }
        } else {
            encoded.append(char)
        }
    }
    return encoded
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_27_flip_case, completion 199 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_66_digitSum, completion 126 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_11_string_xor, completion 98 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7la11_c1.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let a = a.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:8:44: error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type 'Int8'
    let b = b.utf8.map { UInt8(bitPattern: $0) }
                                           ^
                                           Int8( )
/tmp/tmp7la11_c1.swift:10:43: error: incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')
    return result.reduce("") { $0 + String(format: "%02x", $1) }
                                          ^~~~~~~
                                           repeating       count: 

*/
/* stdout = 

*/


/// Input are two strings a and b consisting only of 1s and 0s.
/// Perform binary XOR on these inputs and return result also as a string.
/// >>> string_xor(a: "010", b: "110")
/// "100"
func string_xor(a: String, b: String) -> String {
    let a = a.utf8.map { UInt8(bitPattern: $0) }
    let b = b.utf8.map { UInt8(bitPattern: $0) }
    let result = zip(a, b).map { $0 ^ $1 }
    return result.reduce("") { $0 + String(format: "%02x", $1) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: "111000", b: "101010") == "010010")
assert(string_xor(a: "1", b: "1") == "0")
assert(string_xor(a: "0101", b: "0000") == "0101")



// ----------- problem HumanEval_137_compare_one, completion 165 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_137_compare_one, completion 135 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 90 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpgyvww1al.swift:17:52: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = letters.firstIndex(of: char.lowercased()) {
                                                   ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let letters = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = letters.firstIndex(of: char.lowercased()) {
            let newIndex = index + 2
            let newChar = letters[newIndex % letters.count]
            encodedMessage.append(vowels.contains(char.lowercased()) ? newChar : newChar.uppercased())
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_93_encode, completion 16 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp8cybbik6.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = alphabet.index(index, offsetBy: 2)
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(alphabet[newIndex])
            } else {
                encodedMessage.append(alphabet[newIndex].uppercased())
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 8 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_93_encode, completion 11 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp73_mzivg.swift:17:53: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: char.lowercased()) {
                                                    ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    var encodedMessage = ""
    for char in message {
        if let index = alphabet.firstIndex(of: char.lowercased()) {
            let newIndex = (index + 2) % alphabet.count
            let newChar = alphabet[newIndex]
            if vowels.contains(char.lowercased()) {
                encodedMessage.append(newChar.uppercased())
            } else {
                encodedMessage.append(newChar)
            }
        } else {
            encodedMessage.append(char)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_137_compare_one, completion 194 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpn4xh_kmc.swift:63:9: error: expected pattern
    case
        ^
/tmp/tmpn4xh_kmc.swift:63:9: error: expected ':' after 'case'
    case
        ^
/tmp/tmpn4xh_kmc.swift:86:66: error: expected '}' at end of brace statement
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)
                                                                 ^
/tmp/tmpn4xh_kmc.swift:21:48: note: to match this opening '{'
func compare_one(a: Value, b: Value) -> Value? {
                                               ^
/tmp/tmpn4xh_kmc.swift:29:54: error: binary operator '==' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a == b:
                                                   ~ ^  ~
/tmp/tmpn4xh_kmc.swift:29:54: note: overloads for '==' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a == b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:31:54: error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                   ~ ^ ~
/tmp/tmpn4xh_kmc.swift:31:54: note: overloads for '>' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a > b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:33:54: error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                   ~ ^ ~
/tmp/tmpn4xh_kmc.swift:33:54: note: overloads for '<' exist with these partially matching parameter lists: (Int, Int)
    case let (.intValue(a), .doubleValue(b)) where a < b:
                                                     ^
/tmp/tmpn4xh_kmc.swift:35:54: error: binary operator '==' cannot be applied to operands of type 'Int' and 'String'
    case let (.intValue(a)
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case let (.intValue(a), .intValue(b)) where a == b:
        return nil
    case let (.intValue(a), .intValue(b)) where a > b:
        return a
    case let (.intValue(a), .intValue(b)) where a < b:
        return b
    case let (.intValue(a), .doubleValue(b)) where a == b:
        return nil
    case let (.intValue(a), .doubleValue(b)) where a > b:
        return a
    case let (.intValue(a), .doubleValue(b)) where a < b:
        return b
    case let (.intValue(a), .stringValue(b)) where a == b:
        return nil
    case let (.intValue(a), .stringValue(b)) where a > b:
        return a
    case let (.intValue(a), .stringValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .intValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .intValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .intValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .doubleValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .doubleValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .doubleValue(b)) where a < b:
        return b
    case let (.doubleValue(a), .stringValue(b)) where a == b:
        return nil
    case let (.doubleValue(a), .stringValue(b)) where a > b:
        return a
    case let (.doubleValue(a), .stringValue(b)) where a < b:
        return b
    case let (.stringValue(a), .intValue(b)) where a == b:
        return nil
    case let (.stringValue(a), .intValue(b)) where a > b:
        return a
    case
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_71_triangle_area, completion 124 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp7v3we8ik.swift:13:25: error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'
    let s = (a + b + c) / 2.0
            ~~~~~~~~~~~ ^ ~~~
/tmp/tmp7v3we8ik.swift:13:25: note: overloads for '/' exist with these partially matching parameter lists: (Double, Double), (Duration, Double), (Int, Int)
    let s = (a + b + c) / 2.0
                        ^
/tmp/tmp7v3we8ik.swift:14:16: error: cannot find 'sqrt' in scope
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~
/tmp/tmp7v3we8ik.swift:14:16: error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// Given the lengths of the three sides of a triangle. Return the area of
/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
/// Otherwise return -1
/// Three sides make a valid triangle when the sum of any two sides is greater 
/// than the third side.
/// Example:
/// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
    let s = (a + b + c) / 2.0
    let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
    return area.isNaN ? -1 : area
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)



// ----------- problem HumanEval_137_compare_one, completion 107 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



// ----------- problem HumanEval_161_solve, completion 130 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpylyqlddg.swift:19:14: error: cannot convert return expression of type '[String.Element]' (aka 'Array<Character>') to return type 'String'
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    let letters = s.filter { $0.isLetter }
    if letters.isEmpty {
        return String(s.reversed())
    }
    return s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_93_encode, completion 56 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp8mkzj9z3.swift:17:55: error: cannot convert value of type 'String' to expected argument type 'String.Element' (aka 'Character')
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
                                                      ^

*/
/* stdout = 

*/


/// Write a function that takes a message, and encodes in such a 
/// way that it swaps case of all letters, replaces all vowels in 
/// the message with the letter that appears 2 places ahead of that 
/// vowel in the english alphabet. 
/// Assume only letters. 
/// Examples:
/// >>> encode(message: "test")
/// "TGST"
/// >>> encode(message: "This is a message")
/// "tHKS KS C MGSSCGG"
func encode(message: String) -> String {
    var encodedMessage = ""
    let vowels = "aeiou"
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    for letter in message {
        if let index = alphabet.firstIndex(of: letter.lowercased()) {
            if vowels.contains(letter.lowercased()) {
                let newIndex = alphabet.index(index, offsetBy: 2)
                encodedMessage.append(alphabet[newIndex].uppercased())
            } else {
                encodedMessage.append(alphabet[index].uppercased())
            }
        } else {
            encodedMessage.append(letter)
        }
    }
    return encodedMessage
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: "TEST") == "tgst")
assert(encode(message: "Mudasir") == "mWDCSKR")
assert(encode(message: "YES") == "ygs")
assert(encode(message: "This is a message") == "tHKS KS C MGSSCGG")
assert(encode(message: "I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg")



// ----------- problem HumanEval_66_digitSum, completion 9 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_66_digitSum, completion 63 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp1ugujbvr.swift:19:62: error: result values in '? :' expression have mismatching types 'UInt8' and 'Int'
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
                                                ~~~~~~~~~~~~~^
                                                Int(          )

*/
/* stdout = 

*/


/// Task
/// Write a function that takes a string as input and returns the sum of the upper characters only'
/// ASCII codes.
/// Examples:
/// >>> digitSum(s: "")
/// 0
/// >>> digitSum(s: "abAB")
/// 131
/// >>> digitSum(s: "abcCd")
/// 67
/// >>> digitSum(s: "helloE")
/// 69
/// >>> digitSum(s: "woArBld")
/// 131
/// >>> digitSum(s: "aAaaaXa")
/// 153
func digitSum(s: String) -> Int {
    return s.reduce(0) { $0 + ($1.isUppercase ? $1.asciiValue! : 0) }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: "") == 0)
assert(digitSum(s: "abAB") == 131)
assert(digitSum(s: "abcCd") == 67)
assert(digitSum(s: "helloE") == 69)
assert(digitSum(s: "woArBld") == 131)
assert(digitSum(s: "aAaaaXa") == 153)
assert(digitSum(s: " How are yOu?") == 151)
assert(digitSum(s: "You arE Very Smart") == 327)



// ----------- problem HumanEval_161_solve, completion 180 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp_z5dv__4.swift:15:48: error: cannot convert value of type 'String.Element' (aka 'Character') to closure result type 'String'
    return s.isEmpty ? s : s.map { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()
                                   ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/tmp/tmp_z5dv__4.swift:15:65: error: result values in '? :' expression have mismatching types 'String' and 'String.Element' (aka 'Character')
    return s.isEmpty ? s : s.map { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()
                                                 ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// You are given a string s.
/// if s[i] is a letter, reverse its case from lower to upper or vise versa, 
/// otherwise keep it as it is.
/// If the string contains no letters, reverse the string.
/// The function should return the resulted string.
/// Examples
/// >>> solve(s: "1234")
/// "4321"
/// >>> solve(s: "ab")
/// "AB"
/// >>> solve(s: "#a@C")
/// "#A@c"
func solve(s: String) -> String {
    return s.isEmpty ? s : s.map { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: "AsDf") == "aSdF")
assert(solve(s: "1234") == "4321")
assert(solve(s: "ab") == "AB")
assert(solve(s: "#a@C") == "#A@c")
assert(solve(s: "#AsdfW^45") == "#aSDFw^45")
assert(solve(s: "#6@2") == "2@6#")
assert(solve(s: "#$a^D") == "#$A^d")
assert(solve(s: "#ccc") == "#CCC")



// ----------- problem HumanEval_27_flip_case, completion 184 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_27_flip_case, completion 195 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmp6hcw1kte.swift:6:19: error: cannot convert return expression of type '[String]' to return type 'String'
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/
/* stdout = 

*/


/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
/// >>> flip_case(string: "Hello")
/// "hELLO"
func flip_case(string: String) -> String {
    return string.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: "") == "")
assert(flip_case(string: "Hello!") == "hELLO!")
assert(flip_case(string: "These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS")



// ----------- problem HumanEval_125_split_words, completion 121 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpcvjo0n2j.swift:20:137: error: cannot convert value of type 'UInt8' to closure result type 'Int'
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
                                                                                                                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~
                                                                                                                 Int(                       )

*/
/* stdout = 

*/


extension Int: Error {}
        
/// Given a string of words, return an array of words split on whitespace, if no whitespaces exists in the text you
/// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
/// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
/// Examples
/// >>> split_words(txt: "Hello world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "Hello,world!")
/// .success(["Hello", "world!"])
/// >>> split_words(txt: "abcdef")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains(" ") {
        return .success(txt.split(separator: " ").map(String.init))
    } else if txt.contains(",") {
        return .success(txt.split(separator: ",").map(String.init))
    } else {
        return .failure(txt.lowercased().filter { $0.isLetter }.enumerated().filter { $0.offset % 2 == 1 }.map { $0.element.asciiValue! - 97 }.reduce(0, +))
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: "Hello world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello,world!") == .success(["Hello", "world!"]))
assert(split_words(txt: "Hello world,!") == .success(["Hello", "world,!"]))
assert(split_words(txt: "Hello,Hello,world !") == .success(["Hello,Hello,world", "!"]))
assert(split_words(txt: "abcdef") == .failure(3))
assert(split_words(txt: "aaabb") == .failure(2))
assert(split_words(txt: "aaaBb") == .failure(1))
assert(split_words(txt: "") == .failure(0))



// ----------- problem HumanEval_137_compare_one, completion 134 ------------
// status = SyntaxError
// exit_code = 1
/* stderr = 
/tmp/tmpy7wm4c8o.swift:24:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:26:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:28:22: error: cannot convert return expression of type 'String' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:30:20: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
                   ^
                   Int( )
/tmp/tmpy7wm4c8o.swift:30:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:32:20: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
                   ^
/tmp/tmpy7wm4c8o.swift:32:22: error: cannot convert return expression of type 'Int' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:34:16: error: cannot convert value of type 'Double' to expected argument type 'Int'
        return a > b ? a : b
               ^
               Int( )
/tmp/tmpy7wm4c8o.swift:34:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:36:18: error: binary operator '>' cannot be applied to operands of type 'Double' and 'String'
        return a > b ? a : b
               ~ ^ ~
/tmp/tmpy7wm4c8o.swift:36:22: error: cannot convert return expression of type 'Double' to return type 'Value?'
        return a > b ? a : b
               ~~~~~~^~~~~~~
/tmp/tmpy7wm4c8o.swift:38:16: error: cannot convert value of type 'String' to expected argument type 'Int'
        return a > b ? a : b
               ^
/tmp/tmpy7wm4c8o.swift:38:22: error: ca
*/
/* stdout = 

*/


enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
/// Create a function that takes integers, floats, or strings representing
/// real numbers, and returns the larger variable in its given variable type.
/// Return nil if the values are equal.
/// Note: If a real number is represented as a string, the floating point might be . or ,
/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue("2,3"))
/// .stringValue("2,3")
/// >>> compare_one(a: .stringValue("5,1"), b: .stringValue("6"))
/// .stringValue("6")
/// >>> compare_one(a: .stringValue("1"), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
    switch (a, b) {
    case (.intValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    case (.intValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.doubleValue(let a), .stringValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .intValue(let b)):
        return a > b ? a : b
    case (.stringValue(let a), .doubleValue(let b)):
        return a > b ? a : b
    default:
        return nil
    }
}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue("2,3")) == .stringValue("2,3"))
assert(compare_one(a: .stringValue("5,1"), b: .stringValue("6")) == .stringValue("6"))
assert(compare_one(a: .stringValue("1"), b: .stringValue("2")) == .stringValue("2"))
assert(compare_one(a: .stringValue("1"), b: .intValue(1)) == nil)



