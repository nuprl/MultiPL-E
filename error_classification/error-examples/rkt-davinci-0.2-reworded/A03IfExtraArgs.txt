HumanEval_103_rounded_avg: 15
HumanEval_39_prime_fib: 3
HumanEval_147_get_max_triples: 1
HumanEval_120_maximum: 1
HumanEval_31_is_prime: 1
HumanEval_10_make_palindrome: 1
HumanEval_26_remove_duplicates: 3
HumanEval_130_tri: 6
HumanEval_49_modp: 1
HumanEval_41_car_race_collision: 1
HumanEval_84_solve: 1
HumanEval_89_encrypt: 5
HumanEval_37_sort_even: 3
HumanEval_65_circular_shift: 1
HumanEval_68_pluck: 1
HumanEval_111_histogram: 1
HumanEval_85_add: 3
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m) -1
      (define sum 0)
      (define count 0)
      (for ([i (in-range n (+ m 1))])
        (set! sum (+ sum i))
        (set! count (+ count 1)))
      (define avg (/ sum count))
      (define rounded (round avg))
      (define binary (number->string rounded 2))
      (string-append "0b" binary)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp0j5jvrwx.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define sum 0) (define count 0) (for ((i (in-range n (+ m 1)))) (set! sum (+ sum i)) (set! count (+ count 1))) (define avg (/ sum count)) (define rounded (round avg)) (define binary (number->string rounded 2)) (string-append "0b" binary))
  location...:
   /tmp/tmp0j5jvrwx.rkt:17:2

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (if (< n 2)
        #f
        (if (= n 2)
            #t
            (if (even? n)
                #f
                (define (prime?-iter n d)
                  (if (> (* d d) n)
                      #t
                      (if (zero? (modulo n d))
                          #f
                          (prime?-iter n (+ d 1)))))
              (prime?-iter n 3)))))
  (define (prime_fib-iter n i)
    (if (= n 1)
        (fib i)
        (if (prime? (fib i))
            (prime_fib-iter (- n 1) (+ i 1))
            (prime_fib-iter n (+ i 1)))))
  (prime_fib-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp11e1g_ez.rkt:24:12: if: bad syntax
  in: (if (even? n) #f (define (prime?-iter n d) (if (> (* d d) n) #t (if (zero? (modulo n d)) #f (prime?-iter n (+ d 1))))) (prime?-iter n 3))
  location...:
   /tmp/tmp11e1g_ez.rkt:24:12

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (string->number (number->string (avg n m) 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp1iihg9jm.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (string->number (number->string (avg n m) 2)))
  location...:
   /tmp/tmp1iihg9jm.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (average n m)
        (/ (+ n m) 2))
      (define (round n)
        (if (integer? n)
            n
            (round (+ n 1))))
      (define (convert n)
        (number->string n 2))
      (convert (round (average n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp2nh5t0w9.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (average n m) (/ (+ n m) 2)) (define (round n) (if (integer? n) n (round (+ n 1)))) (define (convert n) (number->string n 2)) (convert (round (average n m))))
  location...:
   /tmp/tmp2nh5t0w9.rkt:17:2

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (helper i acc)
    (if (= i n)
        acc
        (helper (+ i 1) (+ acc (if (and (> i 1) (multiple-of-3? (+ (expt i 2) (- i 1))))) 1 0))
      )
    )
  (helper 1 0)
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp9ovfvb5m.rkt:17:31: if: bad syntax
  in: (if (and (> i 1) (multiple-of-3? (+ (expt i 2) (- i 1)))))
  location...:
   /tmp/tmp9ovfvb5m.rkt:17:31

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_0yiwmup.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmp_0yiwmup.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_0yiwmup.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmp_0yiwmup.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_0yiwmup.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmp_0yiwmup.rkt:17:2

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (if (or (null? arr) (= k 0))
      '()
      (define (maximum-helper arr k)
        (if (or (null? arr) (= k 0))
            '()
            (let ([max (apply max arr)])
              (cons max (maximum-helper (remove max arr) (- k 1))))))
    (maximum-helper arr k)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_4mg5zaq.rkt:19:2: if: bad syntax
  in: (if (or (null? arr) (= k 0)) (quote ()) (define (maximum-helper arr k) (if (or (null? arr) (= k 0)) (quote ()) (let ((max (apply max arr))) (cons max (maximum-helper (remove max arr) (- k 1)))))) (maximum-helper arr k))
  location...:
   /tmp/tmp_4mg5zaq.rkt:19:2

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (if (< n 2)
        #f
        (define (prime? n i)
          (if (< i n)
              (if (= (remainder n i) 0)
                  #f
                  (prime? n (+ i 1)))
              #t))
    (prime? n 2)))
  (define (prime_fib n i)
    (if (= n i)
        (fib i)
        (if (prime? (fib i))
            (prime_fib n (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_jnylkgk.rkt:20:4: if: bad syntax
  in: (if (< n 2) #f (define (prime? n i) (if (< i n) (if (= (remainder n i) 0) #f (prime? n (+ i 1))) #t)) (prime? n 2))
  location...:
   /tmp/tmp_jnylkgk.rkt:20:4

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (if (= n 1)
      #f
      (define (is_prime-helper n i)
        (if (= i n)
            #t
            (if (= (modulo n i) 0)
                #f
                (is_prime-helper n (+ i 1)))))
      (is_prime-helper n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_l37m92i.rkt:19:2: if: bad syntax
  in: (if (= n 1) #f (define (is_prime-helper n i) (if (= i n) #t (if (= (modulo n i) 0) #f (is_prime-helper n (+ i 1))))) (is_prime-helper n 2))
  location...:
   /tmp/tmp_l37m92i.rkt:19:2

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (is_palindrome? string)
    (define (is_palindrome?-helper string start end)
      (if (= start end)
          #t
          (if (= (string-ref string start) (string-ref string (- end 1)))
              (is_palindrome?-helper string (+ start 1) (- end 1))
              #f)))
    (is_palindrome?-helper string 0 (string-length string)))
  (define (find-palindrome-suffix string)
    (define (find-palindrome-suffix-helper string start end)
      (if (is_palindrome? (substring string start end))
          (substring string start end)
          (find-palindrome-suffix-helper string start (- end 1))))
    (find-palindrome-suffix-helper string 0 (string-length string)))
  (define (reverse string)
    (define (reverse-helper string start end)
      (if (= start end)
          string
          (string-set! string start (string-ref string (- end 1)))
          (string-set! string (- end 1) (string-ref string start))
          (reverse-helper string (+ start 1) (- end 1))))
    (reverse-helper string 0 (string-length string)))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpa9u4qzis.rkt:30:6: if: bad syntax
  in: (if (= start end) string (string-set! string start (string-ref string (- end 1))) (string-set! string (- end 1) (string-ref string start)) (reverse-helper string (+ start 1) (- end 1)))
  location...:
   /tmp/tmpa9u4qzis.rkt:30:6

==========================
------- Program HumanEval_26_remove_duplicates --------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  (let ([seen (make-hash)])
    (for/list ([n numbers])
      (if (hash-ref seen n #f)
          '()
          (hash-set! seen n #t)
          (list n)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpansowg32.rkt:10:6: if: bad syntax
  in: (if (hash-ref seen n #f) (quote ()) (hash-set! seen n #t) (list n))
  location...:
   /tmp/tmpansowg32.rkt:10:6

==========================
------- Program HumanEval_26_remove_duplicates --------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  (let ([seen (make-hash)])
    (for/list ([n numbers])
      (if (hash-ref seen n #f)
          '()
          (hash-set! seen n #t)
          (list n)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpansowg32.rkt:10:6: if: bad syntax
  in: (if (hash-ref seen n #f) (quote ()) (hash-set! seen n #t) (list n))
  location...:
   /tmp/tmpansowg32.rkt:10:6

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (> n m)
            0
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpbkx3f1eo.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (> n m) 0 (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmpbkx3f1eo.rkt:17:2

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (zero? n)
      1
      (if (odd? n)
          (* (modp (quotient n 2) p) (modp (quotient n 2) p) p)
          (* (modp (quotient n 2) p) (modp (quotient n 2) p) p) p)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpcflz1yig.rkt:17:6: if: bad syntax
  in: (if (odd? n) (* (modp (quotient n 2) p) (modp (quotient n 2) p) p) (* (modp (quotient n 2) p) (modp (quotient n 2) p) p) p)
  location...:
   /tmp/tmpcflz1yig.rkt:17:6

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum_of_numbers n m)
        (if (> n m)
            0
            (+ n (sum_of_numbers (+ n 1) m))))
      (define (average n m)
        (round (/ (sum_of_numbers n m) (- m n))))
      (define (binary n)
        (if (= n 0)
            ""
            (string-append (binary (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (binary (average n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpcw7q00ni.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum_of_numbers n m) (if (> n m) 0 (+ n (sum_of_numbers (+ n 1) m)))) (define (average n m) (round (/ (sum_of_numbers n m) (- m n)))) (define (binary n) (if (= n 0) "" (string-append (binary (quotient n 2)) (number->string (remain...
  location...:
   /tmp/tmpcw7q00ni.rkt:17:2

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left_cars right_cars)
    (cond
      [(= n 0) 0]
      [(= n 1) 0]
      [(= n 2) 1]
      [else
       (let ([left_car (car left_cars)]
             [right_car (car right_cars)])
         (if (< left_car right_car)
             (car_race_collision_helper (- n 1) (cdr left_cars) right_cars)
             (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars))
             (+ 1 (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars)))))]))
  (car_race_collision_helper n (range n) (reverse (range n))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpekzrn0hl.rkt:20:9: if: bad syntax
  in: (if (< left_car right_car) (car_race_collision_helper (- n 1) (cdr left_cars) right_cars) (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars)) (+ 1 (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars))))
  location...:
   /tmp/tmpekzrn0hl.rkt:20:9

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (quotient (sum n m) (- m n)))
      (define (to_binary n)
        (if (= n 0)
            ""
            (string-append (to_binary (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (to_binary (avg n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpeo70a3yy.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (quotient (sum n m) (- m n))) (define (to_binary n) (if (= n 0) "" (string-append (to_binary (quotient n 2)) (number->string (remainder n 2))))) (string-append "0b"...
  location...:
   /tmp/tmpeo70a3yy.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define sum (+ n m))
      (define avg (/ sum 2))
      (define rounded (round avg))
      (define binary (number->string rounded 2))
      (string-append "0b" binary)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmph90nur9j.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define sum (+ n m)) (define avg (/ sum 2)) (define rounded (round avg)) (define binary (number->string rounded 2)) (string-append "0b" binary))
  location...:
   /tmp/tmph90nur9j.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (avg n m)
        (/ (+ n m) 2))
      (define (round n)
        (if (and (> n 0) (< n 1))
            0
            (if (>= n 1)
                (add1 (round (- n 1)))
                (round n))))
      (define (convert n)
        (if (= n 0)
            '()
            (cons (remainder n 2) (convert (quotient n 2)))))
      (define (reverse lst)
        (if (null? lst)
            '()
            (append (reverse (cdr lst)) (list (car lst)))))
      (define (convert-to-string lst)
        (if (null? lst)
            ""
            (string-append (number->string (car lst)) (convert-to-string (cdr lst)))))
      (string-append "0b" (convert-to-string (reverse (convert (round (avg n m))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpibf7z0nz.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (avg n m) (/ (+ n m) 2)) (define (round n) (if (and (> n 0) (< n 1)) 0 (if (>= n 1) (add1 (round (- n 1))) (round n)))) (define (convert n) (if (= n 0) (quote ()) (cons (remainder n 2) (convert (quotient n 2))))) (define (reverse ...
  location...:
   /tmp/tmpibf7z0nz.rkt:17:2

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (if (= n 1)
        #f
        (if (= n 2)
            #t
            (if (even? n)
                #f
                (define (iter i)
                  (if (> i (sqrt n))
                      #t
                      (if (zero? (modulo n i))
                          #f
                          (iter (+ i 1)))))
                (iter 3)))))
  (define (iter i)
    (if (= i n)
        (fib i)
        (if (prime? (fib i))
            (iter (+ i 1))
            (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpikmfz_t7.rkt:24:12: if: bad syntax
  in: (if (even? n) #f (define (iter i) (if (> i (sqrt n)) #t (if (zero? (modulo n i)) #f (iter (+ i 1))))) (iter 3))
  location...:
   /tmp/tmpikmfz_t7.rkt:24:12

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpky2pkfjs.rkt:26:14: if: bad syntax
  in: (if (= (modulo n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpky2pkfjs.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpky2pkfjs.rkt:26:14: if: bad syntax
  in: (if (= (modulo n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpky2pkfjs.rkt:26:14

==========================
------- Program HumanEval_26_remove_duplicates --------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  (let ([seen (make-hash)])
    (filter (lambda (n)
              (if (hash-ref seen n #f)
                  #f
                  (hash-set! seen n #t)
                  #t))
            numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmjt_m21k.rkt:10:14: if: bad syntax
  in: (if (hash-ref seen n #f) #f (hash-set! seen n #t) #t)
  location...:
   /tmp/tmpmjt_m21k.rkt:10:14

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (sum-digits n)
    (if (= n 0)
        0
        (+ (modulo n 10) (sum-digits (quotient n 10)))))
  (define (to-binary n)
    (if (= n 0)
        ""
        (to-binary (quotient n 2))
        (number->string (modulo n 2))))
  (to-binary (sum-digits N)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmq94sz9f.rkt:22:4: if: bad syntax
  in: (if (= n 0) "" (to-binary (quotient n 2)) (number->string (modulo n 2)))
  location...:
   /tmp/tmpmq94sz9f.rkt:22:4

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (define (bin n)
        (if (= n 0)
            ""
            (string-append (bin (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (bin (avg n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmw2md4ow.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (define (bin n) (if (= n 0) "" (string-append (bin (quotient n 2)) (number->string (remainder n 2))))) (string-append "0b" (bin (avg ...
  location...:
   /tmp/tmpmw2md4ow.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (avg n m)
        (/ (+ n m) 2))
      (define (rounded_avg n m)
        (round (avg n m)))
      (define (convert-to-binary n)
        (number->string n 2))
      (convert-to-binary (rounded_avg n m))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpn9j76hfo.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (avg n m) (/ (+ n m) 2)) (define (rounded_avg n m) (round (avg n m))) (define (convert-to-binary n) (number->string n 2)) (convert-to-binary (rounded_avg n m)))
  location...:
   /tmp/tmpn9j76hfo.rkt:17:2

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (encrypt-helper s i)
    (if (= i (string-length s))
        ""
        (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) (+ (char->integer #\a) 26)))
        (encrypt-helper s (+ i 1))))
  (encrypt-helper s 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpo8r8cxs3.rkt:18:4: if: bad syntax
  in: (if (= i (string-length s)) "" (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) (+ (char->integer #\a) 26))) (encrypt-helper s (+ i 1)))
  location...:
   /tmp/tmpo8r8cxs3.rkt:18:4

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define sum 0)
      (define count 0)
      (for ([i (in-range n m)])
        (set! sum (+ sum i))
        (set! count (+ count 1)))
      (define avg (/ sum count))
      (define rounded_avg (round avg))
      (define binary_avg (integer->binary rounded_avg))
      (string-append "0b" binary_avg)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpox6xrz8p.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define sum 0) (define count 0) (for ((i (in-range n m))) (set! sum (+ sum i)) (set! count (+ count 1))) (define avg (/ sum count)) (define rounded_avg (round avg)) (define binary_avg (integer->binary rounded_avg)) (string-append "0b" bin...
  location...:
   /tmp/tmpox6xrz8p.rkt:17:2

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (null? l)
      '()
      (cons (car l)
            (if (null? (cdr l))
                '()
                (sort (cdr (cdr l)) <)
                (cdr l)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpp89z3rvj.rkt:14:12: if: bad syntax
  in: (if (null? (cdr l)) (quote ()) (sort (cdr (cdr l)) <) (cdr l))
  location...:
   /tmp/tmpp89z3rvj.rkt:14:12

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (null? l)
      '()
      (cons (car l)
            (if (null? (cdr l))
                '()
                (sort (cdr (cdr l)) <)
                (cdr l)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpp89z3rvj.rkt:14:12: if: bad syntax
  in: (if (null? (cdr l)) (quote ()) (sort (cdr (cdr l)) <) (cdr l))
  location...:
   /tmp/tmpp89z3rvj.rkt:14:12

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (null? l)
      '()
      (cons (car l)
            (if (null? (cdr l))
                '()
                (sort (cdr (cdr l)) <)
                (sort_even (cdr l))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmppqktw1fu.rkt:14:12: if: bad syntax
  in: (if (null? (cdr l)) (quote ()) (sort (cdr (cdr l)) <) (sort_even (cdr l)))
  location...:
   /tmp/tmppqktw1fu.rkt:14:12

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum-of-integers n m)
        (if (= n m)
            n
            (+ n (sum-of-integers (+ n 1) m))))
      (define (avg n m)
        (/ (sum-of-integers n m) (- m n)))
      (define (round-to-int n)
        (if (< n 0)
            (round (- n 0.5))
            (round (+ n 0.5))))
      (define (int-to-binary n)
        (if (= n 0)
            ""
            (string-append (int-to-binary (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (int-to-binary (round-to-int (avg n m))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpqq2db9x6.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum-of-integers n m) (if (= n m) n (+ n (sum-of-integers (+ n 1) m)))) (define (avg n m) (/ (sum-of-integers n m) (- m n))) (define (round-to-int n) (if (< n 0) (round (- n 0.5)) (round (+ n 0.5)))) (define (int-to-binary n) (if ...
  location...:
   /tmp/tmpqq2db9x6.rkt:17:2

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (shift-right x shift)
    (if (zero? shift)
        x
        (shift-right (quotient x 10) (- shift 1))))
  (define (shift-left x shift)
    (if (zero? shift)
        x
        (shift-left (* x 10) (- shift 1))))
  (define (digits x)
    (if (zero? x)
        0
        (+ 1 (digits (quotient x 10)))))
  (define (reverse x)
    (define (reverse-helper x acc)
      (if (zero? x)
          acc
          (reverse-helper (quotient x 10) (+ (* acc 10) (remainder x 10)))))
    (reverse-helper x 0))
  (define (shift-digits x shift)
    (if (> shift (digits x))
        (reverse x)
        (define (shift-digits-helper x shift)
          (if (zero? shift)
              x
              (shift-digits-helper (+ (* (shift-left (remainder x 10) shift) 10) (shift-right x shift)) (- shift 1))))
        (shift-digits-helper x shift)))
  (number->string (shift-digits x shift)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmptdofct6w.rkt:30:4: if: bad syntax
  in: (if (> shift (digits x)) (reverse x) (define (shift-digits-helper x shift) (if (zero? shift) x (shift-digits-helper (+ (* (shift-left (remainder x 10) shift) 10) (shift-right x shift)) (- shift 1)))) (shift-digits-helper x shift))
  location...:
   /tmp/tmptdofct6w.rkt:30:4

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (if (empty? arr)
      (list)
      (define evens (filter even? arr))
      (if (empty? evens)
          (list)
          (list (apply min evens) (index-of (apply min evens) arr)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpv6v2z_ge.rkt:29:2: if: bad syntax
  in: (if (empty? arr) (list) (define evens (filter even? arr)) (if (empty? evens) (list) (list (apply min evens) (index-of (apply min evens) arr))))
  location...:
   /tmp/tmpv6v2z_ge.rkt:29:2

==========================
------- Program HumanEval_111_histogram --------
#lang racket

;; Given a string representing a space separated lowercase letters, return a hash
;; of the letter with the most repetition and containing the corresponding count.
;; If several letters have the same occurrence, return all of them.
;; Example:
;; >>> (histogram "a b c")
;; #hash(("a" .  1) ("b" .  1) ("c" .  1))
;; >>> (histogram "a b b a")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "a b c a b")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "b b b b a")
;; #hash(("b" .  4))
;; >>> (histogram "")
;; #hash()
(define (histogram test)
  (define (histogram-helper test max-count max-letters)
    (if (null? test)
        max-letters
        (let ((letter (car test))
              (rest (cdr test)))
          (if (hash-has-key? max-letters letter)
              (let ((count (hash-ref max-letters letter)))
                (hash-set! max-letters letter (+ count 1))
                (if (> count max-count)
                    (histogram-helper rest count max-letters)
                    (histogram-helper rest max-count max-letters)))
              (hash-set! max-letters letter 1)
              (histogram-helper rest max-count max-letters)))))
  (histogram-helper (string-split test) 0 (make-hash)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate histogram))
    (check-equal? (candidate "a b b a") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c a b") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c d g") #hash(("a" .  1) ("b" .  1) ("c" .  1) ("d" .  1) ("g" .  1)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "b b b b a") #hash(("b" .  4)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "") #hash())
    (check-equal? (candidate "a") #hash(("a" .  1)))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpvsqu38mk.rkt:23:10: if: bad syntax
  in: (if (hash-has-key? max-letters letter) (let ((count (hash-ref max-letters letter))) (hash-set! max-letters letter (+ count 1)) (if (> count max-count) (histogram-helper rest count max-letters) (histogram-helper rest max-count max-letters))) (hash-set! m...
  location...:
   /tmp/tmpvsqu38mk.rkt:23:10

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (encrypt-helper s i)
    (if (equal? i (string-length s))
        ""
        (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) #\a))
        (encrypt-helper s (+ i 1))))
  (encrypt-helper s 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpwn4303ns.rkt:18:4: if: bad syntax
  in: (if (equal? i (string-length s)) "" (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) #\a)) (encrypt-helper s (+ i 1)))
  location...:
   /tmp/tmpwn4303ns.rkt:18:4

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (if (null? lst)
      0
      (if (even? (car lst))
          (car lst)
          0)
      (add (cdr lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpyc_fh6zx.rkt:8:2: if: bad syntax
  in: (if (null? lst) 0 (if (even? (car lst)) (car lst) 0) (add (cdr lst)))
  location...:
   /tmp/tmpyc_fh6zx.rkt:8:2

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (if (null? lst)
      0
      (if (even? (car lst))
          (car lst)
          0)
      (add (cdr lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpyc_fh6zx.rkt:8:2: if: bad syntax
  in: (if (null? lst) 0 (if (even? (car lst)) (car lst) 0) (add (cdr lst)))
  location...:
   /tmp/tmpyc_fh6zx.rkt:8:2

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (if (null? lst)
      0
      (if (even? (car lst))
          (car lst)
          0)
      (add (cdr lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpyc_fh6zx.rkt:8:2: if: bad syntax
  in: (if (null? lst) 0 (if (even? (car lst)) (car lst) 0) (add (cdr lst)))
  location...:
   /tmp/tmpyc_fh6zx.rkt:8:2

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n)
    (if (= n 0)
        s
        (rotate (- n 1))
        (string-append (substring s (- n 1) n) (substring s 0 (- n 1)))))
  (rotate 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzwlvv_2z.rkt:18:4: if: bad syntax
  in: (if (= n 0) s (rotate (- n 1)) (string-append (substring s (- n 1) n) (substring s 0 (- n 1))))
  location...:
   /tmp/tmpzwlvv_2z.rkt:18:4

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n)
    (if (= n 0)
        s
        (rotate (- n 1))
        (string-append (substring s (- n 1) n) (substring s 0 (- n 1)))))
  (rotate 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzwlvv_2z.rkt:18:4: if: bad syntax
  in: (if (= n 0) s (rotate (- n 1)) (string-append (substring s (- n 1) n) (substring s 0 (- n 1))))
  location...:
   /tmp/tmpzwlvv_2z.rkt:18:4

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n)
    (if (= n 0)
        s
        (rotate (- n 1))
        (string-append (substring s (- n 1) n) (substring s 0 (- n 1)))))
  (rotate 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzwlvv_2z.rkt:18:4: if: bad syntax
  in: (if (= n 0) s (rotate (- n 1)) (string-append (substring s (- n 1) n) (substring s 0 (- n 1))))
  location...:
   /tmp/tmpzwlvv_2z.rkt:18:4

