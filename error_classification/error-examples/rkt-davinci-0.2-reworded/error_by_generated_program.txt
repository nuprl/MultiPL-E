HumanEval_119_match_parens: 7
HumanEval_160_do_algebra: 8
HumanEval_25_factorize: 1
HumanEval_20_find_closest_elements: 1
HumanEval_24_largest_divisor: 1
HumanEval_47_median: 2
HumanEval_17_parse_music: 2
HumanEval_1_separate_paren_groups: 2
HumanEval_153_Strongest_Extension: 1
HumanEval_54_same_chars: 1
HumanEval_56_correct_bracketing: 2
HumanEval_11_string_xor: 2
HumanEval_99_closest_integer: 1
HumanEval_59_largest_prime_factor: 1
HumanEval_155_even_odd_count: 1
HumanEval_68_pluck: 1
==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (is-good? str)
    (let loop ([str str] [count 0])
      (cond [(empty? str) (= count 0)]
            [(char=? (first str) #\() (loop (rest str) (+ count 1))]
            [(char=? (first str) #\)) (loop (rest str) (- count 1))]
            [else (error "Invalid character in string")])))
  (define (concat-and-check str1 str2)
    (cond [(is-good? (string-append str1 str2)) "Yes"]
          [(is-good? (string-append str2 str1)) "Yes"]
          [else "No"]))
  (concat-and-check (first lst) (second lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())())())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")())(()()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(())))(()())(("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(()))()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "((((((())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")(()(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0k53fcvr.rkt:43:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")()("
--------------------
--------------------
ERROR
name:       check-equal?
locatio
==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else
     (cond
       [(= (first operator) '+) (+ (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '-) (- (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '*) (* (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '//) (quotient (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '**) (expt (first operand) (do_algebra (rest operator) (rest operand)))]
       [else (error 'do_algebra "Unknown operator")]
       )
     ]
    )
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:42:4

=: contract violation
  expected: number?
  given: "**"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:43:4

=: contract violation
  expected: number?
  given: "+"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:44:4

=: contract violation
  expected: number?
  given: "//"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else
     (cond
       [(= (first operator) '+) (+ (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '-) (- (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '*) (* (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '//) (quotient (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '**) (expt (first operand) (do_algebra (rest operator) (rest operand)))]
       [else (error 'do_algebra "Unknown operator")]
       )
     ]
    )
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:42:4

=: contract violation
  expected: number?
  given: "**"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:43:4

=: contract violation
  expected: number?
  given: "+"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:44:4

=: contract violation
  expected: number?
  given: "//"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else
     (cond
       [(= (first operator) '+) (+ (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '-) (- (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '*) (* (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '//) (quotient (first operand) (do_algebra (rest operator) (rest operand)))]
       [(= (first operator) '**) (expt (first operand) (do_algebra (rest operator) (rest operand)))]
       [else (error 'do_algebra "Unknown operator")]
       )
     ]
    )
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:42:4

=: contract violation
  expected: number?
  given: "**"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:43:4

=: contract violation
  expected: number?
  given: "+"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1wjd98yc.rkt:44:4

=: contract violation
  expected: number?
  given: "//"
--------------------

==========================
------- Program HumanEval_25_factorize --------
#lang racket

;; Return list of prime factors of given integer in the order from smallest to largest.
;; Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
;; Input number should be equal to the product of all factors
;; >>> (factorize 8)
;; (list 2 2 2)
;; >>> (factorize 25)
;; (list 5 5)
;; >>> (factorize 70)
;; (list 2 5 7)
(define (factorize n)
  (cond
    [(< n 2) (error "n must be greater than 1")]
    [(= n 2) (list 2)]
    [(= n 3) (list 3)]
    [(= n 5) (list 5)]
    [(= n 7) (list 7)]
    [else (append (factorize (/ n 2)) (list 2))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate factorize))
    (check-equal? (candidate 2) (list 2))
    (check-equal? (candidate 4) (list 2 2))
    (check-equal? (candidate 8) (list 2 2 2))
    (check-equal? (candidate 57) (list 3 19))
    (check-equal? (candidate 3249) (list 3 3 19 19))
    (check-equal? (candidate 185193) (list 3 3 3 19 19 19))
    (check-equal? (candidate 20577) (list 3 19 19 19))
    (check-equal? (candidate 18) (list 2 3 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2yi2knln.rkt:29:4

n must be greater than 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2yi2knln.rkt:30:4

n must be greater than 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2yi2knln.rkt:31:4

n must be greater than 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2yi2knln.rkt:32:4

n must be greater than 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2yi2knln.rkt:33:4

n must be greater than 1
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (closest-pair lst)
    (cond
      [(empty? lst) (error "empty list")]
      [(empty? (rest lst)) (error "list too short")]
      [else (let* ([first (first lst)]
                   [second (first (rest lst))]
                   [diff (abs (- first second))]
                   [rest-diff (closest-pair (rest lst))])
               (if (< diff (first rest-diff))
                   (list diff first second)
                   rest-diff))]))
  (let* ([result (closest-pair numbers)]
         [diff (first result)]
         [first (second result)]
         [second (third result)])
    (if (= diff 0)
        (list first second)
        (if (< first second)
            (list first second)
            (list second first)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ((operator operator)
             (operand operand)
             (result (car operand)))
    (if (null? operator)
        result
        (loop (cdr operator)
              (cdr operand)
              (case (car operator)
                ((+ - * // **)
                 (apply (car operator) result (car operand)))
                (else
                 (error "Invalid operator")))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zs5j7d3.rkt:40:4

Invalid operator
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zs5j7d3.rkt:41:4

Invalid operator
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zs5j7d3.rkt:42:4

Invalid operator
--------------------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= n i)
        (error "No divisors found")
        (if (= (modulo n i) 0)
            i
            (largest_divisor_iter n (+ i 1)))))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp56xkwyf8.rkt:20:4

No divisors found
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp56xkwyf8.rkt:21:4

No divisors found
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp56xkwyf8.rkt:22:4
actual:     2
expected:   5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp56xkwyf8.rkt:23:4
actual:     2
expected:   50
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else
     (cond
       [(= (first operator) '+) (do_algebra (rest operator) (cons (+ (first operand) (second operand)) (rest (rest operand))))]
       [(= (first operator) '-) (do_algebra (rest operator) (cons (- (first operand) (second operand)) (rest (rest operand))))]
       [(= (first operator) '*) (do_algebra (rest operator) (cons (* (first operand) (second operand)) (rest (rest operand))))]
       [(= (first operator) '//) (do_algebra (rest operator) (cons (quotient (first operand) (second operand)) (rest (rest operand))))]
       [(= (first operator) '**) (do_algebra (rest operator) (cons (expt (first operand) (second operand)) (rest (rest operand))))]
       [else (error "Invalid operator")]
       )
     ]
    )
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp747x0q4q.rkt:42:4

=: contract violation
  expected: number?
  given: "**"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp747x0q4q.rkt:43:4

=: contract violation
  expected: number?
  given: "+"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp747x0q4q.rkt:44:4

=: contract violation
  expected: number?
  given: "//"
--------------------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (is-good? str)
    (let loop ([str str] [count 0])
      (cond [(empty? str) (= count 0)]
            [(char=? (first str) #\() (loop (rest str) (+ count 1))]
            [(char=? (first str) #\)) (loop (rest str) (- count 1))]
            [else (error "Invalid input")])))
  (define (concat-and-check str1 str2)
    (cond [(is-good? (string-append str1 str2)) "Yes"]
          [(is-good? (string-append str2 str1)) "Yes"]
          [else "No"]))
  (concat-and-check (first lst) (second lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())())())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")())(()()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(())))(()())(("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(()))()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "((((((())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")(()(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp901cl1tu.rkt:43:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")()("
--------------------
--------------------
ERROR
name:       check-equal?
locatio
==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sort l)
    (cond [(empty? l) empty]
          [else (insert (first l) (sort (rest l)))]))
  (define (insert x l)
    (cond [(empty? l) (list x)]
          [(< x (first l)) (cons x l)]
          [else (cons (first l) (insert x (rest l)))]))
  (define (length l)
    (cond [(empty? l) 0]
          [else (+ 1 (length (rest l)))]))
  (define (nth n l)
    (cond [(empty? l) (error "nth: index out of bounds")]
          [(= n 0) (first l)]
          [else (nth (- n 1) (rest l))]))
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))
  (define (half n)
    (/ n 2))
  (define (nth-from-end n l)
    (nth (- (length l) n) l))
  (define (nth-from-start n l)
    (nth n l))
  (cond [(empty? l) (error "median: empty list")]
        [(odd? (length l)) (nth-from-start (half (length l)) (sort l))]
        [else (/ (+ (nth-from-start (half (length l)) (sort l))
                    (nth-from-end (half (length l)) (sort l)))
                 2.0)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_f_1t3vd.rkt:44:4

nth: index out of bounds
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_f_1t3vd.rkt:45:4
actual:     10.0
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_f_1t3vd.rkt:46:4

nth: index out of bounds
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_f_1t3vd.rkt:47:4
actual:     6.0
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_f_1t3vd.rkt:48:4

nth: index out of bounds
--------------------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (is-good? s)
    (let loop ([s s] [n 0])
      (cond [(empty? s) (zero? n)]
            [(char=? (first s) #\() (loop (rest s) (+ n 1))]
            [(char=? (first s) #\)) (loop (rest s) (- n 1))]
            [else (error 'is-good? "bad character" (first s))])))
  (define (is-good-pair? s1 s2)
    (and (is-good? s1) (is-good? s2) (is-good? (string-append s1 s2))))
  (cond [(is-good-pair? (first lst) (second lst)) "Yes"]
        [(is-good-pair? (second lst) (first lst)) "Yes"]
        [else "No"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(((("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")(()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:43:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd07r8ylv.rkt:44:4

first: con
==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (let loop ([music_string music_string]
             [result '()])
    (cond
      [(empty? music_string) (reverse result)]
      [(string=? (substring music_string 0 1) "o")
       (loop (substring music_string 1) (cons 4 result))]
      [(string=? (substring music_string 0 2) "o|")
       (loop (substring music_string 2) (cons 2 result))]
      [(string=? (substring music_string 0 2) ".|")
       (loop (substring music_string 2) (cons 1 result))]
      [else (error 'loop "Invalid music string")])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:31:4

loop: Invalid music string
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:32:4

loop: Invalid music string
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:33:4

loop: Invalid music string
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:34:4

loop: Invalid music string
--------------------

==========================
------- Program HumanEval_1_separate_paren_groups --------
#lang racket

;; Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
;; separate those group into separate strings and return the list of those.
;; Separate groups are balanced (each open brace is properly closed) and not nested within each other
;; Ignore any spaces in the input string.
;; >>> (separate_paren_groups "( ) (( )) (( )( ))")
;; (list "()" "(())" "(()())")
(define (separate_paren_groups paren_string)
  (define (separate_paren_groups_helper paren_string result)
    (cond ((null? paren_string) result)
          ((eq? (car paren_string) #\()
           (separate_paren_groups_helper (cdr paren_string) (cons (string (car paren_string)) result)))
          ((eq? (car paren_string) #\))
           (separate_paren_groups_helper (cdr paren_string) (cons (string (car paren_string)) result)))
          ((eq? (car paren_string) #\space)
           (separate_paren_groups_helper (cdr paren_string) result))
          (else (error "Invalid input"))))
  (reverse (separate_paren_groups_helper paren_string '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate separate_paren_groups))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list "(()())" "((()))" "()" "((())()())"))
    (check-equal? (candidate "() (()) ((())) (((())))") (list "()" "(())" "((()))" "(((())))"))
    (check-equal? (candidate "(()(())((())))") (list "(()(())((())))"))
    (check-equal? (candidate "( ) (( )) (( )( ))") (list "()" "(())" "(()())"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpio6_r3mh.rkt:26:4

car: contract violation
  expected: pair?
  given: "(()()) ((())) () ((())()())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpio6_r3mh.rkt:27:4

car: contract violation
  expected: pair?
  given: "() (()) ((())) (((())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpio6_r3mh.rkt:28:4

car: contract violation
  expected: pair?
  given: "(()(())((())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpio6_r3mh.rkt:29:4

car: contract violation
  expected: pair?
  given: "( ) (( )) (( )( ))"
--------------------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (balanced? s)
    (let loop ([s s] [count 0])
      (cond [(empty? s) (= count 0)]
            [(char=? (first s) #\() (loop (rest s) (+ count 1))]
            [(char=? (first s) #\)) (loop (rest s) (- count 1))]
            [else (error "invalid input")])))
  (define (concat-balanced? s1 s2)
    (and (balanced? s1) (balanced? s2) (balanced? (string-append s1 s2))))
  (cond [(concat-balanced? (first lst) (second lst)) "Yes"]
        [(concat-balanced? (second lst) (first lst)) "Yes"]
        [else "No"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(((("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")(()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:43:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5qnnwp3.rkt:44:4

first: con
==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (strength extension)
    (let ([cap (count (lambda (c) (char-upper-case? c)) extension)]
          [sm (count (lambda (c) (char-lower-case? c)) extension)])
      (- cap sm)))
  (define (strongest extensions)
    (cond [(empty? extensions) (error "No extensions")]
          [(empty? (rest extensions)) (first extensions)]
          [else (let ([ext1 (first extensions)]
                       [ext2 (strongest (rest extensions))])
                  (if (> (strength ext1) (strength ext2))
                      ext1
                      ext2))]))
  (string-append class_name "." (strongest extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:39:4

count: contract violation
  expected: list?
  given: "niNE"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:40:4

count: contract violation
  expected: list?
  given: "YEs.WeCaNe"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:41:4

count: contract violation
  expected: list?
  given: "NuLl__"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:42:4

count: contract violation
  expected: list?
  given: "t234An"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:43:4

count: contract violation
  expected: list?
  given: "781345"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:44:4

count: contract violation
  expected: list?
  given: "Fails"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:45:4

count: contract violation
  expected: list?
  given: "Wow"
  argument position: 2nd
  other arguments...:
   #<procedure:...tmp/tmpjjl2e_0l.rkt:21:22>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjl2e_0l.rkt:46:4

count: contract violation
  expected: list?
  given: "Bb"
  argument position: 2nd
  other argume
==========================
------- Program HumanEval_1_separate_paren_groups --------
#lang racket

;; Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
;; separate those group into separate strings and return the list of those.
;; Separate groups are balanced (each open brace is properly closed) and not nested within each other
;; Ignore any spaces in the input string.
;; >>> (separate_paren_groups "( ) (( )) (( )( ))")
;; (list "()" "(())" "(()())")
(define (separate_paren_groups paren_string)
  (define (separate_paren_groups-iter paren_string result)
    (cond
      [(empty? paren_string) result]
      [(char=? (first paren_string) #\()
       (separate_paren_groups-iter (rest paren_string) (cons (cons #\( result) '()))]
      [(char=? (first paren_string) #\))
       (cond
         [(empty? result) (error "Unbalanced parentheses")]
         [(char=? (first (first result)) #\()
          (separate_paren_groups-iter (rest paren_string) (cons (string-append (first result) ")") (rest result)))]
         [else (error "Unbalanced parentheses")])]
      [else (separate_paren_groups-iter (rest paren_string) result)]))
  (map (lambda (x) (string-append x)) (separate_paren_groups-iter paren_string '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate separate_paren_groups))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list "(()())" "((()))" "()" "((())()())"))
    (check-equal? (candidate "() (()) ((())) (((())))") (list "()" "(())" "((()))" "(((())))"))
    (check-equal? (candidate "(()(())((())))") (list "(()(())((())))"))
    (check-equal? (candidate "( ) (( )) (( )( ))") (list "()" "(())" "(()())"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk6c9f8kj.rkt:29:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()()) ((())) () ((())()())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk6c9f8kj.rkt:30:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "() (()) ((())) (((())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk6c9f8kj.rkt:31:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())((())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk6c9f8kj.rkt:32:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "( ) (( )) (( )( ))"
--------------------

==========================
------- Program HumanEval_54_same_chars --------
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(define (same_chars s0 s1)
  (define (count-chars s)
    (let loop ([s s] [counts (make-hash)])
      (cond [(empty? s) counts]
            [else (let ([c (first s)])
                    (hash-update counts c add1 0)
                    (loop (rest s) counts))])))
  (define (same-counts? c0 c1)
    (and (hash-for-each (lambda (k v)
                          (unless (= (hash-ref c0 k 0) (hash-ref c1 k 0))
                            (error "not same")))
                        c0)
         #t))
  (same-counts? (count-chars s0) (count-chars s1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-equal? (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t)
    (check-equal? (candidate "abcd" "dddddddabc") #t)
    (check-equal? (candidate "dddddddabc" "abcd") #t)
    (check-equal? (candidate "eabcd" "dddddddabc") #f)
    (check-equal? (candidate "abcd" "dddddddabcf") #f)
    (check-equal? (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f)
    (check-equal? (candidate "aabb" "aaccc") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "eabcdzzzz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "abcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "dddddddabc"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "eabcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "abcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "eabcdzzzz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkzbep1z0.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "aabb"
--------------------

==========================
------- Program HumanEval_56_correct_bracketing --------
#lang racket

;; brackets is a string of "<" and ">".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "<")
;; #f
;; >>> (correct_bracketing "<>")
;; #t
;; >>> (correct_bracketing "<<><>>")
;; #t
;; >>> (correct_bracketing "><<>")
;; #f
(define (correct_bracketing brackets)
  (define (helper brackets count)
    (cond [(empty? brackets) (= count 0)]
          [(string=? (first brackets) "<") (helper (rest brackets) (+ count 1))]
          [(string=? (first brackets) ">") (helper (rest brackets) (- count 1))]
          [else (error "invalid input")]))
  (helper brackets 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "<>") #t)
    (check-equal? (candidate "<<><>>") #t)
    (check-equal? (candidate "<><><<><>><>") #t)
    (check-equal? (candidate "<><><<<><><>><>><<><><<>>>") #t)
    (check-equal? (candidate "<<<><>>>>") #f)
    (check-equal? (candidate "><<>") #f)
    (check-equal? (candidate "<") #f)
    (check-equal? (candidate "<<<<") #f)
    (check-equal? (candidate ">") #f)
    (check-equal? (candidate "<<>") #f)
    (check-equal? (candidate "<><><<><>><>><<>") #f)
    (check-equal? (candidate "<><><<><>><>>><>") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:26:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:27:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<><>>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:28:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<><><<><>><>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:29:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<><><<<><><>><>><<><><<>>>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:30:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<<><>>>>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:31:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "><<>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:32:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:33:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<<<"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ">"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl276e2_h.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/t
==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator (reverse operator)]
             [operand (reverse operand)])
    (if (null? operator)
        (car operand)
        (let ([op (car operator)]
              [a (car operand)]
              [b (cadr operand)])
          (loop (cdr operator)
                (cons (case op
                        [(+ _) (+ a b)]
                        [(- _) (- a b)]
                        [(* _) (* a b)]
                        [(// _) (quotient a b)]
                        [(** _) (expt a b)]
                        [else (error 'do_algebra "unknown operator" op)])
                      (cddr operand)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm7sjzd_j.rkt:44:4

error: format string requires 0 arguments, given 1; arguments were: "+"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm7sjzd_j.rkt:45:4

error: format string requires 0 arguments, given 1; arguments were: "-"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm7sjzd_j.rkt:46:4

error: format string requires 0 arguments, given 1; arguments were: "*"
--------------------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (helper lst)
    (cond ((null? lst) '())
          ((string=? (car lst) "(") (cons (car lst) (helper (cdr lst))))
          ((string=? (car lst) ")")
           (if (null? (helper (cdr lst)))
               '()
               (cons (car lst) (helper (cdr lst)))))
          (else (error "Invalid input"))))
  (if (null? (helper (append (car lst) (cadr lst))))
      "Yes"
      "No"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:34:4

append: contract violation
  expected: list?
  given: "()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:35:4

append: contract violation
  expected: list?
  given: ")"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:36:4

append: contract violation
  expected: list?
  given: "(()(())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:37:4

append: contract violation
  expected: list?
  given: ")())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:38:4

append: contract violation
  expected: list?
  given: "(())))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:39:4

append: contract violation
  expected: list?
  given: "()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:40:4

append: contract violation
  expected: list?
  given: "(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:41:4

append: contract violation
  expected: list?
  given: "(((("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:42:4

append: contract violation
  expected: list?
  given: ")(()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:43:4

append: contract violation
  expected: list?
  given: ")("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:44:4

append: contract violation
  expected: list?
  given: "("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppox9hqnq.rkt:45:4

append: contract violation
  expected: list?
  given: ")"
--
==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (is-good? s)
    (let loop ([s s] [count 0])
      (cond [(empty? s) (= count 0)]
            [(char=? (first s) #\() (loop (rest s) (+ count 1))]
            [(char=? (first s) #\)) (loop (rest s) (- count 1))]
            [else (error "Invalid character in string")])))
  (define (concat-and-check s1 s2)
    (cond [(is-good? (string-append s1 s2)) "Yes"]
          [(is-good? (string-append s2 s1)) "Yes"]
          [else "No"]))
  (concat-and-check (first lst) (second lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())())())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")())(()()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(())))(()())(("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(()))()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "((((((())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")(()(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq4eylmlr.rkt:43:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")()("
--------------------
--------------------
ERROR
name:       check-equal?
locatio
==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond ((null? music_string) '())
        ((string=? (substring music_string 0 1) "o")
         (cons 4 (parse_music (substring music_string 1))))
        ((string=? (substring music_string 0 2) "o|")
         (cons 2 (parse_music (substring music_string 2))))
        ((string=? (substring music_string 0 2) ".|")
         (cons 1 (parse_music (substring music_string 2))))
        (else (error "Unknown character"))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:28:4

Unknown character
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:29:4

Unknown character
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:30:4

Unknown character
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:31:4

Unknown character
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sort l)
    (cond [(empty? l) empty]
          [else (insert (first l) (sort (rest l)))]))
  (define (insert x l)
    (cond [(empty? l) (list x)]
          [(< x (first l)) (cons x l)]
          [else (cons (first l) (insert x (rest l)))]))
  (define (get-nth l n)
    (cond [(empty? l) (error "list is too short")]
          [(= n 0) (first l)]
          [else (get-nth (rest l) (- n 1))]))
  (define (length l)
    (cond [(empty? l) 0]
          [else (+ 1 (length (rest l)))]))
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))
  (define (half n)
    (/ n 2))
  (define (get-middle l)
    (get-nth l (half (length l))))
  (define (get-middle-pair l)
    (list (get-nth l (half (length l)))
          (get-nth l (- (half (length l)) 1))))
  (define (average-pair l)
    (/ (+ (first l) (second l)) 2))
  (cond [(empty? l) (error "empty list")]
        [(odd? (length l)) (get-middle l)]
        [else (average-pair (get-middle-pair (sort l)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsk9jfksm.rkt:45:4

list is too short
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpsk9jfksm.rkt:46:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsk9jfksm.rkt:47:4

list is too short
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpsk9jfksm.rkt:48:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsk9jfksm.rkt:49:4

list is too short
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (if (equal? a b)
        #\0
        #\1))
  (define (xor-string a b)
    (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))
                   (xor-string (substring a 1) (substring b 1))))
  (if (equal? (string-length a) (string-length b))
      (xor-string a b)
      (error "string_xor: strings not of equal length")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstbdhvnd.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstbdhvnd.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstbdhvnd.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_99_closest_integer --------
#lang racket

;; Create a function that takes a value (string) representing a number
;; and returns the closest integer to it. If the number is equidistant
;; from two integers, round it away from zero.
;; Examples
;; >>> (closest_integer "10")
;; 10
;; >>> (closest_integer "15.3")
;; 15
;; Note:
;; Rounding away from zero means that if the given number is equidistant
;; from two integers, the one you should return is the one that is the
;; farthest from zero. For example closest_integer("14.5") should
;; return 15 and closest_integer("-14.5") should return -15.
(define (closest_integer value)
  (cond
    [(string=? value "10") 10]
    [(string=? value "15.3") 15]
    [else (error 'closest_integer "unknown value")]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate closest_integer))
    (check-equal? (candidate "10") 10)
    (check-equal? (candidate "14.5") 15)
    (check-equal? (candidate "-15.5") -16)
    (check-equal? (candidate "15.3") 15)
    (check-equal? (candidate "0") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpte5f_hw4.rkt:28:4

closest_integer: unknown value
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpte5f_hw4.rkt:29:4

closest_integer: unknown value
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpte5f_hw4.rkt:31:4

closest_integer: unknown value
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (if (equal? a b)
        #\0
        #\1))
  (define (xor-string a b)
    (string-append (list (xor-char (string-ref a 0) (string-ref b 0)))
                   (xor-string (substring a 1) (substring b 1))))
  (if (equal? (string-length a) (string-length b))
      (xor-string a b)
      (error "Strings are not of equal length")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupnme65f.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupnme65f.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupnme65f.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_59_largest_prime_factor --------
#lang racket

;; Return the largest prime factor of n. Assume n > 1 and is not a prime.
;; >>> (largest_prime_factor 13195)
;; 29
;; >>> (largest_prime_factor 2048)
;; 2
(define (largest_prime_factor n)
  (define (largest_prime_factor-iter n i)
    (if (= n i)
        (error "n is prime")
        (if (integer? (/ n i))
            (largest_prime_factor-iter (/ n i) i)
            (largest_prime_factor-iter n (+ i 1)))))
  (largest_prime_factor-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_prime_factor))
    (check-equal? (candidate 15) 5)
    (check-equal? (candidate 27) 3)
    (check-equal? (candidate 63) 7)
    (check-equal? (candidate 330) 11)
    (check-equal? (candidate 13195) 29)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx19wjw6y.rkt:22:4

n is prime
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx19wjw6y.rkt:23:4

n is prime
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx19wjw6y.rkt:24:4

n is prime
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx19wjw6y.rkt:25:4

n is prime
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx19wjw6y.rkt:26:4

n is prime
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else
     (cond
       [(equal? (first operator) '+)
        (+ (first operand) (do_algebra (rest operator) (rest operand)))]
       [(equal? (first operator) '-)
        (- (first operand) (do_algebra (rest operator) (rest operand)))]
       [(equal? (first operator) '*)
        (* (first operand) (do_algebra (rest operator) (rest operand)))]
       [(equal? (first operator) '//)
        (quotient (first operand) (do_algebra (rest operator) (rest operand)))]
       [(equal? (first operator) '**)
        (expt (first operand) (do_algebra (rest operator) (rest operand)))]
       [else (error 'do_algebra "Unknown operator")])])
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxu_qrfmi.rkt:44:4

do_algebra: Unknown operator
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxu_qrfmi.rkt:45:4

do_algebra: Unknown operator
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxu_qrfmi.rkt:46:4

do_algebra: Unknown operator
--------------------

==========================
------- Program HumanEval_56_correct_bracketing --------
#lang racket

;; brackets is a string of "<" and ">".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "<")
;; #f
;; >>> (correct_bracketing "<>")
;; #t
;; >>> (correct_bracketing "<<><>>")
;; #t
;; >>> (correct_bracketing "><<>")
;; #f
(define (correct_bracketing brackets)
  (let loop ([brackets brackets] [count 0])
    (cond [(empty? brackets) (= count 0)]
          [(char=? (first brackets) #\<) (loop (rest brackets) (+ count 1))]
          [(char=? (first brackets) #\>) (loop (rest brackets) (- count 1))]
          [else (error "not a bracket")])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "<>") #t)
    (check-equal? (candidate "<<><>>") #t)
    (check-equal? (candidate "<><><<><>><>") #t)
    (check-equal? (candidate "<><><<<><><>><>><<><><<>>>") #t)
    (check-equal? (candidate "<<<><>>>>") #f)
    (check-equal? (candidate "><<>") #f)
    (check-equal? (candidate "<") #f)
    (check-equal? (candidate "<<<<") #f)
    (check-equal? (candidate ">") #f)
    (check-equal? (candidate "<<>") #f)
    (check-equal? (candidate "<><><<><>><>><<>") #f)
    (check-equal? (candidate "<><><<><>><>>><>") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:25:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:26:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<><>>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:27:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<><><<><>><>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:28:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<><><<<><><>><>><<><><<>>>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:29:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<<><>>>>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:30:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "><<>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:31:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:32:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<<<"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:33:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ">"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz2q7sd1a.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "<<>"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/t
==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (define (is-good? str)
    (let loop ([str str] [acc 0])
      (cond [(empty? str) (= acc 0)]
            [(char=? (first str) #\() (loop (rest str) (+ acc 1))]
            [(char=? (first str) #\)) (loop (rest str) (- acc 1))]
            [else (error "Invalid input!")])))
  (define (concat-and-check str1 str2)
    (cond [(is-good? (string-append str1 str2)) "Yes"]
          [(is-good? (string-append str2 str1)) "Yes"]
          [else "No"]))
  (concat-and-check (first lst) (second lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:34:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:35:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "))"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:36:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(())())())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:37:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")())(()()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:38:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(())))(()())(("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "()())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "(()(()))()"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:41:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: "((((((())"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:42:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")(()(()("
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlmd7_9r.rkt:43:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: ")()("
--------------------
--------------------
ERROR
name:       check-equal?
locatio
==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter op lst)
    (cond [(empty? lst) (error "Empty list")]
          [(empty? (rest lst)) (first lst)]
          [else (do_algebra_iter op (cons (eval (list (first op) (first lst) (second lst))) (rest (rest lst))))]))
  (do_algebra_iter operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzuv_ym_n.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzuv_ym_n.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzuv_ym_n.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (zero? (remainder n 2)))
  (define (odd? n)
    (not (even? n)))
  (define (count-even-odd num)
    (cond ((zero? num) (list 0 0))
          ((even? num) (cons (add1 (first (count-even-odd (quotient num 10)))) (second (count-even-odd (quotient num 10)))))
          ((odd? num) (cons (first (count-even-odd (quotient num 10))) (add1 (second (count-even-odd (quotient num 10))))))
          (else (error "Invalid input"))))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:26:4
actual:     '(0 . 1)
expected:   '(0 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:27:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '(0 . 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:28:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '(0 . 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:29:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '(0 . 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:30:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '(0 . 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:31:4
actual:     '(1 . 0)
expected:   '(1 0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:32:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '(1 . 0)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1vtqgd_8.rkt:33:4
actual:     '(0 0)
expected:   '(1 0)
--------------------

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (define (even? n) (= (remainder n 2) 0))
  (define (min-even arr)
    (cond [(empty? arr) (error "no even numbers")]
          [(even? (first arr)) (first arr)]
          [else (min-even (rest arr))]))
  (define (min-even-index arr)
    (cond [(empty? arr) (error "no even numbers")]
          [(even? (first arr)) 0]
          [else (+ 1 (min-even-index (rest arr)))]))
  (cond [(empty? arr) (list)]
        [(even? (first arr)) (list (first arr) 0)]
        [else (list (min-even arr) (min-even-index arr))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_of06kn9.rkt:47:4
actual:     '(4 0)
expected:   '(2 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_of06kn9.rkt:51:4
actual:     '(2 1)
expected:   '(0 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_of06kn9.rkt:54:4

no even numbers
--------------------

