HumanEval_37_sort_even: 2
HumanEval_68_pluck: 4
HumanEval_120_maximum: 5
HumanEval_135_can_arrange: 135
HumanEval_147_get_max_triples: 8
HumanEval_47_median: 9
HumanEval_127_intersection: 15
HumanEval_136_largest_smallest_integers: 25
HumanEval_73_smallest_change: 21
HumanEval_89_encrypt: 3
HumanEval_130_tri: 25
HumanEval_129_minPath: 3
HumanEval_0_has_close_elements: 4
HumanEval_109_move_one_ball: 4
HumanEval_124_valid_date: 3
HumanEval_40_triples_sum_to_zero: 1
HumanEval_121_solution: 10
HumanEval_70_strange_sort_list: 2
HumanEval_93_encode: 1
HumanEval_143_words_in_sentence: 1
==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (cond
    [(empty? l) empty]
    [(empty? (rest l)) l]
    [else (cons (first l)
                (sort_even (cons (min (second l) (third l))
                                 (cons (max (second l) (third l))
                                       (rest (rest (rest l)))))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0_kjx7wi.rkt:24:4

third: list contains too few elements
  list: '(2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0_kjx7wi.rkt:25:4

third: list contains too few elements
  list: '(-10 123)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0_kjx7wi.rkt:26:4

third: list contains too few elements
  list: '(-10 23)
--------------------

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (cond
    [(empty? arr) empty]
    [(even? (first arr))
     (let ([min-even (first arr)])
       (for/fold ([min-even-index 0]
                  [min-even-index-found #f])
                 ([i (in-naturals)])
         (cond
           [(even? (list-ref arr i))
            (cond
              [(not min-even-index-found)
               (values (list min-even i) #t)]
              [(< min-even (list-ref arr i))
               (values (list min-even min-even-index) #t)]
              [else
               (values (list (list-ref arr i) i) #t)])]
           [else
            (values (list min-even min-even-index) min-even-index-found)])))]
    [else
     (pluck (rest arr))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0u0w5e7g.rkt:55:4

list-ref: index too large for list
  index: 3
  in: '(4 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0u0w5e7g.rkt:56:4

list-ref: index too large for list
  index: 2
  in: '(2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0u0w5e7g.rkt:58:4

list-ref: index too large for list
  index: 5
  in: '(0 3 0 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0u0w5e7g.rkt:59:4

list-ref: index too large for list
  index: 5
  in: '(2 3 0 5 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0u0w5e7g.rkt:60:4

list-ref: index too large for list
  index: 4
  in: '(4 8 4 8)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0u0w5e7g.rkt:61:4

list-ref: index too large for list
  index: 3
  in: '(6 7 1)
--------------------

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (sort (list-ref arr k) >))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:26:4

list-ref: index too large for list
  index: 3
  in: '(-3 -4 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:27:4

sort: contract violation
  expected: list?
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:28:4

sort: contract violation
  expected: list?
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:29:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:30:4

sort: contract violation
  expected: list?
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:31:4

list-ref: index too large for list
  index: 7
  in: '(5 15 0 3 -13 -8 0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:32:4

sort: contract violation
  expected: list?
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:33:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:34:4

list-ref: index too large for list
  index: 2
  in: '(4 -4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:35:4

list-ref: index too large for list
  index: 2
  in: '(-10 10)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1w9otf0b.rkt:36:4

sort: contract violation
  expected: list?
  given: 1
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (helper arr i)
    (if (= i (- (length arr) 1))
        -1
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (helper arr (+ i 1))
            i)))
  (helper arr 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27kow838.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27kow838.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27kow838.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27kow838.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27kow838.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (triples lst)
    (cond [(empty? lst) 0]
          [(and (empty? (rest lst)) (empty? (rest (rest lst)))) 0]
          [(and (empty? (rest (rest lst))) (zero? (modulo (+ (first lst) (second lst) (third lst)) 3))) 1]
          [(zero? (modulo (+ (first lst) (second lst) (third lst)) 3)) (+ 1 (triples (rest lst)))]
          [else (triples (rest lst))]))
  (triples (build-list n (lambda (x) (+ (* x x) (- x 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ezqw_cp.rkt:27:4

third: list contains too few elements
  list: '(11 19)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ezqw_cp.rkt:28:4

third: list contains too few elements
  list: '(19 29)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ezqw_cp.rkt:29:4

third: list contains too few elements
  list: '(71 89)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ezqw_cp.rkt:30:4

third: list contains too few elements
  list: '(9701 9899)
--------------------

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (cond
    [(empty? arr) empty]
    [(even? (first arr))
     (let ([min-even (first arr)])
       (for/fold ([min-even-index 0]
                  [min-even-index-found #f])
                 ([i (in-naturals)])
         (cond
           [(even? (list-ref arr i))
            (cond
              [(not min-even-index-found)
               (values (list min-even i) #t)
               ]
              [(< min-even (list-ref arr i))
               (values (list min-even min-even-index) #t)
               ]
              [else
               (values (list (list-ref arr i) i) #t)
               ])
            ]
           [else
            (values (list min-even min-even-index) min-even-index-found)
            ])))]
    [else
     (pluck (rest arr))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ne3yhvp.rkt:60:4

list-ref: index too large for list
  index: 3
  in: '(4 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ne3yhvp.rkt:61:4

list-ref: index too large for list
  index: 2
  in: '(2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ne3yhvp.rkt:63:4

list-ref: index too large for list
  index: 5
  in: '(0 3 0 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ne3yhvp.rkt:64:4

list-ref: index too large for list
  index: 5
  in: '(2 3 0 5 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ne3yhvp.rkt:65:4

list-ref: index too large for list
  index: 4
  in: '(4 8 4 8)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2ne3yhvp.rkt:66:4

list-ref: index too large for list
  index: 3
  in: '(6 7 1)
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (get_a i)
    (+ (* i i) (- i 1)))
  (define (get_triples a)
    (define (get_triples_helper a i j k)
      (cond
        [(> i (- (length a) 2)) 0]
        [(> j (- (length a) 1)) (get_triples_helper a (+ i 1) (+ i 2) (+ i 3))]
        [(> k (length a)) (get_triples_helper a i (+ j 1) (+ j 2))]
        [(= (modulo (+ (list-ref a i) (list-ref a j) (list-ref a k)) 3) 0) (+ 1 (get_triples_helper a i j (+ k 1)))]
        [else (get_triples_helper a i j (+ k 1))]))
    (get_triples_helper a 0 1 2))
  (get_triples (build-list n get_a)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2vfiji_e.rkt:32:4

list-ref: index too large for list
  index: 5
  in: '(-1 1 5 11 19)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2vfiji_e.rkt:33:4

list-ref: index too large for list
  index: 6
  in: '(-1 1 5 11 19 29)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2vfiji_e.rkt:34:4

list-ref: index too large for list
  index: 10
  in: '(-1 1 5 11 19 29 41 55 71 89)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2vfiji_e.rkt:35:4

list-ref: index too large for list
  index: 100
  in: '(-1 1 5 11 19 29 41 55 71 89 109 131 155 181 209 239 271 305 341 379 419 461 505 551 599 649 701 755 811 869 929 991 1055 1121 1189 1259 1331 1405 1481 1559 1639 1721 1805 1891 1979 2069 2161 2255 2351 2449 2549 2651 2755 2861 2969 3079 3191 3305 3421 ...
--------------------

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (sort (list-ref arr (sub1 k)) (list-ref arr (sub1 k)) #:key (lambda (x) (abs x))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:26:4

sort: contract violation
  expected: list?
  given: 5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:27:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:28:4

sort: contract violation
  expected: list?
  given: -3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:29:4

sort: contract violation
  expected: list?
  given: 20
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:30:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:31:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:32:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:33:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:34:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:35:4

sort: contract violation
  expected: list?
  given: 10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31hjir1g.rkt:36:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (let ([sorted (sort l <)])
    (if (even? (length sorted))
        (/ (+ (list-ref sorted (/ (length sorted) 2))
              (list-ref sorted (- (/ (length sorted) 2) 1)))
           2)
        (list-ref sorted (/ (length sorted) 2)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:21:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:22:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:23:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:24:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:25:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (let ([sorted (sort l <)])
    (if (even? (length sorted))
        (/ (+ (list-ref sorted (/ (length sorted) 2))
              (list-ref sorted (- (/ (length sorted) 2) 1)))
           2)
        (list-ref sorted (/ (length sorted) 2)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:21:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:22:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:23:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:24:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ah7y_hb.rkt:25:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(and (and (<= (first interval1) (first interval2))
                   (<= (first interval2) (second interval1)))
              (and (<= (first interval2) (second interval1))
                   (<= (second interval1) (second interval2))))
         (cons (first interval2)
               (interval-intersection-helper interval1 (rest interval2)))]
        [else (interval-intersection-helper interval1 (rest interval2))]))
    (interval-intersection-helper interval1 interval2))
  (define (interval-length interval)
    (if (empty? interval)
        0
        (- (second interval) (first interval))))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:58:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:59:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:60:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:61:4

second: list contains too few elements
  list: '(-1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:63:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dj104k5.rkt:64:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative_integer lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst)))) (first lst)]
      [else (largest_negative_integer (rest lst))]))
  (define (smallest_positive_integer lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst)))) (first lst)]
      [else (smallest_positive_integer (rest lst))]))
  (list (largest_negative_integer lst)
        (smallest_positive_integer lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:37:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:38:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:39:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:40:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:41:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:44:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:45:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:46:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3dt5x7p2.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (sort (list-ref arr (- (length arr) k)) <))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:26:4

sort: contract violation
  expected: list?
  given: -3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:27:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:28:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:29:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:30:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:31:4

sort: contract violation
  expected: list?
  given: 5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:32:4

sort: contract violation
  expected: list?
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:33:4

sort: contract violation
  expected: list?
  given: -7
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:34:4

sort: contract violation
  expected: list?
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:35:4

sort: contract violation
  expected: list?
  given: -10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3hz90lud.rkt:36:4

list-ref: index too large for list
  index: 7
  in: '(1 2 3 -23 243 -400 0)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change-helper arr n)
    (if (= n 0)
        0
        (let ([a (list-ref arr n)]
              [b (list-ref arr (- (length arr) n 1))])
          (if (= a b)
              (smallest_change-helper arr (- n 1))
              (+ 1 (smallest_change-helper arr (- n 1)))))))
  (smallest_change-helper arr (/ (length arr) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3o4q1nx6.rkt:30:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3o4q1nx6.rkt:31:4

list-ref: index 3/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3o4q1nx6.rkt:32:4
actual:     0
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3o4q1nx6.rkt:33:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3o4q1nx6.rkt:35:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change-helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest_change-helper arr (+ left 1) (- right 1))]
      [else (+ 1 (smallest_change-helper arr (+ left 1) (- right 1))
               (smallest_change-helper arr left (- right 1)))]))
  (smallest_change-helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:28:4

list-ref: index too large for list
  index: 8
  in: '(1 2 3 5 4 7 9 6)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:35:4

list-ref: index too large for list
  index: 2
  in: '(0 1)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change-helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest_change-helper arr (+ left 1) (- right 1))]
      [else (+ 1 (smallest_change-helper arr (+ left 1) (- right 1))
               (smallest_change-helper arr left (- right 1)))]))
  (smallest_change-helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:28:4

list-ref: index too large for list
  index: 8
  in: '(1 2 3 5 4 7 9 6)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3r4vk551.rkt:35:4

list-ref: index too large for list
  index: 2
  in: '(0 1)
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (let ([alphabet (string->list "abcdefghijklmnopqrstuvwxyz")])
    (apply string (map (lambda (c)
                         (list-ref alphabet (+ (- (char->integer c) (char->integer #\a))
                                               (* 2 2))))
                       (string->list s)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4q10guv9.rkt:32:4

list-ref: index too large for list
  index: 26
  in: '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4q10guv9.rkt:33:4

list-ref: index too large for list
  index: 28
  in: '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4q10guv9.rkt:34:4

list-ref: index too large for list
  index: 27
  in: '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(> (first interval1) (first interval2)) (intersection-helper interval2 interval1)]
      [(> (first interval1) (second interval2)) '()]
      [(> (second interval1) (second interval2)) (intersection-helper (rest interval1) interval2)]
      [else (cons (first interval1) (intersection-helper (rest interval1) interval2))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(even? n) #f]
      [else
       (define (is-prime-helper n i)
         (cond
           [(= i n) #t]
           [(= (modulo n i) 0) #f]
           [else (is-prime-helper n (+ i 1))]))
       (is-prime-helper n 3)]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:53:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:54:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:55:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:56:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:58:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:59:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4tfoajrr.rkt:60:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (get-triples lst)
    (for/fold ([acc 0]) ([i (in-range (add1 (length lst)))])
      (for/fold ([acc acc]) ([j (in-range (add1 i))])
        (for/fold ([acc acc]) ([k (in-range (add1 j))])
          (if (and (not (zero? (modulo (+ (list-ref lst i) (list-ref lst j) (list-ref lst k)) 3)))
                  (not (zero? (list-ref lst i)))
                  (not (zero? (list-ref lst j)))
                  (not (zero? (list-ref lst k))))
              (add1 acc)
              acc)))))
  (get-triples (for/list ([i (in-range n)])
                 (add1 (* i (- i 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55csq99l.rkt:32:4

list-ref: index too large for list
  index: 5
  in: '(1 1 3 7 13)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55csq99l.rkt:33:4

list-ref: index too large for list
  index: 6
  in: '(1 1 3 7 13 21)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55csq99l.rkt:34:4

list-ref: index too large for list
  index: 10
  in: '(1 1 3 7 13 21 31 43 57 73)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55csq99l.rkt:35:4

list-ref: index too large for list
  index: 100
  in: '(1 1 3 7 13 21 31 43 57 73 91 111 133 157 183 211 241 273 307 343 381 421 463 507 553 601 651 703 757 813 871 931 993 1057 1123 1191 1261 1333 1407 1483 1561 1641 1723 1807 1893 1981 2071 2163 2257 2353 2451 2551 2653 2757 2863 2971 3081 3193 3307 3423...
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond [(= n 0) (list 1)]
        [(= n 1) (list 1 3)]
        [(= n 2) (list 1 3 2)]
        [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                              (list-ref (tri (- n 1)) (- n 2))
                                              (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:32:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp58ph_vfn.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond ((= i j) 0)
          ((= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j)))
          (else (min (add1 (loop (list-set arr i (list-ref arr j))) (add1 i) j))
                  (add1 (loop (list-set arr j (list-ref arr i)) i (sub1 j)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:25:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:26:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:27:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:28:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:32:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond ((= i j) 0)
          ((= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j)))
          (else (min (add1 (loop (list-set arr i (list-ref arr j))) (add1 i) j))
                  (add1 (loop (list-set arr j (list-ref arr i)) i (sub1 j)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:25:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:26:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:27:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:28:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:32:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond ((= i j) 0)
          ((= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j)))
          (else (min (add1 (loop (list-set arr i (list-ref arr j))) (add1 i) j))
                  (add1 (loop (list-set arr j (list-ref arr i)) i (sub1 j)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:25:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:26:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:27:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:28:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5beqze1s.rkt:32:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------

==========================
------- Program HumanEval_129_minPath --------
#lang racket

;; Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
;; each cell of the grid contains a value. Every integer in the range [1, N * N]
;; inclusive appears exactly once on the cells of the grid.
;; You have to find the minimum path of length k in the grid. You can start
;; from any cell, and in each step you can move to any of the neighbor cells,
;; in other words, you can go to cells which share an edge with you current
;; cell.
;; Please note that a path of length k means visiting exactly k cells (not
;; necessarily distinct).
;; You CANNOT go off the grid.
;; A path A (of length k) is considered less than a path B (of length k) if
;; after making the ordered lists of the values on the cells that A and B go
;; through (let's call them lst_A and lst_B), lst_A is lexicographically less
;; than lst_B, in other words, there exist an integer index i (1 <= i <= k)
;; such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
;; lst_A[j] = lst_B[j].
;; It is guaranteed that the answer is unique.
;; Return an ordered list of the values on the cells that the minimum path go through.
;; Examples:    
;; >>> (minPath (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3)
;; (list 1 2 1)
;; >>> (minPath (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1)
;; (list 1)
(define (minPath grid k)
  (define (minPath-helper grid k i j)
    (cond
      [(= k 0) (list (list-ref (list-ref grid i) j))]
      [(= i 0) (minPath-helper grid (- k 1) i (+ j 1))]
      [(= j 0) (minPath-helper grid (- k 1) (+ i 1) j)]
      [else (min (minPath-helper grid (- k 1) i (+ j 1))
                 (minPath-helper grid (- k 1) (+ i 1) j))]))
  (minPath-helper grid k 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minPath))
    (check-equal? (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1))
    (check-equal? (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1))
    (check-equal? (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2))
    (check-equal? (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1))
    (check-equal? (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1))
    (check-equal? (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1))
    (check-equal? (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6))
    (check-equal? (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3))
    (check-equal? (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5))
    (check-equal? (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2))
    (check-equal? (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:41:4

list-ref: index too large for list
  index: 3
  in: '(1 2 3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:42:4
actual:     '(9)
expected:   '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:43:4

list-ref: index too large for list
  index: 4
  in: '(1 2 3 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:44:4

list-ref: index too large for list
  index: 7
  in: '(6 4 13 10)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:45:4

list-ref: index too large for list
  index: 5
  in: '(8 14 9 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:46:4

list-ref: index too large for list
  index: 9
  in: '(11 8 7 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:47:4

list-ref: index too large for list
  index: 12
  in: '(12 13 10 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:48:4

list-ref: index too large for list
  index: 8
  in: '(2 7 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:49:4

list-ref: index too large for list
  index: 8
  in: '(6 1 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:50:4

list-ref: index too large for list
  index: 10
  in: '(1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:51:4

list-ref: index too large for list
  index: 10
  in: '(1 3)
--------------------

==========================
------- Program HumanEval_129_minPath --------
#lang racket

;; Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
;; each cell of the grid contains a value. Every integer in the range [1, N * N]
;; inclusive appears exactly once on the cells of the grid.
;; You have to find the minimum path of length k in the grid. You can start
;; from any cell, and in each step you can move to any of the neighbor cells,
;; in other words, you can go to cells which share an edge with you current
;; cell.
;; Please note that a path of length k means visiting exactly k cells (not
;; necessarily distinct).
;; You CANNOT go off the grid.
;; A path A (of length k) is considered less than a path B (of length k) if
;; after making the ordered lists of the values on the cells that A and B go
;; through (let's call them lst_A and lst_B), lst_A is lexicographically less
;; than lst_B, in other words, there exist an integer index i (1 <= i <= k)
;; such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
;; lst_A[j] = lst_B[j].
;; It is guaranteed that the answer is unique.
;; Return an ordered list of the values on the cells that the minimum path go through.
;; Examples:    
;; >>> (minPath (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3)
;; (list 1 2 1)
;; >>> (minPath (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1)
;; (list 1)
(define (minPath grid k)
  (define (minPath-helper grid k i j)
    (cond
      [(= k 0) (list (list-ref (list-ref grid i) j))]
      [(= i 0) (minPath-helper grid (- k 1) i (+ j 1))]
      [(= j 0) (minPath-helper grid (- k 1) (+ i 1) j)]
      [else (min (minPath-helper grid (- k 1) i (+ j 1))
                 (minPath-helper grid (- k 1) (+ i 1) j))]))
  (minPath-helper grid k 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minPath))
    (check-equal? (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1))
    (check-equal? (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1))
    (check-equal? (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2))
    (check-equal? (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1))
    (check-equal? (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1))
    (check-equal? (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1))
    (check-equal? (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6))
    (check-equal? (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3))
    (check-equal? (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5))
    (check-equal? (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2))
    (check-equal? (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:41:4

list-ref: index too large for list
  index: 3
  in: '(1 2 3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:42:4
actual:     '(9)
expected:   '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:43:4

list-ref: index too large for list
  index: 4
  in: '(1 2 3 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:44:4

list-ref: index too large for list
  index: 7
  in: '(6 4 13 10)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:45:4

list-ref: index too large for list
  index: 5
  in: '(8 14 9 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:46:4

list-ref: index too large for list
  index: 9
  in: '(11 8 7 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:47:4

list-ref: index too large for list
  index: 12
  in: '(12 13 10 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:48:4

list-ref: index too large for list
  index: 8
  in: '(2 7 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:49:4

list-ref: index too large for list
  index: 8
  in: '(6 1 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:50:4

list-ref: index too large for list
  index: 10
  in: '(1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hiwocaq.rkt:51:4

list-ref: index too large for list
  index: 10
  in: '(1 3)
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sorted-list l)
    (sort l <))
  (define (middle l)
    (if (even? (length l))
        (/ (+ (list-ref l (/ (length l) 2))
              (list-ref l (- (/ (length l) 2) 1)))
           2)
        (list-ref l (/ (length l) 2))))
  (middle (sorted-list l)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5y61004u.rkt:24:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5y61004u.rkt:25:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5y61004u.rkt:26:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5y61004u.rkt:27:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5y61004u.rkt:28:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (sort (list-ref arr (sub1 k)) >))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:26:4

sort: contract violation
  expected: list?
  given: 5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:27:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:28:4

sort: contract violation
  expected: list?
  given: -3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:29:4

sort: contract violation
  expected: list?
  given: 20
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:30:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:31:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:32:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:33:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:34:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:35:4

sort: contract violation
  expected: list?
  given: 10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6dmjk2b0.rkt:36:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index 0])
    (if (= i (length arr))
        (if (= max-index 0)
            -1
            max-index)
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index 0])
    (if (= i (length arr))
        (if (= max-index 0)
            -1
            max-index)
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nvil00e.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond [(empty? lst) #f]
          [(and (negative? (first lst)) (not (negative? (second lst)))) (first lst)]
          [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond [(empty? lst) #f]
          [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]
          [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:30:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:31:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:32:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:33:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:34:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:37:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:38:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:39:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7teya3ep.rkt:40:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (let loop ([numbers numbers]
             [threshold threshold])
    (cond
      [(empty? numbers) #f]
      [(< (abs (- (first numbers) (second numbers))) threshold) #t]
      [else (loop (rest numbers) threshold)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7yuougou.rkt:23:4

second: list contains too few elements
  list: '(2.2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7yuougou.rkt:24:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7yuougou.rkt:25:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7yuougou.rkt:26:4

second: list contains too few elements
  list: '(2.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7yuougou.rkt:28:4

second: list contains too few elements
  list: '(5.1)
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (median-helper l)
    (cond
      [(empty? l) 0]
      [(= (length l) 1) (first l)]
      [(= (length l) 2) (/ (+ (first l) (second l)) 2)]
      [else
       (let ([mid (/ (length l) 2)])
         (if (odd? (length l))
             (list-ref l mid)
             (/ (+ (list-ref l mid) (list-ref l (- mid 1))) 2)))]))
  (median-helper (sort l <)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp84a37p31.rkt:26:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp84a37p31.rkt:27:4
actual:     8
expected:   8.0
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp84a37p31.rkt:29:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp84a37p31.rkt:30:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (if (empty? s)
        empty
        (cons (list-ref s n) (rotate (modulo (+ n 2) (length s)) s))))
  (apply string-append (rotate 2 (string->list s))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8gicuy1w.rkt:28:4

list-ref: index too large for list
  index: 2
  in: '(#\h #\i)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst)) (or (not (negative? (second lst))) (empty? (rest lst)))) (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst)) (or (not (positive? (second lst))) (empty? (rest lst)))) (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:32:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:33:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:34:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:35:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:36:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:39:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:40:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:41:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8iymulty.rkt:42:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sort l)
    (if (null? l)
        '()
        (append (sort (filter (lambda (x) (< x (car l))) (cdr l)))
                (list (car l))
                (sort (filter (lambda (x) (>= x (car l))) (cdr l))))))
  (define (middle l)
    (if (null? l)
        0
        (if (= (modulo (length l) 2) 0)
            (/ (+ (list-ref l (/ (length l) 2)) (list-ref l (- (/ (length l) 2) 1))) 2)
            (list-ref l (/ (length l) 2)))))
  (middle (sort l)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:28:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:29:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:30:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:31:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:32:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sort l)
    (if (null? l)
        '()
        (append (sort (filter (lambda (x) (< x (car l))) (cdr l)))
                (list (car l))
                (sort (filter (lambda (x) (>= x (car l))) (cdr l))))))
  (define (middle l)
    (if (null? l)
        0
        (if (= (modulo (length l) 2) 0)
            (/ (+ (list-ref l (/ (length l) 2)) (list-ref l (- (/ (length l) 2) 1))) 2)
            (list-ref l (/ (length l) 2)))))
  (middle (sort l)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:28:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:29:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:30:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:31:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8mn4pdhm.rkt:32:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (+ 1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (- n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:41:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8p5yccs2.rkt:42:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-i -1])
    (cond [(>= i (length arr)) max-i]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-i)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9nqy6owg.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9nqy6owg.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9nqy6owg.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9nqy6owg.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9voc3_3m.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (let loop ([numbers numbers]
             [threshold threshold])
    (cond [(empty? numbers) #f]
          [(< (abs (- (first numbers) (second numbers))) threshold) #t]
          [else (loop (rest numbers) threshold)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:22:4

second: list contains too few elements
  list: '(2.2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:23:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:24:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:25:4

second: list contains too few elements
  list: '(2.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:27:4

second: list contains too few elements
  list: '(5.1)
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (let loop ([numbers numbers]
             [threshold threshold])
    (cond [(empty? numbers) #f]
          [(< (abs (- (first numbers) (second numbers))) threshold) #t]
          [else (loop (rest numbers) threshold)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:22:4

second: list contains too few elements
  list: '(2.2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:23:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:24:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:25:4

second: list contains too few elements
  list: '(2.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1ed7_pv.rkt:27:4

second: list contains too few elements
  list: '(5.1)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond [(empty? interval1) '()]
          [(empty? interval2) '()]
          [(and (>= (first interval1) (first interval2))
                (<= (first interval1) (second interval2)))
           (cons (first interval1) (intersection-helper (rest interval1) interval2))]
          [(and (>= (first interval2) (first interval1))
                (<= (first interval2) (second interval1)))
           (cons (first interval2) (intersection-helper interval1 (rest interval2)))]
          [else (intersection-helper (rest interval1) (rest interval2))]))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond [(= divisor 1) #t]
            [(= (modulo n divisor) 0) #f]
            [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (length-intersection interval)
    (cond [(empty? interval) 0]
          [else (+ 1 (length-intersection (rest interval)))]))
  (cond [(empty? (intersection-helper interval1 interval2)) "NO"]
        [(is-prime? (length-intersection (intersection-helper interval1 interval2))) "YES"]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:51:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:55:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:56:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:58:4
actual:     "YES"
expected:   "NO"
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond ((= n 0) (list 1))
        ((= n 1) (list 1 3))
        ((= n 2) (list 1 3 2))
        (else (append (tri (- n 1))
                      (list (+ (list-ref (tri (- n 1)) (- n 1))
                               (list-ref (tri (- n 1)) (- n 2))
                               (list-ref (tri (- n 1)) n)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:33:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:34:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:35:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:36:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:37:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:38:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:39:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_hb91077.rkt:40:4

list-ref: index too large for list
  index: 3
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (length arr))
        max
        (let ([curr (list-ref arr i)])
          (if (< curr (list-ref arr (- i 1)))
              (loop (+ i 1) max)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ocvoqcf.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ocvoqcf.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ocvoqcf.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ocvoqcf.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond [(= n 0) (list 1)]
        [(= n 1) (list 1 3)]
        [(= n 2) (list 1 3 2)]
        [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                             (list-ref (tri (- n 1)) (- n 2))
                                             (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:32:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa03ap410.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1))) (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:23:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1))) (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:23:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1))) (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:23:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1))) (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:23:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1))) (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:23:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa_c_12ap.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(empty? arr) max-index]
          [(>= (first arr) (list-ref arr i))
           (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaxr11gog.rkt:24:4

list-ref: index too large for list
  index: 5
  in: '(1 2 4 3 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaxr11gog.rkt:25:4

list-ref: index too large for list
  index: 4
  in: '(1 2 4 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaxr11gog.rkt:26:4

list-ref: index too large for list
  index: 9
  in: '(1 4 2 5 6 7 8 9 10)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaxr11gog.rkt:27:4

list-ref: index too large for list
  index: 5
  in: '(4 8 5 7 3)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (length arr))
        max
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (length arr))
        max
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (length arr))
        max
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbg7oihjq.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (- n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:41:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:42:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:43:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:44:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:45:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (- n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:41:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:42:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:43:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:44:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbnvv5fqx.rkt:45:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (cond [(= i (length arr)) max]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6npcpjq.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6npcpjq.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6npcpjq.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6npcpjq.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (sort (list-ref arr (sub1 k)) (list-ref arr (sub1 k)) #:key (lambda (x) (- x))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:26:4

sort: contract violation
  expected: list?
  given: 5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:27:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:28:4

sort: contract violation
  expected: list?
  given: -3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:29:4

sort: contract violation
  expected: list?
  given: 20
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:30:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:31:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:32:4

sort: contract violation
  expected: list?
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:33:4

sort: contract violation
  expected: list?
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:34:4

sort: contract violation
  expected: list?
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:35:4

sort: contract violation
  expected: list?
  given: 10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd_e8l00t.rkt:36:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (define (move_one_ball-iter arr i)
    (if (or (empty? arr) (= i (length arr)))
        #t
        (if (or (= (list-ref arr i) (list-ref arr (- (length arr) 1)))
                (< (list-ref arr i) (list-ref arr (- i 1))))
            (move_one_ball-iter arr (+ i 1))
            #f)))
  (move_one_ball-iter arr 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdeose5k4.rkt:39:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdeose5k4.rkt:40:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdeose5k4.rkt:41:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdeose5k4.rkt:42:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change_helper arr n)
    (if (= n 0)
        0
        (if (= (list-ref arr n) (list-ref arr (- (length arr) n 1)))
            (smallest_change_helper arr (- n 1))
            (+ 1 (smallest_change_helper arr (- n 1))))))
  (smallest_change_helper arr (/ (length arr) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdot0jrwg.rkt:28:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdot0jrwg.rkt:29:4

list-ref: index 3/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdot0jrwg.rkt:30:4
actual:     0
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdot0jrwg.rkt:31:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdot0jrwg.rkt:33:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) i)]
          [else (loop (+ i 1) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpee1d2hdm.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpee1d2hdm.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpee1d2hdm.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpee1d2hdm.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_124_valid_date --------
#lang racket

;; You have to write a function which validates a given date string and
;; returns #t if the date is valid otherwise #f.
;; The date is valid if all of the following rules are satisfied:
;; 1. The date string is not empty.
;; 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
;; 3. The months should not be less than 1 or higher than 12.
;; 4. The date should be in the format: mm-dd-yyyy
;; >>> (valid_date "03-11-2000")
;; #t
;; >>> (valid_date "15-01-2012")
;; #f
;; >>> (valid_date "04-0-2040")
;; #f
;; >>> (valid_date "06-04-2020")
;; #t
;; >>> (valid_date "06/04/2020")
;; #f
(define (valid_date date)
  (let* ([date-parts (string-split date "-")]
         [month (string->number (list-ref date-parts 0))]
         [day (string->number (list-ref date-parts 1))]
         [year (string->number (list-ref date-parts 2))])
    (and (not (empty? date))
         (and (<= 1 day)
              (or (and (<= day 31)
                       (member month '(1 3 5 7 8 10 12)))
                  (and (<= day 30)
                       (member month '(4 6 9 11)))
                  (and (<= day 29)
                       (= month 2))))
         (<= 1 month)
         (<= month 12)
         (<= 1000 year)
         (<= year 9999))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate valid_date))
    (check-equal? (candidate "03-11-2000") #t)
    (check-equal? (candidate "15-01-2012") #f)
    (check-equal? (candidate "04-0-2040") #f)
    (check-equal? (candidate "06-04-2020") #t)
    (check-equal? (candidate "01-01-2007") #t)
    (check-equal? (candidate "03-32-2011") #f)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "04-31-3000") #f)
    (check-equal? (candidate "06-06-2005") #t)
    (check-equal? (candidate "21-31-2000") #f)
    (check-equal? (candidate "04-12-2003") #t)
    (check-equal? (candidate "04122003") #f)
    (check-equal? (candidate "20030412") #f)
    (check-equal? (candidate "2003-04") #f)
    (check-equal? (candidate "2003-04-12") #f)
    (check-equal? (candidate "04-2003") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpejdiku1a.rkt:49:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpejdiku1a.rkt:54:4

list-ref: index too large for list
  index: 1
  in: '("04122003")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpejdiku1a.rkt:55:4

list-ref: index too large for list
  index: 1
  in: '("20030412")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpejdiku1a.rkt:56:4

list-ref: index too large for list
  index: 2
  in: '("2003" "04")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpejdiku1a.rkt:58:4

list-ref: index too large for list
  index: 2
  in: '("04" "2003")
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-i -1])
    (cond [(= i (sub1 (length arr))) max-i]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-i)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwar6yfj.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwar6yfj.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwar6yfj.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwar6yfj.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwar6yfj.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max-index)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg_amky15.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (empty? l)
      '()
      (cons (first l)
            (if (even? (second l))
                (cons (sort (cons (second l) (sort_even (rest (rest l)))) <)
                      (sort_even (rest (rest l))))
                (cons (second l)
                      (sort_even (rest (rest l))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgj0_zjjz.rkt:25:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgj0_zjjz.rkt:26:4

second: list contains too few elements
  list: '(-10)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgj0_zjjz.rkt:27:4

<: contract violation
  expected: real?
  given: '(-10)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([cur-index i]
              [cur-val (list-ref arr i)])
          (loop (+ i 1)
                (if (and (<= cur-val (list-ref arr (- i 1)))
                         (> cur-index max-index))
                    cur-index
                    max-index))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgtgk7lr_.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgtgk7lr_.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgtgk7lr_.rkt:31:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgtgk7lr_.rkt:32:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-i -1])
    (if (= i (length arr))
        max-i
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-i)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4v_i1mh.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4v_i1mh.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4v_i1mh.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4v_i1mh.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_neg lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst)))) (first lst)]
      [else (largest_neg (rest lst))]))
  (define (smallest_pos lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst)))) (first lst)]
      [else (smallest_pos (rest lst))]))
  (list (largest_neg lst) (smallest_pos lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:36:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:37:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:38:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:39:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:40:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:43:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:44:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:45:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphfqvlfe_.rkt:46:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max 0])
    (if (= i (length arr))
        (if (= max 0)
            -1
            max)
        (if (< (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) i)
            (loop (+ i 1) max)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphtakehsd.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphtakehsd.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphtakehsd.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphtakehsd.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(and (<= (first interval1) (first interval2))
              (<= (first interval2) (second interval1)))
         (cons (first interval2) (interval-intersection-helper interval1 (rest interval2)))]
        [else (interval-intersection-helper (rest interval1) interval2)]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (length-interval interval)
    (- (second interval) (first interval)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (length-interval (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:52:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:53:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (sub1 (length arr)))
        max
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) max)
              (loop (add1 i) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpib9k0y1j.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpib9k0y1j.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpib9k0y1j.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpib9k0y1j.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpib9k0y1j.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpihk07b87.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(or (empty? interval1) (empty? interval2)) empty]
        [(and (<= (first interval1) (first interval2)) (<= (first interval2) (second interval1)))
         (cons (first interval2) (intersection-helper-helper interval1 (rest interval2)))]
        [else (intersection-helper-helper interval1 (rest interval2))]))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (- (second (intersection-helper interval1 interval2)) (first (intersection-helper interval1 interval2)))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:48:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:49:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:51:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:55:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (helper lst acc)
    (cond
      [(empty? lst) acc]
      [(and (positive? (first lst)) (not (positive? (second lst))))
       (helper (rest lst) (cons (first lst) acc))]
      [(and (negative? (first lst)) (not (negative? (second lst))))
       (helper (rest lst) (cons (first lst) acc))]
      [else (helper (rest lst) acc)]))
  (let ([negatives (helper lst '())]
        [positives (helper lst '())])
    (if (empty? negatives)
        (cons #f (first positives))
        (cons (first negatives) (first positives)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:34:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:35:4
actual:     '(7 . 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:36:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:37:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:38:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:39:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:40:4

first: contract violation
  expected: (and/c list? (not/c empty?))
  given: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:41:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:42:4
actual:     '(-6 . -6)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:43:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj450qj_p.rkt:44:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sorted-list l)
    (sort l <))
  (define (middle-element l)
    (if (even? (length l))
        (/ (+ (list-ref l (/ (length l) 2))
              (list-ref l (- (/ (length l) 2) 1)))
           2)
        (list-ref l (/ (length l) 2))))
  (middle-element (sorted-list l)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjg9fkzgv.rkt:24:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjg9fkzgv.rkt:25:4
actual:     8
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjg9fkzgv.rkt:26:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjg9fkzgv.rkt:27:4
actual:     11/2
expected:   5.5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjg9fkzgv.rkt:28:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval2 interval1)]
        [(> (first interval1) (second interval2)) empty]
        [(> (second interval1) (second interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) interval2))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:54:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:55:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:56:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:57:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:58:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:59:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:60:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0hk5x5y.rkt:61:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (letrec ([arr-rev (reverse arr)]
           [arr-rev-len (length arr-rev)]
           [arr-rev-len-1 (- arr-rev-len 1)]
           [arr-rev-len-2 (- arr-rev-len 2)]
           [arr-rev-len-3 (- arr-rev-len 3)])
    (cond [(= arr-rev-len 0) -1]
          [(= arr-rev-len 1) -1]
          [(= arr-rev-len 2) (if (< (list-ref arr-rev 0) (list-ref arr-rev 1))
                                 arr-rev-len-1
                                 -1)]
          [(= arr-rev-len 3) (if (< (list-ref arr-rev 0) (list-ref arr-rev 1))
                                 arr-rev-len-1
                                 (if (< (list-ref arr-rev 1) (list-ref arr-rev 2))
                                     arr-rev-len-2
                                     -1))]
          [else (if (< (list-ref arr-rev 0) (list-ref arr-rev 1))
                   arr-rev-len-1
                   (if (< (list-ref arr-rev 1) (list-ref arr-rev 2))
                       arr-rev-len-2
                       (if (< (list-ref arr-rev 2) (list-ref arr-rev 3))
                           arr-rev-len-3
                           (let loop ([i 4])
                             (if (< (list-ref arr-rev i) (list-ref arr-rev (- i 1)))
                                 (- arr-rev-len i)
                                 (loop (+ i 1)))))))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_5d4t2y.rkt:45:4

list-ref: index too large for list
  index: 4
  in: '(5 4 2 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk_5d4t2y.rkt:46:4
actual:     5
expected:   2
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (length arr))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (- i 1)))
              (loop (+ i 1) max-index)
              (loop (+ i 1) i))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkcrfwdws.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(<= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkpemw_ks.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkpemw_ks.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkpemw_ks.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkpemw_ks.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest-negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (not (number? (second lst)))))
       (first lst)]
      [else (largest-negative (rest lst))]))
  (define (smallest-positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (not (number? (second lst)))))
       (first lst)]
      [else (smallest-positive (rest lst))]))
  (list (largest-negative lst) (smallest-positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl577ecx3.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([curr (list-ref arr i)])
          (if (<= curr (list-ref arr (sub1 i)))
              (loop (add1 i) (add1 i))
              (loop (add1 i) max-index))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl_fftyci.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl_fftyci.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl_fftyci.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl_fftyci.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl_fftyci.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond ((= i j) 0)
          ((= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j)))
          (else (min (add1 (loop (list-set arr i (list-ref arr j))) (add1 i) j))
                   (add1 (loop (list-set arr j (list-ref arr i)) i (sub1 j)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplib142v3.rkt:25:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplib142v3.rkt:26:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplib142v3.rkt:27:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplib142v3.rkt:28:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplib142v3.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplib142v3.rkt:32:4

loop: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 3
  given: 1
--------------------

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (cond
    [(empty? arr) empty]
    [(even? (first arr))
     (let ([min-even (first arr)])
       (for/fold ([min-even-index 0]
                  [min-even-value min-even])
         ([i (in-naturals)])
         (cond
           [(even? (list-ref arr i))
            (cond
              [(< min-even (list-ref arr i))
               (values min-even-index min-even)]
              [else
               (values i (list-ref arr i))])]
           [else
            (values min-even-index min-even-value)])))]
    [else
     (pluck (rest arr))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpln24n3ju.rkt:53:4

list-ref: index too large for list
  index: 3
  in: '(4 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpln24n3ju.rkt:54:4

list-ref: index too large for list
  index: 2
  in: '(2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpln24n3ju.rkt:56:4

list-ref: index too large for list
  index: 5
  in: '(0 3 0 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpln24n3ju.rkt:57:4

list-ref: index too large for list
  index: 5
  in: '(2 3 0 5 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpln24n3ju.rkt:58:4

list-ref: index too large for list
  index: 4
  in: '(4 8 4 8)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpln24n3ju.rkt:59:4

list-ref: index too large for list
  index: 3
  in: '(6 7 1)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index 0])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:28:4
actual:     0
expected:   -1
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index 0])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplt3j6zi9.rkt:28:4
actual:     0
expected:   -1
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (quotient n 2) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (- n 1)) (+ n 1))) (tri (- n 1))))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplts95m93.rkt:41:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (+ 1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (- n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:41:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplwzmlpay.rkt:42:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (define (tri-iter n)
    (if (= n 0)
        (list 1)
        (let* ([prev-tri (tri-iter (- n 1))]
               [prev-tri-len (length prev-tri)]
               [prev-tri-last (list-ref prev-tri (- prev-tri-len 1))]
               [prev-tri-second-last (list-ref prev-tri (- prev-tri-len 2))]
               [prev-tri-third-last (list-ref prev-tri (- prev-tri-len 3))])
          (append prev-tri
                  (list (+ prev-tri-last prev-tri-second-last prev-tri-third-last))))))
  (tri-iter n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:37:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:38:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:39:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:40:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:41:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:42:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:43:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:44:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm613hoir.rkt:46:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (- (length arr) 1)) (changes 0))
    (cond
      [(= i j) changes]
      [(= (list-ref arr i) (list-ref arr j)) (loop arr (+ i 1) (- j 1) changes)]
      [else (loop arr (+ i 1) (- j 1) (+ changes 1))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm8sfwtpu.rkt:25:4

list-ref: index too large for list
  index: 8
  in: '(1 2 3 5 4 7 9 6)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm8sfwtpu.rkt:28:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm8sfwtpu.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm8sfwtpu.rkt:32:4

list-ref: index too large for list
  index: 2
  in: '(0 1)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change_helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest_change_helper arr (+ left 1) (- right 1))]
      [else (+ 1 (smallest_change_helper arr (+ left 1) (- right 1)))]))
  (smallest_change_helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn398p5k7.rkt:27:4

list-ref: index too large for list
  index: 8
  in: '(1 2 3 5 4 7 9 6)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn398p5k7.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn398p5k7.rkt:32:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn398p5k7.rkt:34:4

list-ref: index too large for list
  index: 2
  in: '(0 1)
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (merge-sort l)
    (define (merge l1 l2)
      (cond
        [(empty? l1) l2]
        [(empty? l2) l1]
        [(< (first l1) (first l2)) (cons (first l1) (merge (rest l1) l2))]
        [else (cons (first l2) (merge l1 (rest l2)))]))
    (define (split l)
      (cond
        [(empty? l) (list empty empty)]
        [(empty? (rest l)) (list (list (first l)) empty)]
        [else (let ([l1 (split (rest (rest l)))]
                   [l2 (list (first l))])
                (list (merge l2 (first l1)) (second l1)))]))
    (let ([l (split l)])
      (merge (first l) (second l))))
  (define (median-of-sorted l)
    (cond
      [(empty? l) 0]
      [(empty? (rest l)) (first l)]
      [(empty? (rest (rest l))) (/ (+ (first l) (second l)) 2)]
      [else (let ([n (length l)])
              (if (odd? n)
                  (list-ref l (/ n 2))
                  (/ (+ (list-ref l (/ n 2)) (list-ref l (- (/ n 2) 1))) 2)))]))
  (median-of-sorted (merge-sort l)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngwiwj8r.rkt:41:4

list-ref: index 3/2 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngwiwj8r.rkt:42:4

list-ref: index 3/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpngwiwj8r.rkt:44:4
actual:     6
expected:   5.5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpngwiwj8r.rkt:45:4
actual:     15/2
expected:   7
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (negative? (first lst))
                (negative? (first lst))))
       (largest_negative (rest lst))]
      [else (first lst)]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (positive? (first lst))
                (positive? (first lst))))
       (smallest_positive (rest lst))]
      [else (first lst)]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:40:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:41:4
actual:     '(2 0)
expected:   '(#f 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:42:4
actual:     '(1 -2)
expected:   '(-2 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:43:4
actual:     '(4 -7)
expected:   '(-7 2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:44:4
actual:     '(7 -9)
expected:   '(-9 2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:46:4
actual:     '(0 0)
expected:   '(#f #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:47:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:48:4
actual:     '(0 -1)
expected:   '(-1 #f)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:49:4
actual:     '(1 -6)
expected:   '(-3 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpoi_yqko2.rkt:50:4
actual:     '(1 -6)
expected:   '(-3 1)
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (triples lst)
    (cond [(empty? lst) 0]
          [(= (modulo (+ (first lst) (second lst) (third lst)) 3) 0)
           (+ 1 (triples (rest lst)))]
          [else (triples (rest lst))]))
  (triples (build-list n (lambda (x) (+ (* x x) (- x 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpon0kc2i1.rkt:26:4

third: list contains too few elements
  list: '(11 19)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpon0kc2i1.rkt:27:4

third: list contains too few elements
  list: '(19 29)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpon0kc2i1.rkt:28:4

third: list contains too few elements
  list: '(71 89)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpon0kc2i1.rkt:29:4

third: list contains too few elements
  list: '(9701 9899)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) max-index)]
          [else (loop (add1 i) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp3sqsy2s.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change_helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right)) (smallest_change_helper arr (+ left 1) (- right 1))]
      [else (+ 1 (smallest_change_helper arr (+ left 1) (- right 1)) (smallest_change_helper arr left (- right 1)))]))
  (smallest_change_helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp_4i3ib8.rkt:26:4

list-ref: index too large for list
  index: 8
  in: '(1 2 3 5 4 7 9 6)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp_4i3ib8.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp_4i3ib8.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp_4i3ib8.rkt:29:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp_4i3ib8.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp_4i3ib8.rkt:33:4

list-ref: index too large for list
  index: 2
  in: '(0 1)
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (if (null? arr)
      #t
      (let* ([sorted-arr (sort arr <)]
             [sorted-arr-rev (reverse sorted-arr)]
             [sorted-arr-rev-len (length sorted-arr-rev)]
             [sorted-arr-len (length sorted-arr)])
        (if (equal? sorted-arr arr)
            #t
            (let loop ([i 0])
              (if (>= i sorted-arr-rev-len)
                  #f
                  (if (equal? (list-ref sorted-arr-rev i) (list-ref arr (+ i (- sorted-arr-len))))
                      (loop (+ i 1))
                      #t)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppmarccji.rkt:45:4

list-ref: index -5 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppmarccji.rkt:46:4

list-ref: index -5 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppmarccji.rkt:47:4

list-ref: index -4 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppmarccji.rkt:48:4

list-ref: index -5 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let ([min (apply min arr)])
       (let ([min-index (list-ref arr min)])
         (let ([max (apply max arr)])
           (let ([max-index (list-ref arr max)])
             (if (> min-index max-index)
                 #t
                 #f)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqjwg9qha.rkt:42:4

list-ref: index too large for list
  index: 5
  in: '(3 4 5 1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqjwg9qha.rkt:43:4

list-ref: index too large for list
  index: 10
  in: '(3 5 10 1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqjwg9qha.rkt:44:4

list-ref: index too large for list
  index: 4
  in: '(4 3 1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqjwg9qha.rkt:45:4

list-ref: index too large for list
  index: 5
  in: '(3 5 4 1 2)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest-neg lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (largest-neg (rest lst))]))
  (define (smallest-pos lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (empty? (rest lst))))
       (first lst)]
      [else (smallest-pos (rest lst))]))
  (list (largest-neg lst) (smallest-pos lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:39:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:46:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqmy7ip9x.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (length arr))
        max
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (loop (+ i 1) max)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqor_0pfy.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqor_0pfy.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqor_0pfy.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqor_0pfy.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (can_arrange-helper arr i)
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr (sub1 i)))
            (can_arrange-helper arr (add1 i))
            i)))
  (can_arrange-helper arr 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqxsmh_an.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqxsmh_an.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqxsmh_an.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqxsmh_an.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqxsmh_an.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval2 interval1)]
        [(> (first interval1) (second interval2)) '()]
        [(> (second interval1) (second interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) interval2))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (second interval) (first interval)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:52:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:53:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:54:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:55:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:56:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:58:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr3y5g0kg.rkt:59:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:32:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8tsh3j8.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst)) (not (negative? (second lst)))) (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst)) (not (positive? (second lst)))) (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:32:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:33:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:34:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:35:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:36:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:39:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:40:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:41:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprhfp8pai.rkt:42:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (helper n a)
    (if (= n 0)
        a
        (helper (- n 1) (cons (+ (* n n) (- n 1)) a))))
  (define (sum-triples a)
    (define (helper a i j k)
      (if (= j k)
          0
          (if (= (modulo (+ (list-ref a i) (list-ref a j) (list-ref a k)) 3) 0)
              (+ 1 (helper a i (+ j 1) (+ k 1)))
              (helper a i (+ j 1) (+ k 1)))))
    (define (helper2 a i)
      (if (= i (- (length a) 2))
          0
          (+ (helper a i (+ i 1) (+ i 2)) (helper2 a (+ i 1)))))
    (helper2 a 0))
  (sum-triples (helper n '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprwddoxgy.rkt:37:4

list-ref: index too large for list
  index: 5
  in: '(1 5 11 19 29)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprwddoxgy.rkt:38:4

list-ref: index too large for list
  index: 6
  in: '(1 5 11 19 29 41)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprwddoxgy.rkt:39:4

list-ref: index too large for list
  index: 10
  in: '(1 5 11 19 29 41 55 71 89 109)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprwddoxgy.rkt:40:4

list-ref: index too large for list
  index: 100
  in: '(1 5 11 19 29 41 55 71 89 109 131 155 181 209 239 271 305 341 379 419 461 505 551 599 649 701 755 811 869 929 991 1055 1121 1189 1259 1331 1405 1481 1559 1639 1721 1805 1891 1979 2069 2161 2255 2351 2449 2549 2651 2755 2861 2969 3079 3191 3305 3421 353...
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (define (move_one_ball-iter arr count)
    (cond
      [(empty? arr) #t]
      [(= count (length arr)) #f]
      [(> (first arr) (second arr)) (move_one_ball-iter (rest arr) (+ count 1))]
      [else (move_one_ball-iter (rest arr) 0)]))
  (move_one_ball-iter arr 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps4bu464t.rkt:38:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps4bu464t.rkt:39:4

second: list contains too few elements
  list: '(2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(>= (list-ref arr i) (list-ref arr (sub1 i)))
           (loop (add1 i) (add1 i))]
          [else (loop (add1 i) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpslmbt55z.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpslmbt55z.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpslmbt55z.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpslmbt55z.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpslmbt55z.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (let loop ((i 1) (lst (list 1 3 2)))
    (if (= i n)
        lst
        (loop (+ i 1) (append lst (list (+ (list-ref lst (- i 1))
                                           (list-ref lst (- i 2))
                                           (list-ref lst (+ i 1)))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:32:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:33:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:34:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:35:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:36:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:37:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:38:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:39:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:40:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpstx90dh4.rkt:41:4
actual:     '(1 3 2)
expected:   '(1 3)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptc7trs8a.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(>= i (length arr)) max-index]
          [(< (list-ref arr i) (list-ref arr (- i 1))) (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptx9qhhiw.rkt:23:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptx9qhhiw.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptx9qhhiw.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptx9qhhiw.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(> (first interval1) (first interval2)) (intersection-helper interval2 interval1)]
      [(> (first interval1) (second interval2)) '()]
      [(> (second interval1) (second interval2)) (intersection-helper (rest interval1) interval2)]
      [else (cons (first interval1) (intersection-helper (rest interval1) interval2))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(= n 3) #t]
      [(= n 5) #t]
      [(= n 7) #t]
      [(= n 11) #t]
      [(= n 13) #t]
      [(= n 17) #t]
      [(= n 19) #t]
      [(= n 23) #t]
      [(= n 29) #t]
      [(= n 31) #t]
      [(= n 37) #t]
      [(= n 41) #t]
      [(= n 43) #t]
      [(= n 47) #t]
      [(= n 53) #t]
      [(= n 59) #t]
      [(= n 61) #t]
      [(= n 67) #t]
      [(= n 71) #t]
      [(= n 73) #t]
      [(= n 79) #t]
      [(= n 83) #t]
      [(= n 89) #t]
      [(= n 97) #t]
      [else #f]))
  (define (length-intersection interval1 interval2)
    (length (intersection-helper interval1 interval2)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length-intersection interval1 interval2)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:72:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:73:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:74:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:75:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:76:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:77:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:78:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9shp3xt.rkt:79:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index 0])
    (cond [(= i (length arr)) max-index]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max-index)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu_z9mgv9.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu_z9mgv9.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu_z9mgv9.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu_z9mgv9.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpu_z9mgv9.rkt:28:4
actual:     0
expected:   -1
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (cond [(>= i (length arr)) max]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (cond [(>= i (length arr)) max]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (cond [(>= i (length arr)) max]
          [(>= (list-ref arr i) (list-ref arr (- i 1)))
           (loop (+ i 1) max)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:24:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:25:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:26:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpune0ibf4.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (cond
    [(= n 0) (list 1)]
    [(= n 1) (list 1 3)]
    [(= n 2) (list 1 3 2)]
    [else (append (tri (- n 1)) (list (+ (list-ref (tri (- n 1)) (- n 1))
                                          (list-ref (tri (- n 1)) (- n 2))
                                          (list-ref (tri (- n 1)) (+ n 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:34:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:35:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:36:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:38:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:39:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuugzih_r.rkt:40:4

list-ref: index too large for list
  index: 4
  in: '(1 3 2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max -1])
    (if (= i (length arr))
        max
        (let ([prev (list-ref arr (- i 1))]
              [curr (list-ref arr i)])
          (if (<= curr prev)
              (loop (+ i 1) i)
              (loop (+ i 1) max))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuznpsjq6.rkt:27:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuznpsjq6.rkt:28:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuznpsjq6.rkt:29:4

list-ref: index -1 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuznpsjq6.rkt:30:4

list-ref: index -1 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (if (empty? s)
        empty
        (cons (list-ref s n) (rotate n (rest s)))))
  (define (encrypt-helper s)
    (if (empty? s)
        empty
        (cons (rotate (modulo (char->integer (first s)) 97)
                      (string->list "abcdefghijklmnopqrstuvwxyz"))
              (encrypt-helper (rest s)))))
  (list->string (encrypt-helper (string->list s))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:34:4

list-ref: index too large for list
  index: 7
  in: '(#\t #\u #\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:35:4

list-ref: index too large for list
  index: 18
  in: '(#\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:36:4

list-ref: index too large for list
  index: 6
  in: '(#\u #\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:37:4

list-ref: index too large for list
  index: 4
  in: '(#\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:38:4

list-ref: index too large for list
  index: 5
  in: '(#\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:39:4

list-ref: index too large for list
  index: 7
  in: '(#\t #\u #\v #\w #\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:40:4

list-ref: index too large for list
  index: 3
  in: '(#\x #\y #\z)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx70yw6kl.rkt:41:4

list->string: contract violation
  expected: char?
  given: '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_neg lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst)) (or (not (negative? (second lst))) (empty? (rest lst)))) (first lst)]
      [else (largest_neg (rest lst))]))
  (define (smallest_pos lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst)) (or (not (positive? (second lst))) (empty? (rest lst)))) (first lst)]
      [else (smallest_pos (rest lst))]))
  (list (largest_neg lst) (smallest_pos lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:32:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:33:4
actual:     '(#f 7)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:34:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:35:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:36:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:39:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:40:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:41:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7ntzf34.rkt:42:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(> (first interval1) (first interval2)) (intersection-helper interval2 interval1)]
      [(> (first interval1) (second interval2)) '()]
      [(> (second interval1) (second interval2)) (intersection-helper (rest interval1) interval2)]
      [else (cons (first interval1) (intersection-helper (rest interval1) interval2))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(even? n) #f]
      [else (is-prime?-helper n 3)]))
  (define (is-prime?-helper n i)
    (cond
      [(= i n) #t]
      [(= (modulo n i) 0) #f]
      [else (is-prime?-helper n (+ i 2))]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:52:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:53:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:54:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:55:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:56:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:58:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxhorqjam.rkt:59:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sorted-list l)
    (sort l <))
  (define (middle-element l)
    (list-ref l (/ (length l) 2)))
  (define (middle-two-elements l)
    (define (first-middle-element l)
      (list-ref l (/ (length l) 2)))
    (define (second-middle-element l)
      (list-ref l (+ (/ (length l) 2) 1)))
    (list (first-middle-element l) (second-middle-element l)))
  (define (average-of-two-elements l)
    (/ (+ (first l) (second l)) 2))
  (if (even? (length l))
      (average-of-two-elements (middle-two-elements (sorted-list l)))
      (middle-element (sorted-list l))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxmpe52l4.rkt:30:4

list-ref: index 5/2 is not an exact nonnegative integer
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxmpe52l4.rkt:31:4
actual:     15
expected:   8.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxmpe52l4.rkt:32:4

list-ref: index 1/2 is not an exact nonnegative integer
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxmpe52l4.rkt:33:4

list-ref: index too large for list
  index: 2
  in: '(5 6)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxmpe52l4.rkt:34:4

list-ref: index 7/2 is not an exact nonnegative integer
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (negative? (second lst))))
       (largest_negative (rest lst))]
      [else (first lst)]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (positive? (second lst))))
       (smallest_positive (rest lst))]
      [else (first lst)]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:38:4

second: list contains too few elements
  list: '(7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:39:4
actual:     '(2 0)
expected:   '(#f 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:40:4
actual:     '(1 -2)
expected:   '(-2 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:41:4
actual:     '(4 -7)
expected:   '(-7 2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:42:4
actual:     '(7 -9)
expected:   '(-9 2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:44:4
actual:     '(0 0)
expected:   '(#f #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:45:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:46:4
actual:     '(0 -1)
expected:   '(-1 #f)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:47:4
actual:     '(1 -6)
expected:   '(-3 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxo8eftk9.rkt:48:4
actual:     '(1 -6)
expected:   '(-3 1)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(> (first interval1) (first interval2)) (intersection-helper interval2 interval1)]
      [(> (first interval1) (second interval2)) '()]
      [(> (second interval1) (second interval2)) (intersection-helper (rest interval1) interval2)]
      [else (cons (first interval1) (intersection-helper (rest interval1) interval2))]))
  (define (is-prime? n)
    (define (is-prime-helper n d)
      (cond
        [(= d 1) #t]
        [(= (modulo n d) 0) #f]
        [else (is-prime-helper n (- d 1))]))
    (is-prime-helper n (- n 1)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:48:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:49:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:50:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:51:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:52:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:53:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:54:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxop2fmid.rkt:55:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (define (has_close_elements_iter numbers threshold)
    (cond
      [(empty? numbers) #f]
      [(< (abs (- (first numbers) (second numbers))) threshold) #t]
      [else (has_close_elements_iter (rest numbers) threshold)]))
  (has_close_elements_iter numbers threshold))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy388w4p4.rkt:23:4

second: list contains too few elements
  list: '(2.2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy388w4p4.rkt:24:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy388w4p4.rkt:25:4

second: list contains too few elements
  list: '(5.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy388w4p4.rkt:26:4

second: list contains too few elements
  list: '(2.0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy388w4p4.rkt:28:4

second: list contains too few elements
  list: '(5.1)
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (sum-triple lst)
    (cond [(empty? lst) 0]
          [(= (modulo (+ (first lst) (second lst) (third lst)) 3) 0)
           (+ 1 (sum-triple (rest lst)))]
          [else (sum-triple (rest lst))]))
  (sum-triple (build-list n (lambda (x) (+ (* x x) (- x 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpya7o121m.rkt:26:4

third: list contains too few elements
  list: '(11 19)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpya7o121m.rkt:27:4

third: list contains too few elements
  list: '(19 29)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpya7o121m.rkt:28:4

third: list contains too few elements
  list: '(71 89)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpya7o121m.rkt:29:4

third: list contains too few elements
  list: '(9701 9899)
--------------------

==========================
------- Program HumanEval_129_minPath --------
#lang racket

;; Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
;; each cell of the grid contains a value. Every integer in the range [1, N * N]
;; inclusive appears exactly once on the cells of the grid.
;; You have to find the minimum path of length k in the grid. You can start
;; from any cell, and in each step you can move to any of the neighbor cells,
;; in other words, you can go to cells which share an edge with you current
;; cell.
;; Please note that a path of length k means visiting exactly k cells (not
;; necessarily distinct).
;; You CANNOT go off the grid.
;; A path A (of length k) is considered less than a path B (of length k) if
;; after making the ordered lists of the values on the cells that A and B go
;; through (let's call them lst_A and lst_B), lst_A is lexicographically less
;; than lst_B, in other words, there exist an integer index i (1 <= i <= k)
;; such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
;; lst_A[j] = lst_B[j].
;; It is guaranteed that the answer is unique.
;; Return an ordered list of the values on the cells that the minimum path go through.
;; Examples:    
;; >>> (minPath (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3)
;; (list 1 2 1)
;; >>> (minPath (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1)
;; (list 1)
(define (minPath grid k)
  (define (minPath-helper grid k)
    (define (minPath-helper-helper grid k row col)
      (cond
        [(= k 0) (list (list-ref (list-ref grid row) col))]
        [(= row 0) (minPath-helper-helper grid (- k 1) row (+ col 1))]
        [(= col 0) (minPath-helper-helper grid (- k 1) (+ row 1) col)]
        [else
         (let*
             ([left (minPath-helper-helper grid (- k 1) row (+ col 1))]
              [right (minPath-helper-helper grid (- k 1) (+ row 1) col)]
              [down (minPath-helper-helper grid (- k 1) (+ row 1) (+ col 1))])
           (cond
             [(< (list-ref (list-ref grid row) col) (list-ref (list-ref grid row) col)) left]
             [(< (list-ref (list-ref grid row) col) (list-ref (list-ref grid row) col)) right]
             [else down]))]))
    (minPath-helper-helper grid k 0 0))
  (minPath-helper grid k))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minPath))
    (check-equal? (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1))
    (check-equal? (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1))
    (check-equal? (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2))
    (check-equal? (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1))
    (check-equal? (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1))
    (check-equal? (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1))
    (check-equal? (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6))
    (check-equal? (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3))
    (check-equal? (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5))
    (check-equal? (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2))
    (check-equal? (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:50:4

list-ref: index too large for list
  index: 3
  in: '(1 2 3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:51:4
actual:     '(9)
expected:   '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:52:4

list-ref: index too large for list
  index: 4
  in: '(1 2 3 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:53:4

list-ref: index too large for list
  index: 7
  in: '(6 4 13 10)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:54:4

list-ref: index too large for list
  index: 5
  in: '(8 14 9 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:55:4

list-ref: index too large for list
  index: 9
  in: '(11 8 7 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:56:4

list-ref: index too large for list
  index: 12
  in: '(12 13 10 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:57:4

list-ref: index too large for list
  index: 8
  in: '(2 7 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:58:4

list-ref: index too large for list
  index: 8
  in: '(6 1 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:59:4

list-ref: index too large for list
  index: 10
  in: '(1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymhyxjbt.rkt:60:4

list-ref: index too large for list
  index: 10
  in: '(1 3)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(> (first interval1) (first interval2)) (intersection-helper interval2 interval1)]
      [(> (first interval1) (second interval2)) '()]
      [(> (second interval1) (second interval2)) (intersection-helper (rest interval1) interval2)]
      [else (cons (first interval1) (intersection-helper (rest interval1) interval2))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(even? n) #f]
      [else (let loop ([i 3])
               (cond
                 [(= i n) #t]
                 [(= (modulo n i) 0) #f]
                 [else (loop (+ i 2))]))]))
  (define (length-interval interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (length-interval (rest interval)))]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length-interval (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:55:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:56:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:57:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:58:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:59:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:60:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:61:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyp_ksu68.rkt:62:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (sum-triple a b c)
    (+ a b c))
  (define (is-multiple-of-3? n)
    (= (modulo n 3) 0))
  (define (is-valid-triple? a b c)
    (is-multiple-of-3? (sum-triple a b c)))
  (define (get-triples lst)
    (for/fold ([acc 0]) ([i (in-range (add1 (length lst)))])
      (for/fold ([acc acc]) ([j (in-range (add1 i))])
        (for/fold ([acc acc]) ([k (in-range (add1 j))])
          (if (is-valid-triple? (list-ref lst i) (list-ref lst j) (list-ref lst k))
              (add1 acc)
              acc)))))
  (get-triples (build-list n (λ (i) (+ (* i i) (- i 1)))))
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzinlyjdq.rkt:35:4

list-ref: index too large for list
  index: 5
  in: '(-1 1 5 11 19)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzinlyjdq.rkt:36:4

list-ref: index too large for list
  index: 6
  in: '(-1 1 5 11 19 29)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzinlyjdq.rkt:37:4

list-ref: index too large for list
  index: 10
  in: '(-1 1 5 11 19 29 41 55 71 89)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzinlyjdq.rkt:38:4

list-ref: index too large for list
  index: 100
  in: '(-1 1 5 11 19 29 41 55 71 89 109 131 155 181 209 239 271 305 341 379 419 461 505 551 599 649 701 755 811 869 929 991 1055 1121 1189 1259 1331 1405 1481 1559 1639 1721 1805 1891 1979 2069 2161 2255 2351 2449 2549 2651 2755 2861 2969 3079 3191 3305 3421 ...
--------------------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (define (tri-iter n acc)
    (cond
      [(= n 0) (reverse acc)]
      [(= n 1) (reverse (cons 3 acc))]
      [(= n 2) (reverse (cons 2 (cons 3 acc)))]
      [(even? n) (tri-iter (- n 1) (cons (+ 1 (/ n 2)) acc))]
      [else (tri-iter (- n 1) (cons (+ (list-ref acc 0) (list-ref acc 1) (list-ref acc 2)) acc))]))
  (tri-iter n (list)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:34:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:35:4

list-ref: index too large for list
  index: 1
  in: '(3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:36:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:37:4

list-ref: index too large for list
  index: 1
  in: '(4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:38:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:39:4

list-ref: index too large for list
  index: 1
  in: '(5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:40:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:41:4

list-ref: index too large for list
  index: 1
  in: '(11)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:42:4
actual:     '()
expected:   '(1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1lhoc8.rkt:43:4
actual:     '(3)
expected:   '(1 3)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond ((= i j) 0)
          ((= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j)))
          (else (add1 (min (loop (list-set arr i (list-ref arr j)) (add1 i) j)
                           (loop (list-set arr j (list-ref arr i)) i (sub1 j))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0ib_uoba.rkt:25:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0ib_uoba.rkt:26:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0ib_uoba.rkt:27:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ib_uoba.rkt:28:4

list-ref: index too large for list
  index: 4
  in: '(2 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ib_uoba.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_40_triples_sum_to_zero --------
#lang racket

;; triples_sum_to_zero takes a list of integers as an input.
;; it returns #t if there are three distinct elements in the list that
;; sum to zero, and #f otherwise.
;; >>> (triples_sum_to_zero (list 1 3 5 0))
;; #f
;; >>> (triples_sum_to_zero (list 1 3 -2 1))
;; #t
;; >>> (triples_sum_to_zero (list 1 2 3 7))
;; #f
;; >>> (triples_sum_to_zero (list 2 4 -5 3 9 7))
;; #t
;; >>> (triples_sum_to_zero (list 1))
;; #f
(define (triples_sum_to_zero l)
  (cond
    [(empty? l) #f]
    [(and (member (list-ref l 0) l)
          (member (list-ref l 1) l)
          (member (list-ref l 2) l))
     #t]
    [else (triples_sum_to_zero (rest l))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate triples_sum_to_zero))
    (check-equal? (candidate (list 1 3 5 0)) #f)
    (check-equal? (candidate (list 1 3 5 -1)) #f)
    (check-equal? (candidate (list 1 3 -2 1)) #t)
    (check-equal? (candidate (list 1 2 3 7)) #f)
    (check-equal? (candidate (list 1 2 5 7)) #f)
    (check-equal? (candidate (list 2 4 -5 3 9 7)) #t)
    (check-equal? (candidate (list 1)) #f)
    (check-equal? (candidate (list 1 3 5 -100)) #f)
    (check-equal? (candidate (list 100 3 5 -100)) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:30:4
actual:     #t
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:31:4
actual:     #t
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:33:4
actual:     #t
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:34:4
actual:     #t
expected:   #f
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:36:4

list-ref: index too large for list
  index: 1
  in: '(1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:37:4
actual:     #t
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0jb9fkbt.rkt:38:4
actual:     #t
expected:   #f
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [prev (list-ref arr 0)])
    (cond [(= i (length arr)) -1]
          [(>= (list-ref arr i) prev) (loop (+ i 1) (list-ref arr i))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp197d1rsu.rkt:26:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp197d1rsu.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (define (sum-odd-even-positions lst)
    (cond
      [(empty? lst) 0]
      [(even? (second lst)) (+ (first lst) (sum-odd-even-positions (rest (rest lst))))]
      [else (sum-odd-even-positions (rest (rest lst)))]))
  (sum-odd-even-positions lst))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1p08ovgu.rkt:24:4
actual:     5
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1p08ovgu.rkt:25:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1p08ovgu.rkt:27:4
actual:     0
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1p08ovgu.rkt:28:4

second: list contains too few elements
  list: '(8)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1p08ovgu.rkt:30:4
actual:     0
expected:   3
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change-helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest_change-helper arr (+ left 1) (- right 1))]
      [else (+ 1 (min (smallest_change-helper arr (+ left 1) right)
                      (smallest_change-helper arr left (- right 1))))]))
  (smallest_change-helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp22ej4cx5.rkt:28:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp22ej4cx5.rkt:29:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp22ej4cx5.rkt:30:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp22ej4cx5.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp22ej4cx5.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (can-arrange-helper arr i)
    (if (= i (length arr))
        -1
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (can-arrange-helper arr (+ i 1))
            i)))
  (can-arrange-helper arr 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp27fn4v1g.rkt:26:4
actual:     1
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp27fn4v1g.rkt:27:4
actual:     1
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp27fn4v1g.rkt:28:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp27fn4v1g.rkt:29:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27fn4v1g.rkt:30:4

list-ref: index too large for list
  index: 1
  in: '()
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest-negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (and (negative? (second lst))
                     (< (first lst) (second lst)))))
       (first lst)]
      [else (largest-negative (rest lst))]))
  (define (smallest-positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (and (positive? (second lst))
                     (> (first lst) (second lst)))))
       (first lst)]
      [else (smallest-positive (rest lst))]))
  (list (largest-negative lst) (smallest-positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:40:4
actual:     '(#f 4)
expected:   '(#f 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:41:4
actual:     '(#f 4)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:42:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:43:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:44:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:47:4

second: list contains too few elements
  list: '(-6)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:48:4
actual:     '(-6 #f)
expected:   '(-1 #f)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:49:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2laz00ld.rkt:50:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(and (>= (first interval1) (first interval2))
            (<= (first interval1) (second interval2)))
       (cons (first interval1) (intersection-helper (rest interval1) interval2))]
      [(and (>= (first interval2) (first interval1))
            (<= (first interval2) (second interval1)))
       (cons (first interval2) (intersection-helper interval1 (rest interval2)))]
      [else (intersection-helper (rest interval1) (rest interval2))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(even? n) #f]
      [else
       (define (is-prime-helper n i)
         (cond
           [(= i n) #t]
           [(= (modulo n i) 0) #f]
           [else (is-prime-helper n (+ i 1))]))
       (is-prime-helper n 3)]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp389zw0q3.rkt:59:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp389zw0q3.rkt:60:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp389zw0q3.rkt:61:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp389zw0q3.rkt:62:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp389zw0q3.rkt:63:4
actual:     "YES"
expected:   "NO"
--------------------

==========================
------- Program HumanEval_70_strange_sort_list --------
#lang racket

;; Given list of integers, return list in strange order.
;; Strange sorting, is when you start with the minimum value,
;; then maximum of the remaining integers, then minimum and so on.
;; Examples:
;; >>> (strange_sort_list (list 1 2 3 4))
;; (list 1 4 2 3)
;; >>> (strange_sort_list (list 5 5 5 5))
;; (list 5 5 5 5)
;; >>> (strange_sort_list (list ))
;; (list )
(define (strange_sort_list lst)
  (cond
    [(empty? lst) empty]
    [else
     (let ([min (min (first lst) (second lst))]
           [max (max (first lst) (second lst))])
       (cons min (cons max (strange_sort_list (rest (rest lst))))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate strange_sort_list))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 4 2 3))
    (check-equal? (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7))
    (check-equal? (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3))
    (check-equal? (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7))
    (check-equal? (candidate (list 5 5 5 5)) (list 5 5 5 5))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5))
    (check-equal? (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2))
    (check-equal? (candidate (list 111111)) (list 111111))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:26:4
actual:     '(1 2 3 4)
expected:   '(1 4 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:27:4

second: list contains too few elements
  list: '(9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:28:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:29:4
actual:     '(5 6 7 8 1 9)
expected:   '(1 9 5 8 6 7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:32:4
actual:     '(1 2 3 4 5 6 7 8)
expected:   '(1 8 2 7 3 6 4 5)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:33:4
actual:     '(0 2 2 2 5 5 -5 -5)
expected:   '(-5 5 -5 5 0 2 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l7cgqqy.rkt:34:4

second: list contains too few elements
  list: '(111111)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (negative? (first lst))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (positive? (first lst))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:38:4
actual:     '(#f 2)
expected:   '(#f 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:39:4
actual:     '(#f 2)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:40:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:41:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:42:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:47:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3pf87845.rkt:48:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_70_strange_sort_list --------
#lang racket

;; Given list of integers, return list in strange order.
;; Strange sorting, is when you start with the minimum value,
;; then maximum of the remaining integers, then minimum and so on.
;; Examples:
;; >>> (strange_sort_list (list 1 2 3 4))
;; (list 1 4 2 3)
;; >>> (strange_sort_list (list 5 5 5 5))
;; (list 5 5 5 5)
;; >>> (strange_sort_list (list ))
;; (list )
(define (strange_sort_list lst)
  (cond
    [(empty? lst) empty]
    [else
     (let* ([min (min (first lst) (second lst))]
            [max (max (first lst) (second lst))]
            [rest (rest (rest lst))])
       (append (list min max) (strange_sort_list rest)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate strange_sort_list))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 4 2 3))
    (check-equal? (candidate (list 5 6 7 8 9)) (list 5 9 6 8 7))
    (check-equal? (candidate (list 1 2 3 4 5)) (list 1 5 2 4 3))
    (check-equal? (candidate (list 5 6 7 8 9 1)) (list 1 9 5 8 6 7))
    (check-equal? (candidate (list 5 5 5 5)) (list 5 5 5 5))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4 5 6 7 8)) (list 1 8 2 7 3 6 4 5))
    (check-equal? (candidate (list 0 2 2 2 5 5 -5 -5)) (list -5 5 -5 5 0 2 2 2))
    (check-equal? (candidate (list 111111)) (list 111111))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:27:4
actual:     '(1 2 3 4)
expected:   '(1 4 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:28:4

second: list contains too few elements
  list: '(9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:29:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:30:4
actual:     '(5 6 7 8 1 9)
expected:   '(1 9 5 8 6 7)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:33:4
actual:     '(1 2 3 4 5 6 7 8)
expected:   '(1 8 2 7 3 6 4 5)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:34:4
actual:     '(0 2 2 2 5 5 -5 -5)
expected:   '(-5 5 -5 5 0 2 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5darqq9w.rkt:35:4

second: list contains too few elements
  list: '(111111)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (- (length arr) 1))
        -1
        (if (or (= i (- (length arr) 2))
                (<= (list-ref arr i) (list-ref arr j)))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5l6gpk5q.rkt:26:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5l6gpk5q.rkt:28:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5l6gpk5q.rkt:29:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5l6gpk5q.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_93_encode --------
#lang racket

;; Write a function that takes a message, and encodes in such a 
;; way that it swaps case of all letters, replaces all vowels in 
;; the message with the letter that appears 2 places ahead of that 
;; vowel in the english alphabet. 
;; Assume only letters. 
;; Examples:
;; >>> (encode "test")
;; "TGST"
;; >>> (encode "This is a message")
;; "tHKS KS C MGSSCGG"
(define (encode message)
  (define (swap-case c)
    (if (char-lower-case? c)
        (char-upcase c)
        (char-downcase c)))
  (define (encode-char c)
    (if (char-alphabetic? c)
        (swap-case c)
        c))
  (define (encode-vowel c)
    (if (member c '(#\a #\e #\i #\o #\u))
        (list-ref '(#\c #\d #\f #\g #\h) (- (char->integer c) 97))
        c))
  (define (encode-letter c)
    (encode-vowel (encode-char c)))
  (define (encode-message message)
    (if (empty? message)
        empty
        (cons (encode-letter (first message))
              (encode-message (rest message)))))
  (list->string (encode-message (string->list message))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encode))
    (check-equal? (candidate "TEST") "tgst")
    (check-equal? (candidate "Mudasir") "mWDCSKR")
    (check-equal? (candidate "YES") "ygs")
    (check-equal? (candidate "This is a message") "tHKS KS C MGSSCGG")
    (check-equal? (candidate "I DoNt KnOw WhAt tO WrItE") "k dQnT kNqW wHcT Tq wRkTg")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8du3feb4.rkt:40:4
actual:     "thst"
expected:   "tgst"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8du3feb4.rkt:41:4
actual:     "mUDASIR"
expected:   "mWDCSKR"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8du3feb4.rkt:42:4
actual:     "yhs"
expected:   "ygs"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8du3feb4.rkt:43:4
actual:     "tHIS IS A MESSAGE"
expected:   "tHKS KS C MGSSCGG"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8du3feb4.rkt:44:4

list-ref: index too large for list
  index: 8
  in: '(#\c #\d #\f #\g #\h)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let ((len (length arr)))
    (let loop ((i 0) (j 1))
      (cond ((= i (- len 1)) -1)
            ((>= (list-ref arr i) (list-ref arr j))
             (loop (+ i 1) (+ j 1)))
            (else i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8sht936i.rkt:25:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8sht936i.rkt:26:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8sht936i.rkt:27:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8sht936i.rkt:28:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8sht936i.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond [(empty? lst) 0]
        [(even? (second lst)) (+ (first lst) (solution (rest (rest lst))))]
        [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp967c6j79.rkt:21:4
actual:     5
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp967c6j79.rkt:22:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp967c6j79.rkt:24:4
actual:     0
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp967c6j79.rkt:25:4

second: list contains too few elements
  list: '(8)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp967c6j79.rkt:27:4
actual:     0
expected:   3
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([current-index (add1 i)])
          (if (< (list-ref arr current-index) (list-ref arr i))
              (loop current-index i)
              (loop current-index max-index))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_02t_m8c.rkt:26:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_02t_m8c.rkt:28:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_02t_m8c.rkt:29:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_02t_m8c.rkt:30:4

list-ref: index too large for list
  index: 1
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(< (list-ref arr i) (list-ref arr (add1 i))) (loop (add1 i) i)]
          [else (loop (add1 i) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:24:4
actual:     2
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:25:4
actual:     7
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:26:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(< (list-ref arr i) (list-ref arr (add1 i))) (loop (add1 i) i)]
          [else (loop (add1 i) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:24:4
actual:     2
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:25:4
actual:     7
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:26:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(< (list-ref arr i) (list-ref arr (add1 i))) (loop (add1 i) i)]
          [else (loop (add1 i) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:24:4
actual:     2
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:25:4
actual:     7
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:26:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_urqb3qa.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [n (length arr)])
    (cond [(= i (- n 1)) -1]
          [(>= (list-ref arr i) (list-ref arr (+ i 1)))
           (loop (+ i 1) n)]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpajjy5v3m.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpajjy5v3m.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpajjy5v3m.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpajjy5v3m.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajjy5v3m.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond
      [(= i j) 0]
      [(= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j))]
      [else (add1 (min (loop (list-set arr i (list-ref arr j)) (add1 i) j)
                       (loop (list-set arr j (list-ref arr i)) i (sub1 j))))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:26:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:27:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:28:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:29:4

list-ref: index too large for list
  index: 4
  in: '(2 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond
      [(= i j) 0]
      [(= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j))]
      [else (add1 (min (loop (list-set arr i (list-ref arr j)) (add1 i) j)
                       (loop (list-set arr j (list-ref arr i)) i (sub1 j))))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:26:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:27:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:28:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:29:4

list-ref: index too large for list
  index: 4
  in: '(2 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbzggzoxq.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_124_valid_date --------
#lang racket

;; You have to write a function which validates a given date string and
;; returns #t if the date is valid otherwise #f.
;; The date is valid if all of the following rules are satisfied:
;; 1. The date string is not empty.
;; 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
;; 3. The months should not be less than 1 or higher than 12.
;; 4. The date should be in the format: mm-dd-yyyy
;; >>> (valid_date "03-11-2000")
;; #t
;; >>> (valid_date "15-01-2012")
;; #f
;; >>> (valid_date "04-0-2040")
;; #f
;; >>> (valid_date "06-04-2020")
;; #t
;; >>> (valid_date "06/04/2020")
;; #f
(define (valid_date date)
  (let* ([date-parts (string-split date "-")]
         [month (string->number (list-ref date-parts 0))]
         [day (string->number (list-ref date-parts 1))]
         [year (string->number (list-ref date-parts 2))])
    (and (not (empty? date))
         (and (or (and (= month 1) (= day 31))
                  (and (= month 3) (= day 31))
                  (and (= month 5) (= day 31))
                  (and (= month 7) (= day 31))
                  (and (= month 8) (= day 31))
                  (and (= month 10) (= day 31))
                  (and (= month 12) (= day 31))
                  (and (= month 4) (= day 30))
                  (and (= month 6) (= day 30))
                  (and (= month 9) (= day 30))
                  (and (= month 11) (= day 30))
                  (and (= month 2) (= day 29)))
              (and (>= month 1) (<= month 12))
              (and (>= day 1) (<= day 31))
              (and (>= year 1) (<= year 9999))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate valid_date))
    (check-equal? (candidate "03-11-2000") #t)
    (check-equal? (candidate "15-01-2012") #f)
    (check-equal? (candidate "04-0-2040") #f)
    (check-equal? (candidate "06-04-2020") #t)
    (check-equal? (candidate "01-01-2007") #t)
    (check-equal? (candidate "03-32-2011") #f)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "04-31-3000") #f)
    (check-equal? (candidate "06-06-2005") #t)
    (check-equal? (candidate "21-31-2000") #f)
    (check-equal? (candidate "04-12-2003") #t)
    (check-equal? (candidate "04122003") #f)
    (check-equal? (candidate "20030412") #f)
    (check-equal? (candidate "2003-04") #f)
    (check-equal? (candidate "2003-04-12") #f)
    (check-equal? (candidate "04-2003") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:47:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:50:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:51:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:53:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:55:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:57:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:58:4

list-ref: index too large for list
  index: 1
  in: '("04122003")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:59:4

list-ref: index too large for list
  index: 1
  in: '("20030412")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:60:4

list-ref: index too large for list
  index: 2
  in: '("2003" "04")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2wpv8he.rkt:62:4

list-ref: index too large for list
  index: 2
  in: '("04" "2003")
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [arr arr])
    (if (empty? arr)
        -1
        (if (<= (first arr) (second arr))
            (loop (+ i 1) (rest arr))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcvyginey.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvyginey.rkt:26:4

second: list contains too few elements
  list: '(5)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcvyginey.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcvyginey.rkt:28:4
actual:     1
expected:   4
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (second lst)) (+ (first lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:22:4
actual:     5
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:23:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:25:4
actual:     0
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:26:4

second: list contains too few elements
  list: '(8)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:28:4
actual:     0
expected:   3
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (second lst)) (+ (first lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:22:4
actual:     5
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:23:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:25:4
actual:     0
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:26:4

second: list contains too few elements
  list: '(8)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:28:4
actual:     0
expected:   3
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (second lst)) (+ (first lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:22:4
actual:     5
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:23:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:25:4
actual:     0
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:26:4

second: list contains too few elements
  list: '(8)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpda9iaiut.rkt:28:4
actual:     0
expected:   3
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (sub1 (length arr))) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdzghw2oq.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdzghw2oq.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdzghw2oq.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdzghw2oq.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdzghw2oq.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest-change-helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest-change-helper arr (+ left 1) (- right 1))]
      [else (+ 1 (min (smallest-change-helper arr (+ left 1) right)
                      (smallest-change-helper arr left (- right 1))))]))
  (smallest-change-helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped5ahnbz.rkt:28:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped5ahnbz.rkt:29:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped5ahnbz.rkt:30:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmped5ahnbz.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmped5ahnbz.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeupcm1dy.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond [(= i (- (length arr) 1)) -1]
          [(>= (list-ref arr i) (list-ref arr j))
           (loop (+ i 1) (+ j 1))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf4wbodae.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf4wbodae.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf4wbodae.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf4wbodae.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf4wbodae.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond [(= i (sub1 (length arr))) -1]
          [(<= (list-ref arr i) (list-ref arr j)) (loop j (add1 j))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgntv3cy6.rkt:23:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgntv3cy6.rkt:25:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgntv3cy6.rkt:26:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgntv3cy6.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (cond
    [(empty? arr) (list)]
    [(even? (first arr)) (list (first arr) 0)]
    [else (let* ([plucked (pluck (rest arr))]
                 [index (second plucked)])
             (if (empty? plucked)
                 (list (first arr) 0)
                 (if (even? (first arr))
                     (if (< (first arr) (first plucked))
                         (list (first arr) 0)
                         (list (first plucked) (+ index 1)))
                     (list (first plucked) (+ index 1)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgz51ju8v.rkt:47:4
actual:     '(4 0)
expected:   '(2 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgz51ju8v.rkt:51:4
actual:     '(2 1)
expected:   '(0 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgz51ju8v.rkt:54:4

second: list contains too few elements
  list: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (- (length arr) 1)) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (- (length arr) 1)) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (- (length arr) 1)) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (- (length arr) 1)) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (- (length arr) 1)) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (- (length arr) 1)) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvsi0rrf.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (can-arrange-helper arr i)
    (cond
      [(= i (sub1 (length arr))) -1]
      [(>= (list-ref arr i) (list-ref arr (sub1 i))) (can-arrange-helper arr (add1 i))]
      [else i]))
  (can-arrange-helper arr 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpj4n1sw2d.rkt:28:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj4n1sw2d.rkt:29:4

list-ref: index too large for list
  index: 1
  in: '()
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change_helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right)) (smallest_change_helper arr (+ left 1) (- right 1))]
      [else (+ 1 (min (smallest_change_helper arr (+ left 1) right)
                      (smallest_change_helper arr left (- right 1))))]))
  (smallest_change_helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjo84pbyw.rkt:27:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjo84pbyw.rkt:28:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjo84pbyw.rkt:29:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjo84pbyw.rkt:30:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjo84pbyw.rkt:32:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(and (>= (first interval1) (first interval2))
            (<= (first interval1) (second interval2)))
       (cons (first interval1) (intersection-helper (rest interval1) interval2))]
      [(and (>= (first interval2) (first interval1))
            (<= (first interval2) (second interval1)))
       (cons (first interval2) (intersection-helper interval1 (rest interval2)))]
      [else (intersection-helper (rest interval1) (rest interval2))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(= (remainder n 2) 0) #f]
      [else
       (define (is-prime-helper n i)
         (cond
           [(= i n) #t]
           [(= (remainder n i) 0) #f]
           [else (is-prime-helper n (+ i 1))]))
       (is-prime-helper n 3)]))
  (define (length lst)
    (cond
      [(empty? lst) 0]
      [else (+ 1 (length (rest lst)))]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkuqc4awb.rkt:63:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkuqc4awb.rkt:64:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkuqc4awb.rkt:65:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkuqc4awb.rkt:66:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkuqc4awb.rkt:67:4
actual:     "YES"
expected:   "NO"
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change_helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest_change_helper arr (+ left 1) (- right 1))]
      [else (+ 1 (min (smallest_change_helper arr (+ left 1) right)
                      (smallest_change_helper arr left (- right 1))))]))
  (smallest_change_helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:28:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:29:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:30:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change_helper arr left right)
    (cond
      [(= left right) 0]
      [(= (list-ref arr left) (list-ref arr right))
       (smallest_change_helper arr (+ left 1) (- right 1))]
      [else (+ 1 (min (smallest_change_helper arr (+ left 1) right)
                      (smallest_change_helper arr left (- right 1))))]))
  (smallest_change_helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:28:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:29:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:30:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplf835s3b.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond ((or (negative? i) (negative? j)) 0)
          ((= i j) 0)
          ((= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j)))
          (else (add1 (min (loop arr (add1 i) j) (loop arr i (sub1 j))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm2cpidbc.rkt:25:4
actual:     7
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm2cpidbc.rkt:26:4
actual:     2
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm2cpidbc.rkt:27:4
actual:     2
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm2cpidbc.rkt:28:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (define (smallest_change-helper arr left right)
    (if (= left right)
        0
        (if (= (list-ref arr left) (list-ref arr right))
            (smallest_change-helper arr (+ left 1) (- right 1))
            (+ (smallest_change-helper arr (+ left 1) right)
               (smallest_change-helper arr left (- right 1))))))
  (smallest_change-helper arr 0 (- (length arr) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm78sspq4.rkt:28:4
actual:     0
expected:   4
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm78sspq4.rkt:29:4
actual:     0
expected:   1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm78sspq4.rkt:30:4
actual:     0
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm78sspq4.rkt:31:4

list-ref: index too large for list
  index: 4
  in: '(1 4 4 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm78sspq4.rkt:33:4

list-ref: index too large for list
  index: 4
  in: '(3 1 1 3)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm78sspq4.rkt:35:4
actual:     0
expected:   1
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (first lst)) (solution (rest lst))]
    [(odd? (second lst)) (+ (second lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:23:4
actual:     1
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:24:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:25:4

second: list contains too few elements
  list: '(321)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:26:4
actual:     9
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:29:4

second: list contains too few elements
  list: '(9)
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (first lst)) (solution (rest lst))]
    [(odd? (second lst)) (+ (second lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:23:4
actual:     1
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:24:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:25:4

second: list contains too few elements
  list: '(321)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:26:4
actual:     9
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:29:4

second: list contains too few elements
  list: '(9)
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (first lst)) (solution (rest lst))]
    [(odd? (second lst)) (+ (second lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:23:4
actual:     1
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:24:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:25:4

second: list contains too few elements
  list: '(321)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:26:4
actual:     9
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:29:4

second: list contains too few elements
  list: '(9)
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(even? (first lst)) (solution (rest lst))]
    [(odd? (second lst)) (+ (second lst) (solution (rest (rest lst))))]
    [else (solution (rest (rest lst)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:23:4
actual:     1
expected:   12
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:24:4

second: list contains too few elements
  list: '(3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:25:4

second: list contains too few elements
  list: '(321)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:26:4
actual:     9
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnryqtk9x.rkt:29:4

second: list contains too few elements
  list: '(9)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond [(empty? interval1) '()]
          [(empty? interval2) '()]
          [(and (>= (first interval1) (first interval2))
                (<= (first interval1) (second interval2)))
           (cons (first interval1) (intersection-helper (rest interval1) interval2))]
          [(and (>= (first interval2) (first interval1))
                (<= (first interval2) (second interval1)))
           (cons (first interval2) (intersection-helper interval1 (rest interval2)))]
          [else (intersection-helper (rest interval1) (rest interval2))]))
  (define (is-prime? n)
    (cond [(= n 1) #f]
          [(= n 2) #t]
          [(even? n) #f]
          [else
           (define (helper n div)
             (cond [(= div (quotient n 2)) #t]
                   [(= (modulo n div) 0) #f]
                   [else (helper n (+ div 1))]))
           (helper n 3)]))
  (cond [(empty? (intersection-helper interval1 interval2)) "NO"]
        [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpo003iykm.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpo003iykm.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo003iykm.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpo003iykm.rkt:58:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpo003iykm.rkt:59:4
actual:     "YES"
expected:   "NO"
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval2 interval1)]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (second interval2)) empty]
        [(< (first interval1) (second interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (- (second interval) (first interval))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppa1d7dh_.rkt:57:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppa1d7dh_.rkt:58:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppa1d7dh_.rkt:61:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppa1d7dh_.rkt:62:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (cond [(= i (sub1 (length arr))) max-index]
          [(< (list-ref arr i) (list-ref arr (add1 i)))
           (loop (add1 i) i)]
          [else (loop (add1 i) max-index)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqkrtr24v.rkt:25:4
actual:     2
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqkrtr24v.rkt:26:4
actual:     7
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqkrtr24v.rkt:27:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqkrtr24v.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_124_valid_date --------
#lang racket

;; You have to write a function which validates a given date string and
;; returns #t if the date is valid otherwise #f.
;; The date is valid if all of the following rules are satisfied:
;; 1. The date string is not empty.
;; 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
;; 3. The months should not be less than 1 or higher than 12.
;; 4. The date should be in the format: mm-dd-yyyy
;; >>> (valid_date "03-11-2000")
;; #t
;; >>> (valid_date "15-01-2012")
;; #f
;; >>> (valid_date "04-0-2040")
;; #f
;; >>> (valid_date "06-04-2020")
;; #t
;; >>> (valid_date "06/04/2020")
;; #f
(define (valid_date date)
  (define (valid-month month)
    (and (integer? month)
         (and (>= month 1) (<= month 12))))
  (define (valid-day month day)
    (and (integer? day)
         (and (>= day 1)
              (cond
                [(or (= month 1) (= month 3) (= month 5) (= month 7) (= month 8) (= month 10) (= month 12)) (<= day 31)]
                [(or (= month 4) (= month 6) (= month 9) (= month 11)) (<= day 30)]
                [(= month 2) (<= day 29)]))))
  (define (valid-year year)
    (and (integer? year)
         (and (>= year 1) (<= year 9999))))
  (define (valid-date-format date)
    (and (string? date)
         (regexp-match? #rx"^[0-9]{2}-[0-9]{2}-[0-9]{4}$" date)))
  (let* ([date-parts (string-split date "-")]
         [month (string->number (list-ref date-parts 0))]
         [day (string->number (list-ref date-parts 1))]
         [year (string->number (list-ref date-parts 2))])
    (and (valid-date-format date)
         (valid-month month)
         (valid-day month day)
         (valid-year year))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate valid_date))
    (check-equal? (candidate "03-11-2000") #t)
    (check-equal? (candidate "15-01-2012") #f)
    (check-equal? (candidate "04-0-2040") #f)
    (check-equal? (candidate "06-04-2020") #t)
    (check-equal? (candidate "01-01-2007") #t)
    (check-equal? (candidate "03-32-2011") #f)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "04-31-3000") #f)
    (check-equal? (candidate "06-06-2005") #t)
    (check-equal? (candidate "21-31-2000") #f)
    (check-equal? (candidate "04-12-2003") #t)
    (check-equal? (candidate "04122003") #f)
    (check-equal? (candidate "20030412") #f)
    (check-equal? (candidate "2003-04") #f)
    (check-equal? (candidate "2003-04-12") #f)
    (check-equal? (candidate "04-2003") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:51:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:54:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:55:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:57:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:59:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:61:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:62:4

list-ref: index too large for list
  index: 1
  in: '("04122003")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:63:4

list-ref: index too large for list
  index: 1
  in: '("20030412")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:64:4

list-ref: index too large for list
  index: 2
  in: '("2003" "04")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpra5ii7ky.rkt:66:4

list-ref: index too large for list
  index: 2
  in: '("04" "2003")
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond [(= i (- (length arr) 1)) -1]
          [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps7m8oq3l.rkt:23:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps7m8oq3l.rkt:24:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps7m8oq3l.rkt:25:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps7m8oq3l.rkt:26:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps7m8oq3l.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (loop i)
      (cond ((> i (/ n 2)) #t)
            ((is-divisible? n i) #f)
            (else (loop (+ i 1)))))
    (cond ((= n 1) #f)
          ((= n 2) #t)
          (else (loop 2))))
  (define (word-lengths sentence)
    (map string-length (string-split sentence)))
  (define (prime-word-lengths sentence)
    (filter is-prime? (word-lengths sentence)))
  (define (prime-words sentence)
    (map (lambda (word)
           (list-ref (string-split sentence) word))
          (prime-word-lengths sentence)))
  (string-join (prime-words sentence) " "))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps8ppbbta.rkt:43:4
actual:     "a"
expected:   "is"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps8ppbbta.rkt:44:4
actual:     "for swimming"
expected:   "go for"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmps8ppbbta.rkt:45:4
actual:     "here no no here"
expected:   "there is no place"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8ppbbta.rkt:46:4

list-ref: index too large for list
  index: 7
  in: '("Hi" "I" "am" "Hussein")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8ppbbta.rkt:47:4

list-ref: index too large for list
  index: 3
  in: '("go" "for" "it")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8ppbbta.rkt:49:4

list-ref: index too large for list
  index: 2
  in: '("here" "is")
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (can-arrange-helper arr i)
    (cond
      [(= i (- (length arr) 1)) -1]
      [(< (list-ref arr i) (list-ref arr (+ i 1))) i]
      [else (can-arrange-helper arr (+ i 1))]))
  (can-arrange-helper arr 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptfua6blg.rkt:25:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptfua6blg.rkt:26:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptfua6blg.rkt:27:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptfua6blg.rkt:28:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptfua6blg.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (= i (sub1 (length arr)))
        max-index
        (let ([current-index (add1 i)])
          (if (<= (list-ref arr i) (list-ref arr current-index))
              (loop current-index current-index)
              (loop current-index max-index))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptt0ce0iz.rkt:26:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptt0ce0iz.rkt:27:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptt0ce0iz.rkt:28:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptt0ce0iz.rkt:29:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptt0ce0iz.rkt:30:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index 0])
    (if (= i (sub1 (length arr)))
        (if (> max-index i)
            max-index
            -1)
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpu8xdwbxf.rkt:27:4
actual:     -1
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpu8xdwbxf.rkt:29:4
actual:     -1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpu8xdwbxf.rkt:30:4
actual:     -1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8xdwbxf.rkt:31:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (and (negative? (second lst))
                     (> (first lst) (second lst)))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (and (positive? (second lst))
                     (< (first lst) (second lst)))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:40:4
actual:     '(#f 2)
expected:   '(#f 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:41:4
actual:     '(#f 2)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:42:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:43:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:44:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:49:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:50:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_136_largest_smallest_integers --------
#lang racket

;; Create a function that returns a list (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as #f.
;; Examples:
;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))
;; (list #f 1)
;; >>> (largest_smallest_integers (list ))
;; (list #f #f)
;; >>> (largest_smallest_integers (list 0))
;; (list #f #f)
(define (largest_smallest_integers lst)
  (define (largest_negative lst)
    (cond
      [(empty? lst) #f]
      [(and (negative? (first lst))
            (or (not (negative? (second lst)))
                (and (negative? (second lst))
                     (> (first lst) (second lst)))))
       (first lst)]
      [else (largest_negative (rest lst))]))
  (define (smallest_positive lst)
    (cond
      [(empty? lst) #f]
      [(and (positive? (first lst))
            (or (not (positive? (second lst)))
                (and (positive? (second lst))
                     (< (first lst) (second lst)))))
       (first lst)]
      [else (smallest_positive (rest lst))]))
  (list (largest_negative lst) (smallest_positive lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))
    (check-equal? (candidate (list 2 4 1 3 5 7 0)) (list #f 1))
    (check-equal? (candidate (list 1 3 2 4 5 6 -2)) (list -2 1))
    (check-equal? (candidate (list 4 5 3 6 2 7 -7)) (list -7 2))
    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list -9 2))
    (check-equal? (candidate (list )) (list #f #f))
    (check-equal? (candidate (list 0)) (list #f #f))
    (check-equal? (candidate (list -1 -3 -5 -6)) (list -1 #f))
    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1 #f))
    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))
    (check-equal? (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:40:4
actual:     '(#f 2)
expected:   '(#f 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:41:4
actual:     '(#f 2)
expected:   '(#f 1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:42:4

second: list contains too few elements
  list: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:43:4

second: list contains too few elements
  list: '(-7)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:44:4

second: list contains too few elements
  list: '(-9)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:49:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv5ro5x__.rkt:50:4

second: list contains too few elements
  list: '(1)
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (- (length arr) 1))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvmo0ifsj.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvmo0ifsj.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvmo0ifsj.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvmo0ifsj.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond [(= i (sub1 (length arr))) -1]
          [(>= (list-ref arr i) (list-ref arr j))
           (loop (+ i 1) (+ j 1))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvxfznis4.rkt:24:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvxfznis4.rkt:25:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvxfznis4.rkt:26:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvxfznis4.rkt:27:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvxfznis4.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond [(= i (- (length arr) 1)) -1]
          [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
          [else j])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw_vibdft.rkt:23:4
actual:     1
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw_vibdft.rkt:24:4
actual:     1
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw_vibdft.rkt:25:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw_vibdft.rkt:26:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw_vibdft.rkt:27:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_121_solution --------
#lang racket

;; Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
;; Examples
;; >>> (solution (list 5 8 7 1))
;; 12
;; >>> (solution (list 3 3 3 3 3))
;; 9
;; >>> (solution (list 30 13 24 321))
;; 0
(define (solution lst)
  (cond
    [(empty? lst) 0]
    [(and (even? (first lst)) (odd? (second lst))) (+ (second lst) (solution (rest (rest lst))))]
    [else (solution (rest lst))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solution))
    (check-equal? (candidate (list 5 8 7 1)) 12)
    (check-equal? (candidate (list 3 3 3 3 3)) 9)
    (check-equal? (candidate (list 30 13 24 321)) 0)
    (check-equal? (candidate (list 5 9)) 5)
    (check-equal? (candidate (list 2 4 8)) 0)
    (check-equal? (candidate (list 30 13 23 32)) 23)
    (check-equal? (candidate (list 3 13 2 9)) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:22:4
actual:     7
expected:   12
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:23:4
actual:     0
expected:   9
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:24:4
actual:     334
expected:   0
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:25:4
actual:     0
expected:   5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:26:4

second: list contains too few elements
  list: '(8)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:27:4

second: list contains too few elements
  list: '(32)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx698iptu.rkt:28:4
actual:     9
expected:   3
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-i -1])
    (if (= i (sub1 (length arr)))
        max-i
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-i -1])
    (if (= i (sub1 (length arr)))
        max-i
        (if (<= (list-ref arr i) (list-ref arr (add1 i)))
            (loop (add1 i) (add1 i))
            (loop (add1 i) max-i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:25:4
actual:     4
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:26:4
actual:     3
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:27:4
actual:     8
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:28:4
actual:     3
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx9vva8gh.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (sum-of-triple a i j k)
    (+ (list-ref a i) (list-ref a j) (list-ref a k)))
  (define (is-triple-valid? a i j k)
    (and (< i j) (< j k) (zero? (modulo (sum-of-triple a i j k) 3))))
  (define (count-triples a)
    (let loop ([i 0] [j 1] [k 2] [count 0])
      (cond [(= i (- n 3)) count]
            [(is-triple-valid? a i j k) (loop (+ i 1) (+ j 1) (+ k 1) (+ count 1))]
            [(= j (- n 2)) (loop (+ i 1) (+ i 2) (+ i 3) count)]
            [(= k (- n 1)) (loop i (+ j 1) (+ j 2) count)]
            [else (loop i j (+ k 1) count)])))
  (count-triples (build-list n (lambda (i) (+ (* i i) (- i 1)))))
)

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpxn1j9pft.rkt:34:4
actual:     2
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxn1j9pft.rkt:35:4

list-ref: index too large for list
  index: 10
  in: '(-1 1 5 11 19 29 41 55 71 89)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxn1j9pft.rkt:36:4

list-ref: index too large for list
  index: 100
  in: '(-1 1 5 11 19 29 41 55 71 89 109 131 155 181 209 239 271 305 341 379 419 461 505 551 599 649 701 755 811 869 929 991 1055 1121 1189 1259 1331 1405 1481 1559 1639 1721 1805 1891 1979 2069 2161 2255 2351 2449 2549 2651 2755 2861 2969 3079 3191 3305 3421 ...
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (iter i)
    (cond
      [(= i (- (length arr) 1)) -1]
      [(< (list-ref arr i) (list-ref arr (+ i 1))) i]
      [else (iter (+ i 1))]))
  (iter 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy49bulmq.rkt:25:4
actual:     0
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy49bulmq.rkt:26:4
actual:     0
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy49bulmq.rkt:27:4
actual:     0
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy49bulmq.rkt:28:4
actual:     0
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy49bulmq.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (if (= i (sub1 (length arr)))
        -1
        (if (<= (list-ref arr i) (list-ref arr j))
            (loop (+ i 1) (+ j 1))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:25:4
actual:     2
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:27:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:28:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyacvlyad.rkt:29:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [j 1])
    (cond
      [(= i (sub1 (length arr))) -1]
      [(>= (list-ref arr i) (list-ref arr j)) (loop (+ i 1) (+ j 1))]
      [else j])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyl1bpzio.rkt:24:4
actual:     1
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyl1bpzio.rkt:25:4
actual:     1
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyl1bpzio.rkt:26:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyl1bpzio.rkt:27:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyl1bpzio.rkt:28:4

list-ref: index too large for list
  index: 0
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (can-arrange-helper arr i)
    (if (= i (- (length arr) 1))
        -1
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (can-arrange-helper arr (+ i 1))
            i)))
  (can-arrange-helper arr 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyums_2ze.rkt:26:4
actual:     1
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyums_2ze.rkt:27:4
actual:     1
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyums_2ze.rkt:28:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpyums_2ze.rkt:29:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyums_2ze.rkt:30:4

list-ref: index too large for list
  index: 1
  in: '()
--------------------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (define (can_arrange-helper arr i)
    (if (= i (length arr))
        -1
        (if (<= (list-ref arr i) (list-ref arr (- i 1)))
            (can_arrange-helper arr (+ i 1))
            i)))
  (can_arrange-helper arr 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzw8lchx1.rkt:26:4
actual:     1
expected:   3
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzw8lchx1.rkt:27:4
actual:     1
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzw8lchx1.rkt:28:4
actual:     1
expected:   2
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzw8lchx1.rkt:29:4
actual:     1
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzw8lchx1.rkt:30:4

list-ref: index too large for list
  index: 1
  in: '()
--------------------

