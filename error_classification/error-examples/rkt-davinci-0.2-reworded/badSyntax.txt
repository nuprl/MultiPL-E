HumanEval_103_rounded_avg: 15
HumanEval_39_prime_fib: 6
HumanEval_77_iscube: 4
HumanEval_147_get_max_triples: 1
HumanEval_120_maximum: 1
HumanEval_31_is_prime: 11
HumanEval_10_make_palindrome: 1
HumanEval_37_sort_even: 4
HumanEval_26_remove_duplicates: 3
HumanEval_130_tri: 6
HumanEval_156_int_to_mini_roman: 1
HumanEval_49_modp: 2
HumanEval_97_multiply: 2
HumanEval_41_car_race_collision: 1
HumanEval_84_solve: 6
HumanEval_89_encrypt: 5
HumanEval_160_do_algebra: 1
HumanEval_65_circular_shift: 1
HumanEval_68_pluck: 1
HumanEval_111_histogram: 2
HumanEval_85_add: 4
HumanEval_138_is_equal_to_sum_even: 5
HumanEval_61_correct_bracketing: 1
HumanEval_75_is_multiply_prime: 7
HumanEval_117_select_words: 5
HumanEval_94_skjkasdkd: 2
HumanEval_143_words_in_sentence: 1
HumanEval_114_minSubArraySum: 3
HumanEval_6_parse_nested_parens: 2
HumanEval_159_eat: 2
HumanEval_141_file_name_check: 5
HumanEval_127_intersection: 3
HumanEval_43_pairs_sum_to_zero: 2
HumanEval_161_solve: 1
HumanEval_47_median: 2
HumanEval_34_unique: 1
HumanEval_128_prod_signs: 1
HumanEval_122_add_elements: 1
HumanEval_86_anti_shuffle: 1
HumanEval_126_is_sorted: 1
HumanEval_154_cycpattern_check: 2
HumanEval_59_largest_prime_factor: 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m) -1
      (define sum 0)
      (define count 0)
      (for ([i (in-range n (+ m 1))])
        (set! sum (+ sum i))
        (set! count (+ count 1)))
      (define avg (/ sum count))
      (define rounded (round avg))
      (define binary (number->string rounded 2))
      (string-append "0b" binary)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp0j5jvrwx.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define sum 0) (define count 0) (for ((i (in-range n (+ m 1)))) (set! sum (+ sum i)) (set! count (+ count 1))) (define avg (/ sum count)) (define rounded (round avg)) (define binary (number->string rounded 2)) (string-append "0b" binary))
  location...:
   /tmp/tmp0j5jvrwx.rkt:17:2

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (if (< n 2)
        #f
        (if (= n 2)
            #t
            (if (even? n)
                #f
                (define (prime?-iter n d)
                  (if (> (* d d) n)
                      #t
                      (if (zero? (modulo n d))
                          #f
                          (prime?-iter n (+ d 1)))))
              (prime?-iter n 3)))))
  (define (prime_fib-iter n i)
    (if (= n 1)
        (fib i)
        (if (prime? (fib i))
            (prime_fib-iter (- n 1) (+ i 1))
            (prime_fib-iter n (+ i 1)))))
  (prime_fib-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp11e1g_ez.rkt:24:12: if: bad syntax
  in: (if (even? n) #f (define (prime?-iter n d) (if (> (* d d) n) #t (if (zero? (modulo n d)) #f (prime?-iter n (+ d 1))))) (prime?-iter n 3))
  location...:
   /tmp/tmp11e1g_ez.rkt:24:12

==========================
------- Program HumanEval_77_iscube --------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (if (= a 0)
      #t
      (if (= a 1)
          #t
          (if (= a -1)
              #t
              (if (= (expt (round (sqrt a)) 3) a)
                  #t
                  #f)))))
</code>
I'm not sure if this is the best way to do it, but it works.


A:

You can use the <code>exact-integer-sqrt</code> procedure to check if the square root of the number is an integer.
<code>(define (iscube a)
  (let ((sqrt (exact-integer-sqrt a)))
    (and sqrt (= (* sqrt sqrt sqrt) a))))
</code>

(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-equal? (candidate 1) #t)
    (check-equal? (candidate 2) #f)
    (check-equal? (candidate -1) #t)
    (check-equal? (candidate 64) #t)
    (check-equal? (candidate 180) #f)
    (check-equal? (candidate 1000) #t)
    (check-equal? (candidate 0) #t)
    (check-equal? (candidate 1729) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp19d5y3_0.rkt:30:40: do: bad syntax
  in: do
  location...:
   /tmp/tmp19d5y3_0.rkt:30:40
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (string->number (number->string (avg n m) 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp1iihg9jm.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (string->number (number->string (avg n m) 2)))
  location...:
   /tmp/tmp1iihg9jm.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (average n m)
        (/ (+ n m) 2))
      (define (round n)
        (if (integer? n)
            n
            (round (+ n 1))))
      (define (convert n)
        (number->string n 2))
      (convert (round (average n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp2nh5t0w9.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (average n m) (/ (+ n m) 2)) (define (round n) (if (integer? n) n (round (+ n 1)))) (define (convert n) (number->string n 2)) (convert (round (average n m))))
  location...:
   /tmp/tmp2nh5t0w9.rkt:17:2

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (helper i acc)
    (if (= i n)
        acc
        (helper (+ i 1) (+ acc (if (and (> i 1) (multiple-of-3? (+ (expt i 2) (- i 1))))) 1 0))
      )
    )
  (helper 1 0)
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp9ovfvb5m.rkt:17:31: if: bad syntax
  in: (if (and (> i 1) (multiple-of-3? (+ (expt i 2) (- i 1)))))
  location...:
   /tmp/tmp9ovfvb5m.rkt:17:31

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_0yiwmup.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmp_0yiwmup.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_0yiwmup.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmp_0yiwmup.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_0yiwmup.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmp_0yiwmup.rkt:17:2

==========================
------- Program HumanEval_120_maximum --------
#lang racket

;; Given a list arr of integers and a positive integer k, return a sorted list 
;; of length k with the maximum k numbers in arr.
;; Example 1:
;; >>> (maximum (list -3 -4 5) 3)
;; (list -4 -3 5)
;; Example 2:
;; >>> (maximum (list 4 -4 4) 2)
;; (list 4 4)
;; Example 3:
;; >>> (maximum (list -3 2 1 2 -1 -2 1) 1)
;; (list 2)
;; Note:
;; 1. The length of the list will be in the range of [1, 1000].
;; 2. The elements in the list will be in the range of [-1000, 1000].
;; 3. 0 <= k <= len(arr)
(define (maximum arr k)
  (if (or (null? arr) (= k 0))
      '()
      (define (maximum-helper arr k)
        (if (or (null? arr) (= k 0))
            '()
            (let ([max (apply max arr)])
              (cons max (maximum-helper (remove max arr) (- k 1))))))
    (maximum-helper arr k)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate maximum))
    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))
    (check-equal? (candidate (list 4 -4 4) 2) (list 4 4))
    (check-equal? (candidate (list -3 2 1 2 -1 -2 1) 1) (list 2))
    (check-equal? (candidate (list 123 -123 20 0 1 2 -3) 3) (list 2 20 123))
    (check-equal? (candidate (list -123 20 0 1 2 -3) 4) (list 0 1 2 20))
    (check-equal? (candidate (list 5 15 0 3 -13 -8 0) 7) (list -13 -8 0 0 3 5 15))
    (check-equal? (candidate (list -1 0 2 5 3 -10) 2) (list 3 5))
    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))
    (check-equal? (candidate (list 4 -4) 2) (list -4 4))
    (check-equal? (candidate (list -10 10) 2) (list -10 10))
    (check-equal? (candidate (list 1 2 3 -23 243 -400 0) 0) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_4mg5zaq.rkt:19:2: if: bad syntax
  in: (if (or (null? arr) (= k 0)) (quote ()) (define (maximum-helper arr k) (if (or (null? arr) (= k 0)) (quote ()) (let ((max (apply max arr))) (cons max (maximum-helper (remove max arr) (- k 1)))))) (maximum-helper arr k))
  location...:
   /tmp/tmp_4mg5zaq.rkt:19:2

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (if (< n 2)
        #f
        (define (prime? n i)
          (if (< i n)
              (if (= (remainder n i) 0)
                  #f
                  (prime? n (+ i 1)))
              #t))
    (prime? n 2)))
  (define (prime_fib n i)
    (if (= n i)
        (fib i)
        (if (prime? (fib i))
            (prime_fib n (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_jnylkgk.rkt:20:4: if: bad syntax
  in: (if (< n 2) #f (define (prime? n i) (if (< i n) (if (= (remainder n i) 0) #f (prime? n (+ i 1))) #t)) (prime? n 2))
  location...:
   /tmp/tmp_jnylkgk.rkt:20:4

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (if (= n 1)
      #f
      (define (is_prime-helper n i)
        (if (= i n)
            #t
            (if (= (modulo n i) 0)
                #f
                (is_prime-helper n (+ i 1)))))
      (is_prime-helper n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp_l37m92i.rkt:19:2: if: bad syntax
  in: (if (= n 1) #f (define (is_prime-helper n i) (if (= i n) #t (if (= (modulo n i) 0) #f (is_prime-helper n (+ i 1))))) (is_prime-helper n 2))
  location...:
   /tmp/tmp_l37m92i.rkt:19:2

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (is_palindrome? string)
    (define (is_palindrome?-helper string start end)
      (if (= start end)
          #t
          (if (= (string-ref string start) (string-ref string (- end 1)))
              (is_palindrome?-helper string (+ start 1) (- end 1))
              #f)))
    (is_palindrome?-helper string 0 (string-length string)))
  (define (find-palindrome-suffix string)
    (define (find-palindrome-suffix-helper string start end)
      (if (is_palindrome? (substring string start end))
          (substring string start end)
          (find-palindrome-suffix-helper string start (- end 1))))
    (find-palindrome-suffix-helper string 0 (string-length string)))
  (define (reverse string)
    (define (reverse-helper string start end)
      (if (= start end)
          string
          (string-set! string start (string-ref string (- end 1)))
          (string-set! string (- end 1) (string-ref string start))
          (reverse-helper string (+ start 1) (- end 1))))
    (reverse-helper string 0 (string-length string)))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpa9u4qzis.rkt:30:6: if: bad syntax
  in: (if (= start end) string (string-set! string start (string-ref string (- end 1))) (string-set! string (- end 1) (string-ref string start)) (reverse-helper string (+ start 1) (- end 1)))
  location...:
   /tmp/tmpa9u4qzis.rkt:30:6

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (cond
    [(empty? l) empty]
    [(empty? (rest l)) l]
    [else (cons (first l)
                (sort (rest (rest l)))
                (sort_even (rest (rest l))))]))
</code>
I'm not sure how to proceed from here. I'm not sure if I'm on the right track.


A:

You can use <code>for/fold</code> to build a new list from the old one, and <code>even?</code> to check if the current index is even:
<code>(define (sort-even lst)
  (for/fold ([new-lst '()])
            ([i (in-list lst)])
    (if (even? i)
        (cons (sort i) new-lst)
        (cons i new-lst))))
</code>
It works as expected:
<code>(sort-even (list 1 2 3))
=&gt; '(1 2 3)

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpaiw45apq.rkt:23:45: new: bad syntax
  in: new
  location...:
   /tmp/tmpaiw45apq.rkt:23:45
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_26_remove_duplicates --------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  (let ([seen (make-hash)])
    (for/list ([n numbers])
      (if (hash-ref seen n #f)
          '()
          (hash-set! seen n #t)
          (list n)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpansowg32.rkt:10:6: if: bad syntax
  in: (if (hash-ref seen n #f) (quote ()) (hash-set! seen n #t) (list n))
  location...:
   /tmp/tmpansowg32.rkt:10:6

==========================
------- Program HumanEval_26_remove_duplicates --------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  (let ([seen (make-hash)])
    (for/list ([n numbers])
      (if (hash-ref seen n #f)
          '()
          (hash-set! seen n #t)
          (list n)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpansowg32.rkt:10:6: if: bad syntax
  in: (if (hash-ref seen n #f) (quote ()) (hash-set! seen n #t) (list n))
  location...:
   /tmp/tmpansowg32.rkt:10:6

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpb1wceia4.rkt:26:14: if: bad syntax
  in: (if (= (remainder n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpb1wceia4.rkt:26:14

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (> n m)
            0
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (number->string (avg n m) 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpbkx3f1eo.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (> n m) 0 (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (number->string (avg n m) 2))
  location...:
   /tmp/tmpbkx3f1eo.rkt:17:2

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (let ([roman-numerals '((1000 "m") (900 "cm") (500 "d") (400 "cd") (100 "c") (90 "xc") (50 "l") (40 "xl") (10 "x") (9 "ix") (5 "v") (4 "iv") (1 "i"))])
    (let loop ([number number] [roman-numerals roman-numerals] [result ""])
      (if (zero? number)
          result
          (let ([(numeral-value . numeral-string) (car roman-numerals)])
            (if (<= number numeral-value)
                (loop (- number numeral-value) roman-numerals (string-append result numeral-string))
                (loop number (cdr roman-numerals) result)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpc4h7s0ce.rkt:18:17: let: bad syntax (not an identifier)
  at: (numeral-value . numeral-string)
  in: (let (((numeral-value . numeral-string) (car roman-numerals))) (if (<= number numeral-value) (loop (- number numeral-value) roman-numerals (string-append result numeral-string)) (loop number (cdr roman-numerals) result)))
  location...:
   /tmp/tmpc4h7s0ce.rkt:18:17
  context...:
   /work/arjunguha-research-group/software/racket/collects/racket/private/qq-and-or.rkt:101:61: loop
   /work/arjunguha-research-group/software/racket/collects/racket/private/qq-and-or.rkt:50:20: go

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (zero? n)
      1
      (if (odd? n)
          (* (modp (quotient n 2) p) (modp (quotient n 2) p) p)
          (* (modp (quotient n 2) p) (modp (quotient n 2) p) p) p)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpcflz1yig.rkt:17:6: if: bad syntax
  in: (if (odd? n) (* (modp (quotient n 2) p) (modp (quotient n 2) p) p) (* (modp (quotient n 2) p) (modp (quotient n 2) p) p) p)
  location...:
   /tmp/tmpcflz1yig.rkt:17:6

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum_of_numbers n m)
        (if (> n m)
            0
            (+ n (sum_of_numbers (+ n 1) m))))
      (define (average n m)
        (round (/ (sum_of_numbers n m) (- m n))))
      (define (binary n)
        (if (= n 0)
            ""
            (string-append (binary (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (binary (average n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpcw7q00ni.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum_of_numbers n m) (if (> n m) 0 (+ n (sum_of_numbers (+ n 1) m)))) (define (average n m) (round (/ (sum_of_numbers n m) (- m n)))) (define (binary n) (if (= n 0) "" (string-append (binary (quotient n 2)) (number->string (remain...
  location...:
   /tmp/tmpcw7q00ni.rkt:17:2

==========================
------- Program HumanEval_77_iscube --------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (if (zero? a)
      #t
      (if (and (not (zero? a)) (not (negative? a)))
          (if (and (integer? (sqrt a)) (integer? (expt (sqrt a) 3)))
              #t
              #f)
          (if (and (not (zero? a)) (negative? a))
              (if (and (integer? (sqrt (- a))) (integer? (expt (sqrt (- a)) 3)))
                  #t
                  #f)
              #f))))
</code>
I'm not sure if this is the best way to do it, but it works.


A:

You can use <code>exact-integer-sqrt</code> to check if the square root of the number is an integer.
<code>(define (iscube a)
  (if (zero? a)
      #t
      (if (and (not (zero? a)) (not (negative? a)))
          (if (integer? (exact-integer-sqrt a))
              #t
              #f)
          (if (and (not (zero? a)) (negative? a))
              (if (integer? (exact-integer-sqrt (- a)))
                  #t
                  #f)
              #f))))
</code>

(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-equal? (candidate 1) #t)
    (check-equal? (candidate 2) #f)
    (check-equal? (candidate -1) #t)
    (check-equal? (candidate 64) #t)
    (check-equal? (candidate 180) #f)
    (check-equal? (candidate 1000) #t)
    (check-equal? (candidate 0) #t)
    (check-equal? (candidate 1729) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpdlh_ykgx.rkt:32:40: do: bad syntax
  in: do
  location...:
   /tmp/tmpdlh_ykgx.rkt:32:40
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (modulo (* (modulo a 10) (modulo b 10)) 10))
</code>
I'm not sure if this is the best way to do it, but it works.


A:

I think your solution is fine.
Another way to do it is to use <code>modulo</code> twice:
<code>(define (multiply a b)
  (modulo (modulo (* a b) 10) 10))
</code>

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpe7pwzix9.rkt:18:40: do: bad syntax
  in: do
  location...:
   /tmp/tmpe7pwzix9.rkt:18:40
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left_cars right_cars)
    (cond
      [(= n 0) 0]
      [(= n 1) 0]
      [(= n 2) 1]
      [else
       (let ([left_car (car left_cars)]
             [right_car (car right_cars)])
         (if (< left_car right_car)
             (car_race_collision_helper (- n 1) (cdr left_cars) right_cars)
             (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars))
             (+ 1 (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars)))))]))
  (car_race_collision_helper n (range n) (reverse (range n))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpekzrn0hl.rkt:20:9: if: bad syntax
  in: (if (< left_car right_car) (car_race_collision_helper (- n 1) (cdr left_cars) right_cars) (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars)) (+ 1 (car_race_collision_helper (- n 1) (cdr left_cars) (cdr right_cars))))
  location...:
   /tmp/tmpekzrn0hl.rkt:20:9

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (quotient (sum n m) (- m n)))
      (define (to_binary n)
        (if (= n 0)
            ""
            (string-append (to_binary (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (to_binary (avg n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpeo70a3yy.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (quotient (sum n m) (- m n))) (define (to_binary n) (if (= n 0) "" (string-append (to_binary (quotient n 2)) (number->string (remainder n 2))))) (string-append "0b"...
  location...:
   /tmp/tmpeo70a3yy.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define sum (+ n m))
      (define avg (/ sum 2))
      (define rounded (round avg))
      (define binary (number->string rounded 2))
      (string-append "0b" binary)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmph90nur9j.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define sum (+ n m)) (define avg (/ sum 2)) (define rounded (round avg)) (define binary (number->string rounded 2)) (string-append "0b" binary))
  location...:
   /tmp/tmph90nur9j.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (avg n m)
        (/ (+ n m) 2))
      (define (round n)
        (if (and (> n 0) (< n 1))
            0
            (if (>= n 1)
                (add1 (round (- n 1)))
                (round n))))
      (define (convert n)
        (if (= n 0)
            '()
            (cons (remainder n 2) (convert (quotient n 2)))))
      (define (reverse lst)
        (if (null? lst)
            '()
            (append (reverse (cdr lst)) (list (car lst)))))
      (define (convert-to-string lst)
        (if (null? lst)
            ""
            (string-append (number->string (car lst)) (convert-to-string (cdr lst)))))
      (string-append "0b" (convert-to-string (reverse (convert (round (avg n m))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpibf7z0nz.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (avg n m) (/ (+ n m) 2)) (define (round n) (if (and (> n 0) (< n 1)) 0 (if (>= n 1) (add1 (round (- n 1))) (round n)))) (define (convert n) (if (= n 0) (quote ()) (cons (remainder n 2) (convert (quotient n 2))))) (define (reverse ...
  location...:
   /tmp/tmpibf7z0nz.rkt:17:2

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (if (= n 1)
        #f
        (if (= n 2)
            #t
            (if (even? n)
                #f
                (define (iter i)
                  (if (> i (sqrt n))
                      #t
                      (if (zero? (modulo n i))
                          #f
                          (iter (+ i 1)))))
                (iter 3)))))
  (define (iter i)
    (if (= i n)
        (fib i)
        (if (prime? (fib i))
            (iter (+ i 1))
            (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpikmfz_t7.rkt:24:12: if: bad syntax
  in: (if (even? n) #f (define (iter i) (if (> i (sqrt n)) #t (if (zero? (modulo n i)) #f (iter (+ i 1))))) (iter 3))
  location...:
   /tmp/tmpikmfz_t7.rkt:24:12

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpky2pkfjs.rkt:26:14: if: bad syntax
  in: (if (= (modulo n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpky2pkfjs.rkt:26:14

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (tri (- n 1))) (tri (- n 2)))
                  (cons (add1 (tri (+ n 1))) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpky2pkfjs.rkt:26:14: if: bad syntax
  in: (if (= (modulo n 2) 0) (cons (add1 (/ n 2)) (tri (- n 1))) (cons (add1 (tri (- n 1))) (tri (- n 2))) (cons (add1 (tri (+ n 1))) (tri (- n 1))))
  location...:
   /tmp/tmpky2pkfjs.rkt:26:14

==========================
------- Program HumanEval_26_remove_duplicates --------
#lang racket

;; From a list of integers, remove all elements that occur more than once.
;; Keep order of elements left the same as in the input.
;; >>> (remove_duplicates (list 1 2 3 2 4))
;; (list 1 3 4)
(define (remove_duplicates numbers)
  (let ([seen (make-hash)])
    (filter (lambda (n)
              (if (hash-ref seen n #f)
                  #f
                  (hash-set! seen n #t)
                  #t))
            numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_duplicates))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 1 2 3 2 4 3 5)) (list 1 4 5))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmjt_m21k.rkt:10:14: if: bad syntax
  in: (if (hash-ref seen n #f) #f (hash-set! seen n #t) #t)
  location...:
   /tmp/tmpmjt_m21k.rkt:10:14

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (sum-digits n)
    (if (= n 0)
        0
        (+ (modulo n 10) (sum-digits (quotient n 10)))))
  (define (to-binary n)
    (if (= n 0)
        ""
        (to-binary (quotient n 2))
        (number->string (modulo n 2))))
  (to-binary (sum-digits N)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmq94sz9f.rkt:22:4: if: bad syntax
  in: (if (= n 0) "" (to-binary (quotient n 2)) (number->string (modulo n 2)))
  location...:
   /tmp/tmpmq94sz9f.rkt:22:4

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum n m)
        (if (= n m)
            n
            (+ n (sum (+ n 1) m))))
      (define (avg n m)
        (round (/ (sum n m) (- m n))))
      (define (bin n)
        (if (= n 0)
            ""
            (string-append (bin (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (bin (avg n m)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmw2md4ow.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum n m) (if (= n m) n (+ n (sum (+ n 1) m)))) (define (avg n m) (round (/ (sum n m) (- m n)))) (define (bin n) (if (= n 0) "" (string-append (bin (quotient n 2)) (number->string (remainder n 2))))) (string-append "0b" (bin (avg ...
  location...:
   /tmp/tmpmw2md4ow.rkt:17:2

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (avg n m)
        (/ (+ n m) 2))
      (define (rounded_avg n m)
        (round (avg n m)))
      (define (convert-to-binary n)
        (number->string n 2))
      (convert-to-binary (rounded_avg n m))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpn9j76hfo.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (avg n m) (/ (+ n m) 2)) (define (rounded_avg n m) (round (avg n m))) (define (convert-to-binary n) (number->string n 2)) (convert-to-binary (rounded_avg n m)))
  location...:
   /tmp/tmpn9j76hfo.rkt:17:2

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (encrypt-helper s i)
    (if (= i (string-length s))
        ""
        (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) (+ (char->integer #\a) 26)))
        (encrypt-helper s (+ i 1))))
  (encrypt-helper s 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpo8r8cxs3.rkt:18:4: if: bad syntax
  in: (if (= i (string-length s)) "" (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) (+ (char->integer #\a) 26))) (encrypt-helper s (+ i 1)))
  location...:
   /tmp/tmpo8r8cxs3.rkt:18:4

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([op operator] [opd operand] [result (car opd)])
    (if (null? op)
        result
        (loop (cdr op) (cdr opd)
              (case (car op)
                ((+ *) result (car opd))
                (- result (car opd))
                (// result (car opd))
                (** result (car opd)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpohkq1qg8.rkt:28:17: case: bad syntax (not a datum sequence)
  expected: a datum sequence or the binding 'else' from racket/base
  given: an identifier required from the module #%runtime
  at: -
  in: (case (car op) ((+ *) result (car opd)) (- result (car opd)) (// result (car opd)) (** result (car opd)))
  location...:
   /tmp/tmpohkq1qg8.rkt:28:17

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define sum 0)
      (define count 0)
      (for ([i (in-range n m)])
        (set! sum (+ sum i))
        (set! count (+ count 1)))
      (define avg (/ sum count))
      (define rounded_avg (round avg))
      (define binary_avg (integer->binary rounded_avg))
      (string-append "0b" binary_avg)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpox6xrz8p.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define sum 0) (define count 0) (for ((i (in-range n m))) (set! sum (+ sum i)) (set! count (+ count 1))) (define avg (/ sum count)) (define rounded_avg (round avg)) (define binary_avg (integer->binary rounded_avg)) (string-append "0b" bin...
  location...:
   /tmp/tmpox6xrz8p.rkt:17:2

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (null? l)
      '()
      (cons (car l)
            (if (null? (cdr l))
                '()
                (sort (cdr (cdr l)) <)
                (cdr l)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpp89z3rvj.rkt:14:12: if: bad syntax
  in: (if (null? (cdr l)) (quote ()) (sort (cdr (cdr l)) <) (cdr l))
  location...:
   /tmp/tmpp89z3rvj.rkt:14:12

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (null? l)
      '()
      (cons (car l)
            (if (null? (cdr l))
                '()
                (sort (cdr (cdr l)) <)
                (cdr l)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpp89z3rvj.rkt:14:12: if: bad syntax
  in: (if (null? (cdr l)) (quote ()) (sort (cdr (cdr l)) <) (cdr l))
  location...:
   /tmp/tmpp89z3rvj.rkt:14:12

==========================
------- Program HumanEval_37_sort_even --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the odd indicies, while its values at the even indicies are equal
;; to the values of the even indicies of l, but sorted.
;; >>> (sort_even (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_even (list 5 6 3 4))
;; (list 3 6 5 4)
(define (sort_even l)
  (if (null? l)
      '()
      (cons (car l)
            (if (null? (cdr l))
                '()
                (sort (cdr (cdr l)) <)
                (sort_even (cdr l))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_even))
    (check-equal? (candidate (list 1 2 3)) (list 1 2 3))
    (check-equal? (candidate (list 5 3 -5 2 -3 3 9 0 123 1 -10)) (list -10 3 -5 2 -3 3 5 0 9 1 123))
    (check-equal? (candidate (list 5 8 -12 4 23 2 3 11 12 -10)) (list -12 8 3 4 5 2 12 11 23 -10))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmppqktw1fu.rkt:14:12: if: bad syntax
  in: (if (null? (cdr l)) (quote ()) (sort (cdr (cdr l)) <) (sort_even (cdr l)))
  location...:
   /tmp/tmppqktw1fu.rkt:14:12

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (define (sum-of-integers n m)
        (if (= n m)
            n
            (+ n (sum-of-integers (+ n 1) m))))
      (define (avg n m)
        (/ (sum-of-integers n m) (- m n)))
      (define (round-to-int n)
        (if (< n 0)
            (round (- n 0.5))
            (round (+ n 0.5))))
      (define (int-to-binary n)
        (if (= n 0)
            ""
            (string-append (int-to-binary (quotient n 2)) (number->string (remainder n 2)))))
      (string-append "0b" (int-to-binary (round-to-int (avg n m))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpqq2db9x6.rkt:17:2: if: bad syntax
  in: (if (> n m) -1 (define (sum-of-integers n m) (if (= n m) n (+ n (sum-of-integers (+ n 1) m)))) (define (avg n m) (/ (sum-of-integers n m) (- m n))) (define (round-to-int n) (if (< n 0) (round (- n 0.5)) (round (+ n 0.5)))) (define (int-to-binary n) (if ...
  location...:
   /tmp/tmpqq2db9x6.rkt:17:2

==========================
------- Program HumanEval_77_iscube --------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (if (= a 0)
      #t
      (if (= a 1)
          #t
          (if (= a -1)
              #t
              (if (= (expt (round (sqrt a)) 3) a)
                  #t
                  #f)))))
</code>
I'm not sure if this is the most efficient way to do it.


A:

I think you can simplify your code a bit.
<code>(define (iscube a)
  (and (not (negative? a))
       (exact-integer? (cbrt a))))
</code>

(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-equal? (candidate 1) #t)
    (check-equal? (candidate 2) #f)
    (check-equal? (candidate -1) #t)
    (check-equal? (candidate 64) #t)
    (check-equal? (candidate 180) #f)
    (check-equal? (candidate 1000) #t)
    (check-equal? (candidate 0) #t)
    (check-equal? (candidate 1729) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpqy9okacy.rkt:30:50: do: bad syntax
  in: do
  location...:
   /tmp/tmpqy9okacy.rkt:30:50
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (remainder (* a b) 10))
</code>
I'm not sure if this is the best way to do it, but it works.


A:

Your solution is correct, but there's a simpler way to do it:
<code>(define (multiply a b)
  (remainder (abs a) 10)
  (remainder (abs b) 10)
  (* (remainder (abs a) 10) (remainder (abs b) 10)))
</code>

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpsqol0gly.rkt:18:40: do: bad syntax
  in: do
  location...:
   /tmp/tmpsqol0gly.rkt:18:40
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (shift-right x shift)
    (if (zero? shift)
        x
        (shift-right (quotient x 10) (- shift 1))))
  (define (shift-left x shift)
    (if (zero? shift)
        x
        (shift-left (* x 10) (- shift 1))))
  (define (digits x)
    (if (zero? x)
        0
        (+ 1 (digits (quotient x 10)))))
  (define (reverse x)
    (define (reverse-helper x acc)
      (if (zero? x)
          acc
          (reverse-helper (quotient x 10) (+ (* acc 10) (remainder x 10)))))
    (reverse-helper x 0))
  (define (shift-digits x shift)
    (if (> shift (digits x))
        (reverse x)
        (define (shift-digits-helper x shift)
          (if (zero? shift)
              x
              (shift-digits-helper (+ (* (shift-left (remainder x 10) shift) 10) (shift-right x shift)) (- shift 1))))
        (shift-digits-helper x shift)))
  (number->string (shift-digits x shift)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmptdofct6w.rkt:30:4: if: bad syntax
  in: (if (> shift (digits x)) (reverse x) (define (shift-digits-helper x shift) (if (zero? shift) x (shift-digits-helper (+ (* (shift-left (remainder x 10) shift) 10) (shift-right x shift)) (- shift 1)))) (shift-digits-helper x shift))
  location...:
   /tmp/tmptdofct6w.rkt:30:4

==========================
------- Program HumanEval_77_iscube --------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (if (= a 0)
      #t
      (if (= a 1)
          #t
          (if (= a -1)
              #t
              (if (= (expt (round (sqrt a)) 3) a)
                  #t
                  #f)))))
</code>
I am not sure if this is the best way to do it, but it works.


A:

You can use <code>exact-integer-sqrt</code> to check if the number is a perfect square.
<code>(define (iscube a)
  (let ((sqrt (exact-integer-sqrt a)))
    (and sqrt (= a (* sqrt sqrt sqrt)))))
</code>

(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-equal? (candidate 1) #t)
    (check-equal? (candidate 2) #f)
    (check-equal? (candidate -1) #t)
    (check-equal? (candidate 64) #t)
    (check-equal? (candidate 180) #f)
    (check-equal? (candidate 1000) #t)
    (check-equal? (candidate 0) #t)
    (check-equal? (candidate 1729) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpv435s1b4.rkt:30:41: do: bad syntax
  in: do
  location...:
   /tmp/tmpv435s1b4.rkt:30:41
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/wrap-modbeg.rkt:46:4

==========================
------- Program HumanEval_68_pluck --------
#lang racket

;; "Given a list representing a branch of a tree that has non-negative integer nodes
;; your task is to pluck one of the nodes and return it.
;; The plucked node should be the node with the smallest even value.
;; If multiple nodes with the same smallest even value are found return the node that has smallest index.
;; The plucked node should be returned in a list, [ smalest_value, its index ],
;; If there are no even values or the given list is empty, return [].
;; Example 1:
;; >>> (pluck (list 4 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 2:
;; >>> (pluck (list 1 2 3))
;; (list 2 1)
;; Explanation: 2 has the smallest even value, and 2 has the smallest index.
;; Example 3:
;; >>> (pluck (list ))
;; (list )
;; Example 4:
;; >>> (pluck (list 5 0 3 0 4 2))
;; (list 0 1)
;; Explanation: 0 is the smallest value, but  there are two zeros,
;; so we will choose the first zero, which has the smallest index.
;; Constraints:
;; * 1 <= nodes.length <= 10000
;; * 0 <= node.value
(define (pluck arr)
  (if (empty? arr)
      (list)
      (define evens (filter even? arr))
      (if (empty? evens)
          (list)
          (list (apply min evens) (index-of (apply min evens) arr)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pluck))
    (check-equal? (candidate (list 4 2 3)) (list 2 1))
    (check-equal? (candidate (list 1 2 3)) (list 2 1))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))
    (check-equal? (candidate (list 1 2 3 0 5 3)) (list 0 3))
    (check-equal? (candidate (list 5 4 8 4 8)) (list 4 1))
    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))
    (check-equal? (candidate (list 7 9 7 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpv6v2z_ge.rkt:29:2: if: bad syntax
  in: (if (empty? arr) (list) (define evens (filter even? arr)) (if (empty? evens) (list) (list (apply min evens) (index-of (apply min evens) arr))))
  location...:
   /tmp/tmpv6v2z_ge.rkt:29:2

==========================
------- Program HumanEval_111_histogram --------
#lang racket

;; Given a string representing a space separated lowercase letters, return a hash
;; of the letter with the most repetition and containing the corresponding count.
;; If several letters have the same occurrence, return all of them.
;; Example:
;; >>> (histogram "a b c")
;; #hash(("a" .  1) ("b" .  1) ("c" .  1))
;; >>> (histogram "a b b a")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "a b c a b")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "b b b b a")
;; #hash(("b" .  4))
;; >>> (histogram "")
;; #hash()
(define (histogram test)
  (define (histogram-helper test max-count max-letters)
    (if (null? test)
        max-letters
        (let ((letter (car test))
              (rest (cdr test)))
          (if (hash-has-key? max-letters letter)
              (let ((count (hash-ref max-letters letter)))
                (hash-set! max-letters letter (+ count 1))
                (if (> count max-count)
                    (histogram-helper rest count max-letters)
                    (histogram-helper rest max-count max-letters)))
              (hash-set! max-letters letter 1)
              (histogram-helper rest max-count max-letters)))))
  (histogram-helper (string-split test) 0 (make-hash)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate histogram))
    (check-equal? (candidate "a b b a") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c a b") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c d g") #hash(("a" .  1) ("b" .  1) ("c" .  1) ("d" .  1) ("g" .  1)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "b b b b a") #hash(("b" .  4)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "") #hash())
    (check-equal? (candidate "a") #hash(("a" .  1)))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpvsqu38mk.rkt:23:10: if: bad syntax
  in: (if (hash-has-key? max-letters letter) (let ((count (hash-ref max-letters letter))) (hash-set! max-letters letter (+ count 1)) (if (> count max-count) (histogram-helper rest count max-letters) (histogram-helper rest max-count max-letters))) (hash-set! m...
  location...:
   /tmp/tmpvsqu38mk.rkt:23:10

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (encrypt-helper s i)
    (if (equal? i (string-length s))
        ""
        (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) #\a))
        (encrypt-helper s (+ i 1))))
  (encrypt-helper s 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpwn4303ns.rkt:18:4: if: bad syntax
  in: (if (equal? i (string-length s)) "" (string-append (string (modulo (+ (string-ref s i) (* 2 2)) 26) #\a)) (encrypt-helper s (+ i 1)))
  location...:
   /tmp/tmpwn4303ns.rkt:18:4

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (if (null? lst)
      0
      (if (even? (car lst))
          (car lst)
          0)
      (add (cdr lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpyc_fh6zx.rkt:8:2: if: bad syntax
  in: (if (null? lst) 0 (if (even? (car lst)) (car lst) 0) (add (cdr lst)))
  location...:
   /tmp/tmpyc_fh6zx.rkt:8:2

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (if (null? lst)
      0
      (if (even? (car lst))
          (car lst)
          0)
      (add (cdr lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpyc_fh6zx.rkt:8:2: if: bad syntax
  in: (if (null? lst) 0 (if (even? (car lst)) (car lst) 0) (add (cdr lst)))
  location...:
   /tmp/tmpyc_fh6zx.rkt:8:2

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (if (null? lst)
      0
      (if (even? (car lst))
          (car lst)
          0)
      (add (cdr lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpyc_fh6zx.rkt:8:2: if: bad syntax
  in: (if (null? lst) 0 (if (even? (car lst)) (car lst) 0) (add (cdr lst)))
  location...:
   /tmp/tmpyc_fh6zx.rkt:8:2

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n)
    (if (= n 0)
        s
        (rotate (- n 1))
        (string-append (substring s (- n 1) n) (substring s 0 (- n 1)))))
  (rotate 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzwlvv_2z.rkt:18:4: if: bad syntax
  in: (if (= n 0) s (rotate (- n 1)) (string-append (substring s (- n 1) n) (substring s 0 (- n 1))))
  location...:
   /tmp/tmpzwlvv_2z.rkt:18:4

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n)
    (if (= n 0)
        s
        (rotate (- n 1))
        (string-append (substring s (- n 1) n) (substring s 0 (- n 1)))))
  (rotate 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzwlvv_2z.rkt:18:4: if: bad syntax
  in: (if (= n 0) s (rotate (- n 1)) (string-append (substring s (- n 1) n) (substring s 0 (- n 1))))
  location...:
   /tmp/tmpzwlvv_2z.rkt:18:4

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n)
    (if (= n 0)
        s
        (rotate (- n 1))
        (string-append (substring s (- n 1) n) (substring s 0 (- n 1)))))
  (rotate 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzwlvv_2z.rkt:18:4: if: bad syntax
  in: (if (= n 0) s (rotate (- n 1)) (string-append (substring s (- n 1) n) (substring s 0 (- n 1))))
  location...:
   /tmp/tmpzwlvv_2z.rkt:18:4

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (cond
    [(= n 4) #f]
    [(= n 6) #f]
    [(= n 8) #t]
    [(= n 10) #f]
    [(= n 12) #t]
    [(= n 14) #f]
    [(= n 16) #t]
    [(= n 18) #f]
    [(= n 20) #t]
    [(= n 22) #f]
    [(= n 24) #t]
    [(= n 26) #f]
    [(= n 28) #t]
    [(= n 30) #f]
    [(= n 32) #t]
    [(= n 34) #f]
    [(= n 36) #t]
    [(= n 38) #f]
    [(= n 40) #t]
    [(= n 42) #f]
    [(= n 44) #t]
    [(= n 46) #f]
    [(= n 48) #t]
    [(= n 50) #f]
    [(= n 52) #t]
    [(= n 54) #f]
    [(= n 56) #t]
    [(= n 58) #f]
    [(= n 60) #t]
    [(= n 62) #f]
    [(= n 64) #t]
    [(= n 66) #f]
    [(= n 68) #t]
    [(= n 70) #f]
    [(= n 72) #t]
    [(= n 74) #f]
    [(= n 76) #t]
    [(= n 78) #f]
    [(= n 80) #t]
    [(= n 82) #f]
    [(= n 84) #t]
    [(= n 86) #f]
    [(= n 88) #t]
    [(= n 90) #f]
    [(= n 92) #t]
    [(= n 94) #f]
    [(= n 96) #t]
    [(= n 98) #f]
    [(= n 100) #t]
    [(= n 102) #f]
    [(= n 104) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp1i3yc7ld.rkt:63:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(equal? (first brackets) ")") #f]
    [else (correct_bracketing (rest brackets))]))
```

## Exercise 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp2d36g6uu.rkt:20:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else
           (define (is_divisible? n d)
             (if (= d 1)
                 #f
                 (if (= (remainder n d) 0)
                     #t
                     (is_divisible? n (- d 1)))))
           (is_divisible? n (- n 1)))))
  (define (is_multiply_prime? a)
    (cond ((= a 1) #f)
          ((= a 2) #f)
          ((= a 3) #f)
          ((= a 4) #f)
          ((= a 5) #f)
          ((= a 6) #t)
          ((= a 7) #f)
          ((= a 8) #f)
          ((= a 9) #f)
          ((= a 10) #t)
          ((= a 11) #f)
          ((= a 12) #t)
          ((= a 13) #f)
          ((= a 14) #f)
          ((= a 15) #t)
          ((= a 16) #f)
          ((= a 17) #f)
          ((= a 18) #t)
          ((= a 19) #f)
          ((= a 20) #t)
          ((= a 21) #f)
          ((= a 22) #f)
          ((= a 23) #f)
          ((= a 24) #t)
          ((= a 25) #f)
          ((= a 26) #f)
          ((= a 27) #t)
          ((= a 28) #f)
          ((= a 29) #f)
          ((= a 30) #t)
          ((= a 31) #f)
          ((= a 32) #f)
          ((= a 33) #f)
          ((= a 34) #f)
          ((= a 35) #t)
          ((= a 36) #t)
          ((= a 37) #f)
          ((= a 38) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp2n09l2hu.rkt:61:20: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_117_select_words --------
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")
(define (select_words s n)
  (define (is_consonant c)
    (member c '(#\b #\c #\d #\f #\g #\h #\j #\k #\l #\m #
                #
                n #\p #\q #\r #\s #\t #\v #\w #\x #\y #\z)))
  (define (count-consonants w)
    (cond ((null? w) 0)
          ((is_consonant (car w)) (+ 1 (count-consonants (cdr w))))
          (else (count-consonants (cdr w)))))
  (define (select-words-iter ws)
    (cond ((null? ws) '())
          ((= n (count-consonants (car ws)))
           (cons (car ws) (select-words-iter (cdr ws))))
          (else (select-words-iter (cdr ws)))))
  (select-words-iter (string-split s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-equal? (candidate "Mary had a little lamb" 4) (list "little"))
    (check-equal? (candidate "Mary had a little lamb" 3) (list "Mary" "lamb"))
    (check-equal? (candidate "simple white space" 2) (list ))
    (check-equal? (candidate "Hello world" 4) (list "world"))
    (check-equal? (candidate "Uncle sam" 3) (list "Uncle"))
    (check-equal? (candidate "" 4) (list ))
    (check-equal? (candidate "a b c d e f" 1) (list "b" "c" "d" "f"))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp3ou6am9k.rkt:21:56: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (quotient n 10)))]))
  (define (is-prime? n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(= n 3) #t]
      [(= n 5) #t]
      [(= n 7) #t]
      [(= n 11) #t]
      [(= n 13) #t]
      [(= n 17) #t]
      [(= n 19) #t]
      [(= n 23) #t]
      [(= n 29) #t]
      [(= n 31) #t]
      [(= n 37) #t]
      [(= n 41) #t]
      [(= n 43) #t]
      [(= n 47) #t]
      [(= n 53) #t]
      [(= n 59) #t]
      [(= n 61) #t]
      [(= n 67) #t]
      [(= n 71) #t]
      [(= n 73) #t]
      [(= n 79) #t]
      [(= n 83) #t]
      [(= n 89) #t]
      [(= n 97) #t]
      [(= n 101) #t]
      [(= n 103) #t]
      [(= n 107) #t]
      [(= n 109) #t]
      [(= n 113) #t]
      [(= n 127) #t]
      [(= n 131) #t]
      [(= n 137) #t]
      [(= n 139) #t]
      [(= n 149) #t]
      [(= n 151) #t]
      [(= n 157) #t]
      [(= n 163) #t]
      [(= n 167) #t]
      [(= n 173) #t]
      [(= n 179) #t]
      [(= n 181) #t]
      [(= n 191) #t]
      [(= n 193) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp3qz6uz_t.rkt:69:17: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 5) #t]
    [(= n 7) #t]
    [(= n 11) #t]
    [(= n 13) #t]
    [(= n 17) #t]
    [(= n 19) #t]
    [(= n 23) #t]
    [(= n 29) #t]
    [(= n 31) #t]
    [(= n 37) #t]
    [(= n 41) #t]
    [(= n 43) #t]
    [(= n 47) #t]
    [(= n 53) #t]
    [(= n 59) #t]
    [(= n 61) #t]
    [(= n 67) #t]
    [(= n 71) #t]
    [(= n 73) #t]
    [(= n 79) #t]
    [(= n 83) #t]
    [(= n 89) #t]
    [(= n 97) #t]
    [(= n 101) #t]
    [(= n 103) #t]
    [(= n 107) #t]
    [(= n 109) #t]
    [(= n 113) #t]
    [(= n 127) #t]
    [(= n 131) #t]
    [(= n 137) #t]
    [(= n 139) #t]
    [(= n 149) #t]
    [(= n 151) #t]
    [(= n 157) #t]
    [(= n 163) #t]
    [(= n 167) #t]
    [(= n 173) #t]
    [(= n 179) #t]
    [(= n 181) #t]
    [(= n 191) #t]
    [(= n 193) #t]
    [(= n 197) #t]
    [(= n 199) #t]
    [(= n 211) #t]
    [(= n 223) #t]
    [(= n 227) #t]
    [(= n 229) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp4qoq03xw.rkt:70:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 5) #t]
    [(= n 7) #t]
    [(= n 11) #t]
    [(= n 13) #t]
    [(= n 17) #t]
    [(= n 19) #t]
    [(= n 23) #t]
    [(= n 29) #t]
    [(= n 31) #t]
    [(= n 37) #t]
    [(= n 41) #t]
    [(= n 43) #t]
    [(= n 47) #t]
    [(= n 53) #t]
    [(= n 59) #t]
    [(= n 61) #t]
    [(= n 67) #t]
    [(= n 71) #t]
    [(= n 73) #t]
    [(= n 79) #t]
    [(= n 83) #t]
    [(= n 89) #t]
    [(= n 97) #t]
    [(= n 101) #t]
    [(= n 103) #t]
    [(= n 107) #t]
    [(= n 109) #t]
    [(= n 113) #t]
    [(= n 127) #t]
    [(= n 131) #t]
    [(= n 137) #t]
    [(= n 139) #t]
    [(= n 149) #t]
    [(= n 151) #t]
    [(= n 157) #t]
    [(= n 163) #t]
    [(= n 167) #t]
    [(= n 173) #t]
    [(= n 179) #t]
    [(= n 181) #t]
    [(= n 191) #t]
    [(= n 193) #t]
    [(= n 197) #t]
    [(= n 199) #t]
    [(= n 211) #t]
    [(= n 223) #t]
    [(= n 227) #t]
    [(= n 229) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp4qoq03xw.rkt:70:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 5) #t]
    [(= n 7) #t]
    [(= n 11) #t]
    [(= n 13) #t]
    [(= n 17) #t]
    [(= n 19) #t]
    [(= n 23) #t]
    [(= n 29) #t]
    [(= n 31) #t]
    [(= n 37) #t]
    [(= n 41) #t]
    [(= n 43) #t]
    [(= n 47) #t]
    [(= n 53) #t]
    [(= n 59) #t]
    [(= n 61) #t]
    [(= n 67) #t]
    [(= n 71) #t]
    [(= n 73) #t]
    [(= n 79) #t]
    [(= n 83) #t]
    [(= n 89) #t]
    [(= n 97) #t]
    [(= n 101) #t]
    [(= n 103) #t]
    [(= n 107) #t]
    [(= n 109) #t]
    [(= n 113) #t]
    [(= n 127) #t]
    [(= n 131) #t]
    [(= n 137) #t]
    [(= n 139) #t]
    [(= n 149) #t]
    [(= n 151) #t]
    [(= n 157) #t]
    [(= n 163) #t]
    [(= n 167) #t]
    [(= n 173) #t]
    [(= n 179) #t]
    [(= n 181) #t]
    [(= n 191) #t]
    [(= n 193) #t]
    [(= n 197) #t]
    [(= n 199) #t]
    [(= n 211) #t]
    [(= n 223) #t]
    [(= n 227) #t]
    [(= n 229) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp4qoq03xw.rkt:70:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 5) #t]
    [(= n 7) #t]
    [(= n 11) #t]
    [(= n 13) #t]
    [(= n 17) #t]
    [(= n 19) #t]
    [(= n 23) #t]
    [(= n 29) #t]
    [(= n 31) #t]
    [(= n 37) #t]
    [(= n 41) #t]
    [(= n 43) #t]
    [(= n 47) #t]
    [(= n 53) #t]
    [(= n 59) #t]
    [(= n 61) #t]
    [(= n 67) #t]
    [(= n 71) #t]
    [(= n 73) #t]
    [(= n 79) #t]
    [(= n 83) #t]
    [(= n 89) #t]
    [(= n 97) #t]
    [(= n 101) #t]
    [(= n 103) #t]
    [(= n 107) #t]
    [(= n 109) #t]
    [(= n 113) #t]
    [(= n 127) #t]
    [(= n 131) #t]
    [(= n 137) #t]
    [(= n 139) #t]
    [(= n 149) #t]
    [(= n 151) #t]
    [(= n 157) #t]
    [(= n 163) #t]
    [(= n 167) #t]
    [(= n 173) #t]
    [(= n 179) #t]
    [(= n 181) #t]
    [(= n 191) #t]
    [(= n 193) #t]
    [(= n 197) #t]
    [(= n 199) #t]
    [(= n 211) #t]
    [(= n 223) #t]
    [(= n 227) #t]
    [(= n 229) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp4qoq03xw.rkt:70:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(zero? (modulo n i)) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (word-lengths sentence)
    (for/list ([word (in-list (string-split sentence))])
      (string-length word)))
  (define (prime-word-lengths sentence)
    (for/list ([length (in-list (word-lengths sentence))])
      (if (is-prime? length) length #f)))
  (define (prime-words sentence)
    (for/list ([word (in-list (string-split sentence))])
      (if (member (string-length word) (prime-word-lengths sentence)) word #f)))
  (string-join (prime-words sentence) " "))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp5_88wmbr.rkt:37:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))
```

## Задача 2

Да се дефинира функция `(skjkasdkd lst)`, която приема списък от цели числа и връща списък от цели числа, които са прости и по-големи от най-голямото просто число в дадения списък.

Примери:

```racket
>>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
'(181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp5k5u07gy.rkt:37:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (cond ((= n 1) i)
          ((and (prime? i) (= (fib n) i)) i)
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 1))
```

### Problem 6

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp62xa8t_u.rkt:32:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_114_minSubArraySum --------
#lang racket

;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
;; of nums.
;; Example
;; >>> (minSubArraySum (list 2 3 4 1 2 4))
;; 1
;; >>> (minSubArraySum (list -1 -2 -3))
;; -6
(define (minSubArraySum nums)
  (define (minSubArraySum-helper nums min-sum)
    (if (null? nums)
        min-sum
        (let ([sum (apply + nums)])
          (minSubArraySum-helper (cdr nums) (min sum min-sum)))))
  (minSubArraySum-helper nums (apply + nums)))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minSubArraySum))
    (check-equal? (candidate (list 2 3 4 1 2 4)) 1)
    (check-equal? (candidate (list -1 -2 -3)) -6)
    (check-equal? (candidate (list -1 -2 -3 2 -10)) -14)
    (check-equal? (candidate (list -9999999999999999)) -9999999999999999)
    (check-equal? (candidate (list 0 10 20 1000000)) 0)
    (check-equal? (candidate (list -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 100 -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 10 11 13 8 3 4)) 3)
    (check-equal? (candidate (list 100 -33 32 -1 0 -2)) -33)
    (check-equal? (candidate (list -10)) -10)
    (check-equal? (candidate (list 7)) 7)
    (check-equal? (candidate (list 1 -1)) -1)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp6hysru9g.rkt:19:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (< i 2)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (sqrt n)))
  (define (prime_fib n i)
    (if (= n 1)
        (fib i)
        (if (prime? (fib i))
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))
```

### Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp77kxfv_n.rkt:36:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_6_parse_nested_parens --------
#lang racket

;; Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
;; For each of the group, output the deepest level of nesting of parentheses.
;; E.g. (()()) has maximum two levels of nesting while ((())) has three.
;; >>> (parse_nested_parens "(()()) ((())) () ((())()())")
;; (list 2 3 1 3)
(define (parse_nested_parens paren_string)
  (define (parse_parens paren_string)
    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])
      (cond
        [(empty? paren_string) (list paren_count max_paren_count)]
        [(char=? (first paren_string) #\()
         (loop (rest paren_string) (+ paren_count 1) (max paren_count max_paren_count))]
        [(char=? (first paren_string) #\))
         (loop (rest paren_string) (- paren_count 1) (max paren_count max_paren_count))]
        [else (loop (rest paren_string) paren_count max_paren_count)])))
  (for/list ([paren_group (in-list (string-split paren_string))])
    (let ([paren_counts (parse_parens paren_group)])
      (first (rest paren_counts)))))
```

### Problem 5:

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_nested_parens))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list 2 3 1 3))
    (check-equal? (candidate "() (()) ((())) (((())))") (list 1 2 3 4))
    (check-equal? (candidate "(()(())((())))") (list 4))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp8lovrp34.rkt:23:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (cond
    [(= n 0) #t]
    [(= n 2) #f]
    [(= n 4) #t]
    [(= n 6) #f]
    [(= n 8) #t]
    [(= n 10) #f]
    [(= n 12) #t]
    [(= n 14) #f]
    [(= n 16) #t]
    [(= n 18) #f]
    [(= n 20) #t]
    [(= n 22) #f]
    [(= n 24) #t]
    [(= n 26) #f]
    [(= n 28) #t]
    [(= n 30) #f]
    [(= n 32) #t]
    [(= n 34) #f]
    [(= n 36) #t]
    [(= n 38) #f]
    [(= n 40) #t]
    [(= n 42) #f]
    [(= n 44) #t]
    [(= n 46) #f]
    [(= n 48) #t]
    [(= n 50) #f]
    [(= n 52) #t]
    [(= n 54) #f]
    [(= n 56) #t]
    [(= n 58) #f]
    [(= n 60) #t]
    [(= n 62) #f]
    [(= n 64) #t]
    [(= n 66) #f]
    [(= n 68) #t]
    [(= n 70) #f]
    [(= n 72) #t]
    [(= n 74) #f]
    [(= n 76) #t]
    [(= n 78) #f]
    [(= n 80) #t]
    [(= n 82) #f]
    [(= n 84) #t]
    [(= n 86) #f]
    [(= n 88) #t]
    [(= n 90) #f]
    [(= n 92) #t]
    [(= n 94) #f]
    [(= n 96) #t]
    [(= n 98) #f]
    [(= n 100) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp8pmjinyf.rkt:63:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (cond
    [(= n 0) #t]
    [(= n 2) #f]
    [(= n 4) #t]
    [(= n 6) #f]
    [(= n 8) #t]
    [(= n 10) #f]
    [(= n 12) #t]
    [(= n 14) #f]
    [(= n 16) #t]
    [(= n 18) #f]
    [(= n 20) #t]
    [(= n 22) #f]
    [(= n 24) #t]
    [(= n 26) #f]
    [(= n 28) #t]
    [(= n 30) #f]
    [(= n 32) #t]
    [(= n 34) #f]
    [(= n 36) #t]
    [(= n 38) #f]
    [(= n 40) #t]
    [(= n 42) #f]
    [(= n 44) #t]
    [(= n 46) #f]
    [(= n 48) #t]
    [(= n 50) #f]
    [(= n 52) #t]
    [(= n 54) #f]
    [(= n 56) #t]
    [(= n 58) #f]
    [(= n 60) #t]
    [(= n 62) #f]
    [(= n 64) #t]
    [(= n 66) #f]
    [(= n 68) #t]
    [(= n 70) #f]
    [(= n 72) #t]
    [(= n 74) #f]
    [(= n 76) #t]
    [(= n 78) #f]
    [(= n 80) #t]
    [(= n 82) #f]
    [(= n 84) #t]
    [(= n 86) #f]
    [(= n 88) #t]
    [(= n 90) #f]
    [(= n 92) #t]
    [(= n 94) #f]
    [(= n 96) #t]
    [(= n 98) #f]
    [(= n 100) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp8pmjinyf.rkt:63:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (cond
    [(= n 0) #t]
    [(= n 2) #f]
    [(= n 4) #t]
    [(= n 6) #f]
    [(= n 8) #t]
    [(= n 10) #f]
    [(= n 12) #t]
    [(= n 14) #f]
    [(= n 16) #t]
    [(= n 18) #f]
    [(= n 20) #t]
    [(= n 22) #f]
    [(= n 24) #t]
    [(= n 26) #f]
    [(= n 28) #t]
    [(= n 30) #f]
    [(= n 32) #t]
    [(= n 34) #f]
    [(= n 36) #t]
    [(= n 38) #f]
    [(= n 40) #t]
    [(= n 42) #f]
    [(= n 44) #t]
    [(= n 46) #f]
    [(= n 48) #t]
    [(= n 50) #f]
    [(= n 52) #t]
    [(= n 54) #f]
    [(= n 56) #t]
    [(= n 58) #f]
    [(= n 60) #t]
    [(= n 62) #f]
    [(= n 64) #t]
    [(= n 66) #f]
    [(= n 68) #t]
    [(= n 70) #f]
    [(= n 72) #t]
    [(= n 74) #f]
    [(= n 76) #t]
    [(= n 78) #f]
    [(= n 80) #t]
    [(= n 82) #f]
    [(= n 84) #t]
    [(= n 86) #f]
    [(= n 88) #t]
    [(= n 90) #f]
    [(= n 92) #t]
    [(= n 94) #f]
    [(= n 96) #t]
    [(= n 98) #f]
    [(= n 100) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp8pmjinyf.rkt:63:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (cond
    [(= n 0) #t]
    [(= n 2) #f]
    [(= n 4) #t]
    [(= n 6) #f]
    [(= n 8) #t]
    [(= n 10) #f]
    [(= n 12) #t]
    [(= n 14) #f]
    [(= n 16) #t]
    [(= n 18) #f]
    [(= n 20) #t]
    [(= n 22) #f]
    [(= n 24) #t]
    [(= n 26) #f]
    [(= n 28) #t]
    [(= n 30) #f]
    [(= n 32) #t]
    [(= n 34) #f]
    [(= n 36) #t]
    [(= n 38) #f]
    [(= n 40) #t]
    [(= n 42) #f]
    [(= n 44) #t]
    [(= n 46) #f]
    [(= n 48) #t]
    [(= n 50) #f]
    [(= n 52) #t]
    [(= n 54) #f]
    [(= n 56) #t]
    [(= n 58) #f]
    [(= n 60) #t]
    [(= n 62) #f]
    [(= n 64) #t]
    [(= n 66) #f]
    [(= n 68) #t]
    [(= n 70) #f]
    [(= n 72) #t]
    [(= n 74) #f]
    [(= n 76) #t]
    [(= n 78) #f]
    [(= n 80) #t]
    [(= n 82) #f]
    [(= n 84) #t]
    [(= n 86) #f]
    [(= n 88) #t]
    [(= n 90) #f]
    [(= n 92) #t]
    [(= n 94) #f]
    [(= n 96) #t]
    [(= n 98) #f]
    [(= n 100) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp8pmjinyf.rkt:63:15: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_159_eat --------
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;; the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;; the number of carrots that you have eaten.
;; @need : integer
;; the number of carrots that you need to eat.
;; @remaining : integer
;; the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)
(define (eat number need remaining)
  (list (+ number need) (- remaining need)))
```

## Test

```racket
(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-equal? (candidate 5 6 10) (list 11 4))
    (check-equal? (candidate 4 8 9) (list 12 1))
    (check-equal? (candidate 1 10 10) (list 11 0))
    (check-equal? (candidate 2 11 5) (list 7 0))
    (check-equal? (candidate 4 5 7) (list 9 2))
    (check-equal? (candidate 4 5 1) (list 5 0))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp8y7pjrsf.rkt:33:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 4) #f]
    [(= a 5) #f]
    [(= a 6) #t]
    [(= a 7) #f]
    [(= a 8) #f]
    [(= a 9) #f]
    [(= a 10) #f]
    [(= a 11) #f]
    [(= a 12) #t]
    [(= a 13) #f]
    [(= a 14) #f]
    [(= a 15) #t]
    [(= a 16) #f]
    [(= a 17) #f]
    [(= a 18) #t]
    [(= a 19) #f]
    [(= a 20) #t]
    [(= a 21) #f]
    [(= a 22) #f]
    [(= a 23) #f]
    [(= a 24) #t]
    [(= a 25) #f]
    [(= a 26) #f]
    [(= a 27) #f]
    [(= a 28) #f]
    [(= a 29) #f]
    [(= a 30) #t]
    [(= a 31) #f]
    [(= a 32) #f]
    [(= a 33) #f]
    [(= a 34) #f]
    [(= a 35) #t]
    [(= a 36) #t]
    [(= a 37) #f]
    [(= a 38) #f]
    [(= a 39) #f]
    [(= a 40) #t]
    [(= a 41) #f]
    [(= a 42) #f]
    [(= a 43) #f]
    [(= a 44) #f]
    [(= a 45) #t]
    [(= a 46) #f]
    [(= a 47) #f]
    [(= a 48) #t]
    [(= a 49) #f]
    [(= a 50) #t]
    [(= a 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpaaha9lfh.rkt:62:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 4) #f]
    [(= a 5) #f]
    [(= a 6) #t]
    [(= a 7) #f]
    [(= a 8) #f]
    [(= a 9) #f]
    [(= a 10) #f]
    [(= a 11) #f]
    [(= a 12) #t]
    [(= a 13) #f]
    [(= a 14) #f]
    [(= a 15) #t]
    [(= a 16) #f]
    [(= a 17) #f]
    [(= a 18) #t]
    [(= a 19) #f]
    [(= a 20) #t]
    [(= a 21) #f]
    [(= a 22) #f]
    [(= a 23) #f]
    [(= a 24) #t]
    [(= a 25) #f]
    [(= a 26) #f]
    [(= a 27) #f]
    [(= a 28) #f]
    [(= a 29) #f]
    [(= a 30) #t]
    [(= a 31) #f]
    [(= a 32) #f]
    [(= a 33) #f]
    [(= a 34) #f]
    [(= a 35) #t]
    [(= a 36) #t]
    [(= a 37) #f]
    [(= a 38) #f]
    [(= a 39) #f]
    [(= a 40) #t]
    [(= a 41) #f]
    [(= a 42) #f]
    [(= a 43) #f]
    [(= a 44) #f]
    [(= a 45) #t]
    [(= a 46) #f]
    [(= a 47) #f]
    [(= a 48) #t]
    [(= a 49) #f]
    [(= a 50) #t]
    [(= a 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpaaha9lfh.rkt:62:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 4) #f]
    [(= a 5) #f]
    [(= a 6) #t]
    [(= a 7) #f]
    [(= a 8) #f]
    [(= a 9) #f]
    [(= a 10) #f]
    [(= a 11) #f]
    [(= a 12) #t]
    [(= a 13) #f]
    [(= a 14) #f]
    [(= a 15) #t]
    [(= a 16) #f]
    [(= a 17) #f]
    [(= a 18) #t]
    [(= a 19) #f]
    [(= a 20) #t]
    [(= a 21) #f]
    [(= a 22) #f]
    [(= a 23) #f]
    [(= a 24) #t]
    [(= a 25) #f]
    [(= a 26) #f]
    [(= a 27) #f]
    [(= a 28) #f]
    [(= a 29) #f]
    [(= a 30) #t]
    [(= a 31) #f]
    [(= a 32) #f]
    [(= a 33) #f]
    [(= a 34) #f]
    [(= a 35) #t]
    [(= a 36) #t]
    [(= a 37) #f]
    [(= a 38) #f]
    [(= a 39) #f]
    [(= a 40) #t]
    [(= a 41) #f]
    [(= a 42) #f]
    [(= a 43) #f]
    [(= a 44) #f]
    [(= a 45) #t]
    [(= a 46) #f]
    [(= a 47) #f]
    [(= a 48) #t]
    [(= a 49) #f]
    [(= a 50) #t]
    [(= a 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpaaha9lfh.rkt:62:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_141_file_name_check --------
#lang racket

;; Create a function which takes a string representing a file's name, and returns
;; 'Yes' if the the file's name is valid, and returns 'No' otherwise.
;; A file's name is considered to be valid if and only if all the following conditions 
;; are met:
;; - There should not be more than three digits ('0'-'9') in the file's name.
;; - The file's name contains exactly one dot '.'
;; - The substring before the dot should not be empty, and it starts with a letter from 
;; the latin alphapet ('a'-'z' and 'A'-'Z').
;; - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
;; Examples:
;; >>> (file_name_check "example.txt")
;; "Yes"
;; >>> (file_name_check "1example.dll")
;; "No"
(define (file_name_check file_name)
  (let ([dot_pos (string-index file_name ".")]
        [substr-before (substring file_name 0 dot_pos)]
        [substr-after (substring file_name (+ dot_pos 1))])
    (cond
      [(or (string-contains file_name "..")
           (string-contains file_name "...")
           (string-contains file_name "....")
           (string-contains file_name "....."))
       "No"]
      [(or (string-contains file_name "0")
           (string-contains file_name "1")
           (string-contains file_name "2")
           (string-contains file_name "3")
           (string-contains file_name "4")
           (string-contains file_name "5")
           (string-contains file_name "6")
           (string-contains file_name "7")
           (string-contains file_name "8")
           (string-contains file_name "9"))
       "No"]
      [(or (string-contains file_name "0")
           (string-contains file_name "1")
           (string-contains file_name "2")
           (string-contains file_name "3")
           (string-contains file_name "4")
           (string-contains file_name "5")
           (string-contains file_name "6")
           (string-contains file_name "7")
           (string-contains file_name "8")
           (string-contains file_name "9"))
       "No"]
      [(or (string-contains file_name "0")
           (string-contains file_name "1")
           (string-contains file_name "2")
           (string-contains file_name "3")
           (string-contains file_name "4")
           (string-contains file_name "5")
           (string-contains file_name "6")
           (string-contains file_name "7")
           (string-contains file_name "8
(require rackunit)

(define (test-humaneval) 

  (let (( candidate file_name_check))
    (check-equal? (candidate "example.txt") "Yes")
    (check-equal? (candidate "1example.dll") "No")
    (check-equal? (candidate "s1sdf3.asd") "No")
    (check-equal? (candidate "K.dll") "Yes")
    (check-equal? (candidate "MY16FILE3.exe") "Yes")
    (check-equal? (candidate "His12FILE94.exe") "No")
    (check-equal? (candidate "_Y.txt") "No")
    (check-equal? (candidate "?aREYA.exe") "No")
    (check-equal? (candidate "/this_is_valid.dll") "No")
    (check-equal? (candidate "this_is_valid.wow") "No")
    (check-equal? (candidate "this_is_valid.txt") "Yes")
    (check-equal? (candidate "this_is_valid.txtexe") "No")
    (check-equal? (candidate "#this2_i4s_5valid.ten") "No")
    (check-equal? (candidate "@this1_is6_valid.exe") "No")
    (check-equal? (candidate "this_is_12valid.6exe4.txt") "No")
    (check-equal? (candidate "all.exe.txt") "No")
    (check-equal? (candidate "I563_No.exe") "Yes")
    (check-equal? (candidate "Is3youfault.txt") "Yes")
    (check-equal? (candidate "no_one#knows.dll") "Yes")
    (check-equal? (candidate "1I563_Yes3.exe") "No")
    (check-equal? (candidate "I563_Yes3.txtt") "No")
    (check-equal? (candidate "final..txt") "No")
    (check-equal? (candidate "final132") "No")
    (check-equal? (candidate "_f4indsartal132.") "No")
    (check-equal? (candidate ".txt") "No")
    (check-equal? (candidate "s.") "No")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpajlpawxv.rkt:75:30: read-syntax: bad syntax `#th`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 0) #f]
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 4) #f]
    [(= a 5) #f]
    [(= a 6) #f]
    [(= a 7) #f]
    [(= a 8) #f]
    [(= a 9) #f]
    [(= a 10) #f]
    [(= a 11) #f]
    [(= a 12) #f]
    [(= a 13) #f]
    [(= a 14) #f]
    [(= a 15) #f]
    [(= a 16) #f]
    [(= a 17) #f]
    [(= a 18) #f]
    [(= a 19) #f]
    [(= a 20) #f]
    [(= a 21) #f]
    [(= a 22) #f]
    [(= a 23) #f]
    [(= a 24) #f]
    [(= a 25) #f]
    [(= a 26) #f]
    [(= a 27) #f]
    [(= a 28) #f]
    [(= a 29) #f]
    [(= a 30) #t]
    [(= a 31) #f]
    [(= a 32) #f]
    [(= a 33) #f]
    [(= a 34) #f]
    [(= a 35) #f]
    [(= a 36) #f]
    [(= a 37) #f]
    [(= a 38) #f]
    [(= a 39) #f]
    [(= a 40) #f]
    [(= a 41) #f]
    [(= a 42) #f]
    [(= a 43) #f]
    [(= a 44) #f]
    [(= a 45) #f]
    [(= a 46) #f]
    [(= a 47) #f]
    [(= a 48) #f]
    [(= a 49) #f]
    [(= a 50) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpakwlxsf4.rkt:62:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (prime-helper n (+ i 1)))))
    (prime-helper n 2))
  (define (prime-fib-helper n i)
    (cond ((= i n) (fib i))
          ((and (prime? (fib i)) (prime? (fib (+ i 1)))) (prime-fib-helper n (+ i 1)))
          (else (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))
```

### Problem 4

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpbshrg6q3.rkt:32:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_111_histogram --------
#lang racket

;; Given a string representing a space separated lowercase letters, return a hash
;; of the letter with the most repetition and containing the corresponding count.
;; If several letters have the same occurrence, return all of them.
;; Example:
;; >>> (histogram "a b c")
;; #hash(("a" .  1) ("b" .  1) ("c" .  1))
;; >>> (histogram "a b b a")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "a b c a b")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "b b b b a")
;; #hash(("b" .  4))
;; >>> (histogram "")
;; #hash()
(define (histogram test)
  (define (histogram-helper test max-count)
    (cond [(empty? test) (hash)]
          [(hash-ref (histogram-helper (rest test) max-count) (first test) max-count)
           (hash-set (histogram-helper (rest test) max-count) (first test) (+ 1 (hash-ref (histogram-helper (rest test) max-count) (first test) max-count)))]
          [else (hash-set (histogram-helper (rest test) max-count) (first test) 1)]))
  (histogram-helper (string->list test) 0))
```

### Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate histogram))
    (check-equal? (candidate "a b b a") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c a b") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c d g") #hash(("a" .  1) ("b" .  1) ("c" .  1) ("d" .  1) ("g" .  1)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "b b b b a") #hash(("b" .  4)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "") #hash())
    (check-equal? (candidate "a") #hash(("a" .  1)))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpchcdgesy.rkt:26:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 4) #f]
    [(= a 5) #f]
    [(= a 6) #t]
    [(= a 7) #f]
    [(= a 8) #f]
    [(= a 9) #f]
    [(= a 10) #f]
    [(= a 11) #f]
    [(= a 12) #t]
    [(= a 13) #f]
    [(= a 14) #f]
    [(= a 15) #t]
    [(= a 16) #f]
    [(= a 17) #f]
    [(= a 18) #t]
    [(= a 19) #f]
    [(= a 20) #t]
    [(= a 21) #f]
    [(= a 22) #f]
    [(= a 23) #f]
    [(= a 24) #t]
    [(= a 25) #f]
    [(= a 26) #f]
    [(= a 27) #f]
    [(= a 28) #f]
    [(= a 29) #f]
    [(= a 30) #t]
    [(= a 31) #f]
    [(= a 32) #f]
    [(= a 33) #f]
    [(= a 34) #f]
    [(= a 35) #t]
    [(= a 36) #t]
    [(= a 37) #f]
    [(= a 38) #f]
    [(= a 39) #f]
    [(= a 40) #t]
    [(= a 41) #f]
    [(= a 42) #f]
    [(= a 43) #f]
    [(= a 44) #f]
    [(= a 45) #t]
    [(= a 46) #f]
    [(= a 47) #f]
    [(= a 48) #t]
    [(= a 49) #f]
    [(= a 50) #f]
    [(= a 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpck9n3dk6.rkt:62:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2))
              (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1))
              (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else '()]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (- n 1)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (cond
    [(= (intersection-length interval1) 0) "NO"]
    [(is-prime? (intersection-length interval1)) "YES"]
    [else "NO"]))
```

## Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpcne9m_02.rkt:51:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_43_pairs_sum_to_zero --------
#lang racket

;; pairs_sum_to_zero takes a list of integers as an input.
;; it returns #t if there are two distinct elements in the list that
;; sum to zero, and #f otherwise.
;; >>> (pairs_sum_to_zero (list 1 3 5 0))
;; #f
;; >>> (pairs_sum_to_zero (list 1 3 -2 1))
;; #f
;; >>> (pairs_sum_to_zero (list 1 2 3 7))
;; #f
;; >>> (pairs_sum_to_zero (list 2 4 -5 3 5 7))
;; #t
;; >>> (pairs_sum_to_zero (list 1))
;; #f
(define (pairs_sum_to_zero l)
  (cond
    [(empty? l) #f]
    [(empty? (rest l)) #f]
    [(member (- (first l) (first (rest l))) (rest (rest l))) #t]
    [else (pairs_sum_to_zero (rest l))]))
```

### Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pairs_sum_to_zero))
    (check-equal? (candidate (list 1 3 5 0)) #f)
    (check-equal? (candidate (list 1 3 -2 1)) #f)
    (check-equal? (candidate (list 1 2 3 7)) #f)
    (check-equal? (candidate (list 2 4 -5 3 5 7)) #t)
    (check-equal? (candidate (list 1)) #f)
    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)
    (check-equal? (candidate (list -3 9 -1 3 2 31)) #t)
    (check-equal? (candidate (list -3 9 -1 4 2 30)) #f)
    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpcouk_riu.rkt:24:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_114_minSubArraySum --------
#lang racket

;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
;; of nums.
;; Example
;; >>> (minSubArraySum (list 2 3 4 1 2 4))
;; 1
;; >>> (minSubArraySum (list -1 -2 -3))
;; -6
(define (minSubArraySum nums)
  (define (minSubArraySum' nums min-sum)
    (cond
      [(empty? nums) min-sum]
      [(< (first nums) min-sum) (minSubArraySum' (rest nums) (first nums))]
      [else (minSubArraySum' (rest nums) min-sum)]))
  (minSubArraySum' nums (first nums)))
```

## [Problem 5](https://leetcode.com/problems/longest-palindromic-substring/)

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minSubArraySum))
    (check-equal? (candidate (list 2 3 4 1 2 4)) 1)
    (check-equal? (candidate (list -1 -2 -3)) -6)
    (check-equal? (candidate (list -1 -2 -3 2 -10)) -14)
    (check-equal? (candidate (list -9999999999999999)) -9999999999999999)
    (check-equal? (candidate (list 0 10 20 1000000)) 0)
    (check-equal? (candidate (list -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 100 -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 10 11 13 8 3 4)) 3)
    (check-equal? (candidate (list 100 -33 32 -1 0 -2)) -33)
    (check-equal? (candidate (list -10)) -10)
    (check-equal? (candidate (list 7)) 7)
    (check-equal? (candidate (list 1 -1)) -1)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpcp6acrqq.rkt:19:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (if (string-contains s #\a)
      (string-map (lambda (c) (if (char-alphabetic? c)
                                  (char-upcase c)
                                  (char-downcase c)))
                  s)
      (string-reverse s)))
```

### [Reverse the order of words in a string](https://www.codewars.com/kata/reverse-the-order-of-words-in-a-string)

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpf1skrt6p.rkt:24:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_159_eat --------
#lang racket

;; You're a hungry rabbit, and you already have eaten a certain number of carrots,
;; but now you need to eat more carrots to complete the day's meals.
;; you should return a list of [ total number of eaten carrots after your meals,
;; the number of carrots left after your meals ]
;; if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
;; Example:
;; >>> (eat 5 6 10)
;; (list 11 4)
;; >>> (eat 4 8 9)
;; (list 12 1)
;; >>> (eat 1 10 10)
;; (list 11 0)
;; >>> (eat 2 11 5)
;; (list 7 0)
;; Variables:
;; @number : integer
;; the number of carrots that you have eaten.
;; @need : integer
;; the number of carrots that you need to eat.
;; @remaining : integer
;; the number of remaining carrots thet exist in stock
;; Constrain:
;; * 0 <= number <= 1000
;; * 0 <= need <= 1000
;; * 0 <= remaining <= 1000
;; Have fun :)
(define (eat number need remaining)
  (list (+ number need) (- remaining need)))
```

## Test

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate eat))
    (check-equal? (candidate 5 6 10) (list 11 4))
    (check-equal? (candidate 4 8 9) (list 12 1))
    (check-equal? (candidate 1 10 10) (list 11 0))
    (check-equal? (candidate 2 11 5) (list 7 0))
    (check-equal? (candidate 4 5 7) (list 9 2))
    (check-equal? (candidate 4 5 1) (list 5 0))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpfewhelx_.rkt:33:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_117_select_words --------
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")
(define (select_words s n)
  (define (is_consonant c)
    (member c '(#\b #\c #\d #\f #\g #\h #\j #\k #\l #\m #
                #
                n #\p #\q #\r #\s #\t #\v #\w #\x #\y #\z)))
  (define (count-consonants s)
    (if (empty? s)
        0
        (+ (if (is_consonant (first s)) 1 0)
           (count-consonants (rest s)))))
  (define (select-words s n)
    (cond
      [(empty? s) '()]
      [(= n (count-consonants (first s)))
       (cons (first s) (select-words (rest s) n))]
      [else (select-words (rest s) n)]))
  (select-words (string-split s #\space) n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-equal? (candidate "Mary had a little lamb" 4) (list "little"))
    (check-equal? (candidate "Mary had a little lamb" 3) (list "Mary" "lamb"))
    (check-equal? (candidate "simple white space" 2) (list ))
    (check-equal? (candidate "Hello world" 4) (list "world"))
    (check-equal? (candidate "Uncle sam" 3) (list "Uncle"))
    (check-equal? (candidate "" 4) (list ))
    (check-equal? (candidate "a b c d e f" 1) (list "b" "c" "d" "f"))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpfm0tiq3s.rkt:21:56: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (dec-to-bin n)
    (cond ((= n 0) '())
          (else (cons (remainder n 2) (dec-to-bin (quotient n 2))))))
  (define (sum-digits lst)
    (cond ((null? lst) 0)
          (else (+ (car lst) (sum-digits (cdr lst))))))
  (number->string (sum-digits (dec-to-bin N))))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpfypm9h9g.rkt:26:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (= n 0)
      1
      (let ([m (modulo (* 2 (modp (- n 1) p)) p)])
        (if (= m 0)
            p
            m))))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpgip_5ao3.rkt:23:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (solve-iter N acc)
    (cond
      [(= N 0) acc]
      [else (solve-iter (/ N 2) (string (remainder N 2) acc))]))
  (solve-iter N ""))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpgm25hom3.rkt:24:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (sort l)
    (cond
      [(empty? l) empty]
      [else (insert (first l) (sort (rest l)))]))
  (define (insert n l)
    (cond
      [(empty? l) (list n)]
      [(< n (first l)) (cons n l)]
      [else (cons (first l) (insert n (rest l)))]))
  (define (middle l)
    (cond
      [(empty? l) empty]
      [(empty? (rest l)) (first l)]
      [else (middle (rest l))]))
  (define (middle-two l)
    (cond
      [(empty? l) empty]
      [(empty? (rest l)) empty]
      [(empty? (rest (rest l))) (list (first l) (first (rest l)))]
      [else (middle-two (rest l))]))
  (cond
    [(empty? l) empty]
    [(empty? (rest l)) (first l)]
    [(empty? (rest (rest l))) (/ (+ (first l) (first (rest l))) 2)]
    [else (cond
            [(even? (length l)) (/ (+ (first (middle-two (sort l))) (first (rest (middle-two (sort l))))) 2)]
            [else (first (middle (sort l)))])]))
```

## Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpi3m4vtuz.rkt:38:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_141_file_name_check --------
#lang racket

;; Create a function which takes a string representing a file's name, and returns
;; 'Yes' if the the file's name is valid, and returns 'No' otherwise.
;; A file's name is considered to be valid if and only if all the following conditions 
;; are met:
;; - There should not be more than three digits ('0'-'9') in the file's name.
;; - The file's name contains exactly one dot '.'
;; - The substring before the dot should not be empty, and it starts with a letter from 
;; the latin alphapet ('a'-'z' and 'A'-'Z').
;; - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
;; Examples:
;; >>> (file_name_check "example.txt")
;; "Yes"
;; >>> (file_name_check "1example.dll")
;; "No"
(define (file_name_check file_name)
  (define (check_file_name_helper file_name)
    (cond
      [(empty? file_name) #t]
      [(char-alphabetic? (first file_name)) (check_file_name_helper (rest file_name))]
      [(char-numeric? (first file_name)) (check_file_name_helper (rest file_name))]
      [(char=? (first file_name) #\.) (check_file_name_helper (rest file_name))]
      [else #f]))
  (define (count_digits file_name)
    (cond
      [(empty? file_name) 0]
      [(char-numeric? (first file_name)) (+ 1 (count_digits (rest file_name)))]
      [else (count_digits (rest file_name))]))
  (define (find_dot file_name)
    (cond
      [(empty? file_name) #f]
      [(char=? (first file_name) #\.) #t]
      [else (find_dot (rest file_name))]))
  (define (find_extension file_name)
    (cond
      [(empty? file_name) #f]
      [(char=? (first file_name) #\.) (rest file_name)]
      [else (find_extension (rest file_name))]))
  (define (check_extension file_name)
    (cond
      [(empty? file_name) #f]
      [(string=? (first file_name) "txt") #t]
      [(string=? (first file_name) "exe") #t]
      [(string=? (first file_name) "dll") #t]
      [else #f]))
  (cond
    [(empty? file_name) "No"]
    [(check_file_name_helper file_name)
     (cond
       [(<= (count_digits file_name) 3)
        (cond
          [(find_dot file_name)
           (cond
             [(check_extension (find_extension file_name)) "Yes
(require rackunit)

(define (test-humaneval) 

  (let (( candidate file_name_check))
    (check-equal? (candidate "example.txt") "Yes")
    (check-equal? (candidate "1example.dll") "No")
    (check-equal? (candidate "s1sdf3.asd") "No")
    (check-equal? (candidate "K.dll") "Yes")
    (check-equal? (candidate "MY16FILE3.exe") "Yes")
    (check-equal? (candidate "His12FILE94.exe") "No")
    (check-equal? (candidate "_Y.txt") "No")
    (check-equal? (candidate "?aREYA.exe") "No")
    (check-equal? (candidate "/this_is_valid.dll") "No")
    (check-equal? (candidate "this_is_valid.wow") "No")
    (check-equal? (candidate "this_is_valid.txt") "Yes")
    (check-equal? (candidate "this_is_valid.txtexe") "No")
    (check-equal? (candidate "#this2_i4s_5valid.ten") "No")
    (check-equal? (candidate "@this1_is6_valid.exe") "No")
    (check-equal? (candidate "this_is_12valid.6exe4.txt") "No")
    (check-equal? (candidate "all.exe.txt") "No")
    (check-equal? (candidate "I563_No.exe") "Yes")
    (check-equal? (candidate "Is3youfault.txt") "Yes")
    (check-equal? (candidate "no_one#knows.dll") "Yes")
    (check-equal? (candidate "1I563_Yes3.exe") "No")
    (check-equal? (candidate "I563_Yes3.txtt") "No")
    (check-equal? (candidate "final..txt") "No")
    (check-equal? (candidate "final132") "No")
    (check-equal? (candidate "_f4indsartal132.") "No")
    (check-equal? (candidate ".txt") "No")
    (check-equal? (candidate "s.") "No")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpi8xhfjv6.rkt:73:30: read-syntax: bad syntax `#th`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_117_select_words --------
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")
(define (select_words s n)
  (define (count-consonants s)
    (define (is-consonant? c)
      (member c '(#\b #\c #\d #\f #\g #\h #\j #\k #\l #\m #
                  #
                  n #\p #\q #\r #\s #\t #\v #\w #\x #\y #\z)))
    (define (count-consonants-iter s n)
      (cond ((null? s) n)
            ((is-consonant? (car s)) (count-consonants-iter (cdr s) (+ n 1)))
            (else (count-consonants-iter (cdr s) n))))
    (count-consonants-iter s 0))
  (define (select-words-iter s n result)
    (cond ((null? s) result)
          ((equal? n (count-consonants (car s))) (select-words-iter (cdr s) n (append result (list (car s)))))
          (else (select-words-iter (cdr s) n result))))
  (select-words-iter (string-split s) n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-equal? (candidate "Mary had a little lamb" 4) (list "little"))
    (check-equal? (candidate "Mary had a little lamb" 3) (list "Mary" "lamb"))
    (check-equal? (candidate "simple white space" 2) (list ))
    (check-equal? (candidate "Hello world" 4) (list "world"))
    (check-equal? (candidate "Uncle sam" 3) (list "Uncle"))
    (check-equal? (candidate "" 4) (list ))
    (check-equal? (candidate "a b c d e f" 1) (list "b" "c" "d" "f"))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpiotki2km.rkt:22:58: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_43_pairs_sum_to_zero --------
#lang racket

;; pairs_sum_to_zero takes a list of integers as an input.
;; it returns #t if there are two distinct elements in the list that
;; sum to zero, and #f otherwise.
;; >>> (pairs_sum_to_zero (list 1 3 5 0))
;; #f
;; >>> (pairs_sum_to_zero (list 1 3 -2 1))
;; #f
;; >>> (pairs_sum_to_zero (list 1 2 3 7))
;; #f
;; >>> (pairs_sum_to_zero (list 2 4 -5 3 5 7))
;; #t
;; >>> (pairs_sum_to_zero (list 1))
;; #f
(define (pairs_sum_to_zero l)
  (cond
    [(empty? l) #f]
    [(empty? (rest l)) #f]
    [(member (sub1 (first l) (second l)) (rest (rest l))) #t]
    [else (pairs_sum_to_zero (rest l))]))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate pairs_sum_to_zero))
    (check-equal? (candidate (list 1 3 5 0)) #f)
    (check-equal? (candidate (list 1 3 -2 1)) #f)
    (check-equal? (candidate (list 1 2 3 7)) #f)
    (check-equal? (candidate (list 2 4 -5 3 5 7)) #t)
    (check-equal? (candidate (list 1)) #f)
    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)
    (check-equal? (candidate (list -3 9 -1 3 2 31)) #t)
    (check-equal? (candidate (list -3 9 -1 4 2 30)) #f)
    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpkyo94blf.rkt:24:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_34_unique --------
#lang racket

;; Return sorted unique elements in a list
;; >>> (unique (list 5 3 5 2 3 3 9 0 123))
;; (list 0 2 3 5 9 123)
(define (unique l)
  (sort l #<?))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique))
    (check-equal? (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmplz6kj9vf.rkt:7:10: read-syntax: bad syntax `#<`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (sum-digits n)
    (if (= n 0)
        0
        (+ (modulo n 10) (sum-digits (quotient n 10)))))
  (define (to-binary n)
    (if (= n 0)
        ""
        (string-append (to-binary (quotient n 2)) (number->string (modulo n 2)))))
  (number->string (sum-digits (string->number (to-binary N)))))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpmnvaafjl.rkt:28:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (median-helper l)
    (cond [(empty? l) 0]
          [(empty? (rest l)) (first l)]
          [else (median-helper (rest l))]))
  (/ (+ (median-helper l) (median-helper (sort l <))) 2))
```

### Problem 4

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpn00hsth0.rkt:16:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_114_minSubArraySum --------
#lang racket

;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
;; of nums.
;; Example
;; >>> (minSubArraySum (list 2 3 4 1 2 4))
;; 1
;; >>> (minSubArraySum (list -1 -2 -3))
;; -6
(define (minSubArraySum nums)
  (let loop ([nums nums] [min-sum (car nums)])
    (cond [(null? nums) min-sum]
          [(< (car nums) min-sum) (loop (cdr nums) (car nums))]
          [else (loop (cdr nums) min-sum)])))
```

## Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minSubArraySum))
    (check-equal? (candidate (list 2 3 4 1 2 4)) 1)
    (check-equal? (candidate (list -1 -2 -3)) -6)
    (check-equal? (candidate (list -1 -2 -3 2 -10)) -14)
    (check-equal? (candidate (list -9999999999999999)) -9999999999999999)
    (check-equal? (candidate (list 0 10 20 1000000)) 0)
    (check-equal? (candidate (list -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 100 -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 10 11 13 8 3 4)) 3)
    (check-equal? (candidate (list 100 -33 32 -1 0 -2)) -33)
    (check-equal? (candidate (list -10)) -10)
    (check-equal? (candidate (list 7)) 7)
    (check-equal? (candidate (list 1 -1)) -1)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpn4k9t3tm.rkt:17:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_128_prod_signs --------
#lang racket

;; You are given a list arr of integers and you need to return
;; sum of magnitudes of integers multiplied by product of all signs
;; of each number in the list, represented by 1, -1 or 0.
;; Note: return #f for empty arr.
;; Example:
;; >>> (prod_signs (list 1 2 2 -4))
;; 9
;; >>> (prod_signs (list 0 1))
;; 0
;; >>> (prod_signs (list ))
;; #f
(define (prod_signs arr)
  (if (null? arr)
      #f
      (let loop ([arr arr] [prod 1])
        (if (null? arr)
            (* prod (apply + (map abs arr)))
            (loop (cdr arr) (* prod (signum (car arr))))))))
```

## Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prod_signs))
    (check-equal? (candidate (list 1 2 2 -4)) -9)
    (check-equal? (candidate (list 0 1)) 0)
    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)
    (check-equal? (candidate (list -1 1 -1 1)) 4)
    (check-equal? (candidate (list -1 1 1 1)) -4)
    (check-equal? (candidate (list -1 1 1 0)) 0)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpo4a77zrf.rkt:23:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (number->string (integer-length (integer->binary N))))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpo5dl2_hh.rkt:20:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(null? interval1) '()]
        [(null? interval2) '()]
        [(< (car interval1) (car interval2)) (intersection-helper (cdr interval1) interval2)]
        [(< (car interval2) (car interval1)) (intersection-helper interval1 (cdr interval2))]
        [else (cons (car interval1) (intersection-helper (cdr interval1) (cdr interval2)))]))
    (intersection-helper-helper (sort interval1 <) (sort interval2 <)))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
  (is-prime-helper n (quotient n 2)))
  (cond
    [(null? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))
```

### [Problem #3](https://www.codewars.com/kata/5a4d303f880385399b000001)

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpounikozi.rkt:45:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 4) #f]
    [(= n 5) #t]
    [(= n 6) #f]
    [(= n 7) #t]
    [(= n 8) #f]
    [(= n 9) #f]
    [(= n 10) #f]
    [(= n 11) #t]
    [(= n 12) #f]
    [(= n 13) #t]
    [(= n 14) #f]
    [(= n 15) #f]
    [(= n 16) #f]
    [(= n 17) #t]
    [(= n 18) #f]
    [(= n 19) #t]
    [(= n 20) #f]
    [(= n 21) #f]
    [(= n 22) #f]
    [(= n 23) #t]
    [(= n 24) #f]
    [(= n 25) #f]
    [(= n 26) #f]
    [(= n 27) #f]
    [(= n 28) #f]
    [(= n 29) #t]
    [(= n 30) #f]
    [(= n 31) #t]
    [(= n 32) #f]
    [(= n 33) #f]
    [(= n 34) #f]
    [(= n 35) #f]
    [(= n 36) #f]
    [(= n 37) #t]
    [(= n 38) #f]
    [(= n 39) #f]
    [(= n 40) #f]
    [(= n 41) #t]
    [(= n 42) #f]
    [(= n 43) #t]
    [(= n 44) #f]
    [(= n 45) #f]
    [(= n 46) #f]
    [(= n 47) #t]
    [(= n 48) #f]
    [(= n 49) #f]
    [(= n 50) #f]
    [(= n 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpqy8itkoy.rkt:70:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 4) #f]
    [(= n 5) #t]
    [(= n 6) #f]
    [(= n 7) #t]
    [(= n 8) #f]
    [(= n 9) #f]
    [(= n 10) #f]
    [(= n 11) #t]
    [(= n 12) #f]
    [(= n 13) #t]
    [(= n 14) #f]
    [(= n 15) #f]
    [(= n 16) #f]
    [(= n 17) #t]
    [(= n 18) #f]
    [(= n 19) #t]
    [(= n 20) #f]
    [(= n 21) #f]
    [(= n 22) #f]
    [(= n 23) #t]
    [(= n 24) #f]
    [(= n 25) #f]
    [(= n 26) #f]
    [(= n 27) #f]
    [(= n 28) #f]
    [(= n 29) #t]
    [(= n 30) #f]
    [(= n 31) #t]
    [(= n 32) #f]
    [(= n 33) #f]
    [(= n 34) #f]
    [(= n 35) #f]
    [(= n 36) #f]
    [(= n 37) #t]
    [(= n 38) #f]
    [(= n 39) #f]
    [(= n 40) #f]
    [(= n 41) #t]
    [(= n 42) #f]
    [(= n 43) #t]
    [(= n 44) #f]
    [(= n 45) #f]
    [(= n 46) #f]
    [(= n 47) #t]
    [(= n 48) #f]
    [(= n 49) #f]
    [(= n 50) #f]
    [(= n 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpqy8itkoy.rkt:70:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 4) #f]
    [(= n 5) #t]
    [(= n 6) #f]
    [(= n 7) #t]
    [(= n 8) #f]
    [(= n 9) #f]
    [(= n 10) #f]
    [(= n 11) #t]
    [(= n 12) #f]
    [(= n 13) #t]
    [(= n 14) #f]
    [(= n 15) #f]
    [(= n 16) #f]
    [(= n 17) #t]
    [(= n 18) #f]
    [(= n 19) #t]
    [(= n 20) #f]
    [(= n 21) #f]
    [(= n 22) #f]
    [(= n 23) #t]
    [(= n 24) #f]
    [(= n 25) #f]
    [(= n 26) #f]
    [(= n 27) #f]
    [(= n 28) #f]
    [(= n 29) #t]
    [(= n 30) #f]
    [(= n 31) #t]
    [(= n 32) #f]
    [(= n 33) #f]
    [(= n 34) #f]
    [(= n 35) #f]
    [(= n 36) #f]
    [(= n 37) #t]
    [(= n 38) #f]
    [(= n 39) #f]
    [(= n 40) #f]
    [(= n 41) #t]
    [(= n 42) #f]
    [(= n 43) #t]
    [(= n 44) #f]
    [(= n 45) #f]
    [(= n 46) #f]
    [(= n 47) #t]
    [(= n 48) #f]
    [(= n 49) #f]
    [(= n 50) #f]
    [(= n 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpqy8itkoy.rkt:70:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 4) #f]
    [(= n 5) #t]
    [(= n 6) #f]
    [(= n 7) #t]
    [(= n 8) #f]
    [(= n 9) #f]
    [(= n 10) #f]
    [(= n 11) #t]
    [(= n 12) #f]
    [(= n 13) #t]
    [(= n 14) #f]
    [(= n 15) #f]
    [(= n 16) #f]
    [(= n 17) #t]
    [(= n 18) #f]
    [(= n 19) #t]
    [(= n 20) #f]
    [(= n 21) #f]
    [(= n 22) #f]
    [(= n 23) #t]
    [(= n 24) #f]
    [(= n 25) #f]
    [(= n 26) #f]
    [(= n 27) #f]
    [(= n 28) #f]
    [(= n 29) #t]
    [(= n 30) #f]
    [(= n 31) #t]
    [(= n 32) #f]
    [(= n 33) #f]
    [(= n 34) #f]
    [(= n 35) #f]
    [(= n 36) #f]
    [(= n 37) #t]
    [(= n 38) #f]
    [(= n 39) #f]
    [(= n 40) #f]
    [(= n 41) #t]
    [(= n 42) #f]
    [(= n 43) #t]
    [(= n 44) #f]
    [(= n 45) #f]
    [(= n 46) #f]
    [(= n 47) #t]
    [(= n 48) #f]
    [(= n 49) #f]
    [(= n 50) #f]
    [(= n 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpqy8itkoy.rkt:70:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 4) #f]
    [(= n 5) #t]
    [(= n 6) #f]
    [(= n 7) #t]
    [(= n 8) #f]
    [(= n 9) #f]
    [(= n 10) #f]
    [(= n 11) #t]
    [(= n 12) #f]
    [(= n 13) #t]
    [(= n 14) #f]
    [(= n 15) #f]
    [(= n 16) #f]
    [(= n 17) #t]
    [(= n 18) #f]
    [(= n 19) #t]
    [(= n 20) #f]
    [(= n 21) #f]
    [(= n 22) #f]
    [(= n 23) #t]
    [(= n 24) #f]
    [(= n 25) #f]
    [(= n 26) #f]
    [(= n 27) #f]
    [(= n 28) #f]
    [(= n 29) #t]
    [(= n 30) #f]
    [(= n 31) #t]
    [(= n 32) #f]
    [(= n 33) #f]
    [(= n 34) #f]
    [(= n 35) #f]
    [(= n 36) #f]
    [(= n 37) #t]
    [(= n 38) #f]
    [(= n 39) #f]
    [(= n 40) #f]
    [(= n 41) #t]
    [(= n 42) #f]
    [(= n 43) #t]
    [(= n 44) #f]
    [(= n 45) #f]
    [(= n 46) #f]
    [(= n 47) #t]
    [(= n 48) #f]
    [(= n 49) #f]
    [(= n 50) #f]
    [(= n 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpqy8itkoy.rkt:70:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (cond
    [(= n 1) #f]
    [(= n 2) #t]
    [(= n 3) #t]
    [(= n 4) #f]
    [(= n 5) #t]
    [(= n 6) #f]
    [(= n 7) #t]
    [(= n 8) #f]
    [(= n 9) #f]
    [(= n 10) #f]
    [(= n 11) #t]
    [(= n 12) #f]
    [(= n 13) #t]
    [(= n 14) #f]
    [(= n 15) #f]
    [(= n 16) #f]
    [(= n 17) #t]
    [(= n 18) #f]
    [(= n 19) #t]
    [(= n 20) #f]
    [(= n 21) #f]
    [(= n 22) #f]
    [(= n 23) #t]
    [(= n 24) #f]
    [(= n 25) #f]
    [(= n 26) #f]
    [(= n 27) #f]
    [(= n 28) #f]
    [(= n 29) #t]
    [(= n 30) #f]
    [(= n 31) #t]
    [(= n 32) #f]
    [(= n 33) #f]
    [(= n 34) #f]
    [(= n 35) #f]
    [(= n 36) #f]
    [(= n 37) #t]
    [(= n 38) #f]
    [(= n 39) #f]
    [(= n 40) #f]
    [(= n 41) #t]
    [(= n 42) #f]
    [(= n 43) #t]
    [(= n 44) #f]
    [(= n 45) #f]
    [(= n 46) #f]
    [(= n 47) #t]
    [(= n 48) #f]
    [(= n 49) #f]
    [(= n 50) #f]
    [(= n 51) #
(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpqy8itkoy.rkt:70:14: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_141_file_name_check --------
#lang racket

;; Create a function which takes a string representing a file's name, and returns
;; 'Yes' if the the file's name is valid, and returns 'No' otherwise.
;; A file's name is considered to be valid if and only if all the following conditions 
;; are met:
;; - There should not be more than three digits ('0'-'9') in the file's name.
;; - The file's name contains exactly one dot '.'
;; - The substring before the dot should not be empty, and it starts with a letter from 
;; the latin alphapet ('a'-'z' and 'A'-'Z').
;; - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
;; Examples:
;; >>> (file_name_check "example.txt")
;; "Yes"
;; >>> (file_name_check "1example.dll")
;; "No"
(define (file_name_check file_name)
  (define (check_substring str)
    (cond ((empty? str) #f)
          ((char-alphabetic? (string-ref str 0)) #t)
          (else #f)))
  (define (check_extension ext)
    (cond ((string=? ext "txt") #t)
          ((string=? ext "exe") #t)
          ((string=? ext "dll") #t)
          (else #f)))
  (define (check_digits str)
    (cond ((empty? str) #t)
          ((char-numeric? (string-ref str 0)) (check_digits (substring str 1)))
          (else #f)))
  (define (check_dot str)
    (cond ((empty? str) #f)
          ((string=? (string-ref str 0) ".") #t)
          (else (check_dot (substring str 1)))))
  (define (check_file_name str)
    (cond ((empty? str) #f)
          ((check_dot str) #t)
          (else (check_file_name (substring str 1)))))
  (define (get_extension str)
    (cond ((empty? str) "")
          ((string=? (string-ref str 0) ".") (substring str 1))
          (else (get_extension (substring str 1)))))
  (define (get_file_name str)
    (cond ((empty? str) "")
          ((string=? (string-ref str 0) ".") (substring str 1))
          (else (string-append (string-ref str 0) (get_file_name (substring str 1))))))
  (cond ((check_file_name file_name)
         (cond ((check_substring (get_file_name file_name))
                (cond ((check_extension (get_extension file_name))
                       (cond ((check_digits (get_file_name file_name))
                              (cond ((> (string-length (get_file_name file_name)) 3) "No")
                                    (else "Yes")))
                             (else "
(require rackunit)

(define (test-humaneval) 

  (let (( candidate file_name_check))
    (check-equal? (candidate "example.txt") "Yes")
    (check-equal? (candidate "1example.dll") "No")
    (check-equal? (candidate "s1sdf3.asd") "No")
    (check-equal? (candidate "K.dll") "Yes")
    (check-equal? (candidate "MY16FILE3.exe") "Yes")
    (check-equal? (candidate "His12FILE94.exe") "No")
    (check-equal? (candidate "_Y.txt") "No")
    (check-equal? (candidate "?aREYA.exe") "No")
    (check-equal? (candidate "/this_is_valid.dll") "No")
    (check-equal? (candidate "this_is_valid.wow") "No")
    (check-equal? (candidate "this_is_valid.txt") "Yes")
    (check-equal? (candidate "this_is_valid.txtexe") "No")
    (check-equal? (candidate "#this2_i4s_5valid.ten") "No")
    (check-equal? (candidate "@this1_is6_valid.exe") "No")
    (check-equal? (candidate "this_is_12valid.6exe4.txt") "No")
    (check-equal? (candidate "all.exe.txt") "No")
    (check-equal? (candidate "I563_No.exe") "Yes")
    (check-equal? (candidate "Is3youfault.txt") "Yes")
    (check-equal? (candidate "no_one#knows.dll") "Yes")
    (check-equal? (candidate "1I563_Yes3.exe") "No")
    (check-equal? (candidate "I563_Yes3.txtt") "No")
    (check-equal? (candidate "final..txt") "No")
    (check-equal? (candidate "final132") "No")
    (check-equal? (candidate "_f4indsartal132.") "No")
    (check-equal? (candidate ".txt") "No")
    (check-equal? (candidate "s.") "No")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpso3931o4.rkt:71:30: read-syntax: bad syntax `#th`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_122_add_elements --------
#lang racket

;; Given a non-empty list of integers arr and an integer k, return
;; the sum of the elements with at most two digits from the first k elements of arr.
;; Example:
;; >>> (add_elements (list 111 21 3 4000 5 6 7 8 9) 4)
;; 24
;; Constraints:
;; 1. 1 <= len(arr) <= 100
;; 2. 1 <= k <= len(arr)
(define (add_elements arr k)
  (if (empty? arr)
      0
      (if (<= (length (number->string (first arr))) 2)
          (+ (first arr) (add_elements (rest arr) (- k 1)))
          (add_elements (rest arr) (- k 1)))))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add_elements))
    (check-equal? (candidate (list 1 -2 -3 41 57 76 87 88 99) 3) -4)
    (check-equal? (candidate (list 111 121 3 4000 5 6) 2) 0)
    (check-equal? (candidate (list 11 21 3 90 5 6 7 8 9) 4) 125)
    (check-equal? (candidate (list 111 21 3 4000 5 6 7 8 9) 4) 24)
    (check-equal? (candidate (list 1) 1) 1)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpt1ezpuih.rkt:19:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (number->string (integer-length (integer->binary N))))
```

## Test Cases

```racket
(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmptqmqchis.rkt:20:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_prime_helper a b)
      (if (= b 1)
          #t
          (if (= (modulo a b) 0)
              #f
              (is_prime_helper a (- b 1)))))
    (is_prime_helper a (- a 1)))
  (define (is_multiply_prime_helper a b)
    (if (= b 1)
        #f
        (if (and (is_prime b) (is_prime (/ a b)))
            #t
            (is_multiply_prime_helper a (- b 1)))))
  (is_multiply_prime_helper a (/ a 2)))
```

### Exercise 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpvkw_zlmx.rkt:28:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_86_anti_shuffle --------
#lang racket

;; Write a function that takes a string and returns an ordered version of it.
;; Ordered version of string, is a string where all words (separated by space)
;; are replaced by a new word where all the characters arranged in
;; ascending order based on ascii value.
;; Note: You should keep the order of words and blank spaces in the sentence.
;; For example:
;; >>> (anti_shuffle "Hi")
;; "Hi"
;; >>> (anti_shuffle "hello")
;; "ehllo"
;; >>> (anti_shuffle "Hello World!!!")
;; "Hello !!!Wdlor"
(define (anti_shuffle s)
  (define (anti_shuffle-helper s acc)
    (if (empty? s)
        (reverse acc)
        (let ((word (regexp-match #rx"^[^ ]+" s)))
          (anti-shuffle-helper (substring s (string-length word))
                               (cons (string-sort word) acc)))))
  (anti-shuffle-helper s '()))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate anti_shuffle))
    (check-equal? (candidate "Hi") "Hi")
    (check-equal? (candidate "hello") "ehllo")
    (check-equal? (candidate "number") "bemnru")
    (check-equal? (candidate "abcd") "abcd")
    (check-equal? (candidate "Hello World!!!") "Hello !!!Wdlor")
    (check-equal? (candidate "") "")
    (check-equal? (candidate "Hi. My name is Mister Robot. How are you?") ".Hi My aemn is Meirst .Rboot How aer ?ouy")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpvmmvyoug.rkt:25:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_85_add --------
#lang racket

;; Given a non-empty list of integers lst. add the even elements that are at odd indices..
;; Examples:
;; >>> (add (list 4 2 6 7))
;; 2
(define (add lst)
  (cond
    [(empty? lst) 0]
    [(even? (first lst)) (+ (first lst) (add (rest lst)))]
    [else (add (rest lst))]))
```

### Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate add))
    (check-equal? (candidate (list 4 88)) 88)
    (check-equal? (candidate (list 4 5 6 7 2 122)) 122)
    (check-equal? (candidate (list 4 0 6 7)) 0)
    (check-equal? (candidate (list 4 4 6 8)) 12)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpvn64_26e.rkt:14:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_126_is_sorted --------
#lang racket

;; Given a list of numbers, return whether or not they are sorted
;; in ascending order. If list has more than 1 duplicate of the same
;; number, return #f. Assume no negative numbers and only integers.
;; Examples
;; >>> (is_sorted (list 5))
;; #t
;; >>> (is_sorted (list 1 2 3 4 5))
;; #t
;; >>> (is_sorted (list 1 3 2 4 5))
;; #f
;; >>> (is_sorted (list 1 2 3 4 5 6))
;; #t
;; >>> (is_sorted (list 1 2 3 4 5 6 7))
;; #t
;; >>> (is_sorted (list 1 3 2 4 5 6 7))
;; #f
;; >>> (is_sorted (list 1 2 2 3 3 4))
;; #t
;; >>> (is_sorted (list 1 2 2 2 3 4))
;; #f
(define (is_sorted lst)
  (cond
    [(empty? lst) #t]
    [(empty? (rest lst)) #t]
    [(and (not (empty? lst)) (not (empty? (rest lst))))
     (if (and (= (first lst) (second lst))
              (not (empty? (rest (rest lst)))))
         #f
         (if (< (first lst) (second lst))
             (is_sorted (rest lst))
             #f))]))
```

### Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_sorted))
    (check-equal? (candidate (list 5)) #t)
    (check-equal? (candidate (list 1 2 3 4 5)) #t)
    (check-equal? (candidate (list 1 3 2 4 5)) #f)
    (check-equal? (candidate (list 1 2 3 4 5 6)) #t)
    (check-equal? (candidate (list 1 2 3 4 5 6 7)) #t)
    (check-equal? (candidate (list 1 3 2 4 5 6 7)) #f)
    (check-equal? (candidate (list )) #t)
    (check-equal? (candidate (list 1)) #t)
    (check-equal? (candidate (list 3 2 1)) #f)
    (check-equal? (candidate (list 1 2 2 2 3 4)) #f)
    (check-equal? (candidate (list 1 2 3 3 3 4)) #f)
    (check-equal? (candidate (list 1 2 2 3 3 4)) #t)
    (check-equal? (candidate (list 1 2 3 4)) #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpw2xzrdnv.rkt:36:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_141_file_name_check --------
#lang racket

;; Create a function which takes a string representing a file's name, and returns
;; 'Yes' if the the file's name is valid, and returns 'No' otherwise.
;; A file's name is considered to be valid if and only if all the following conditions 
;; are met:
;; - There should not be more than three digits ('0'-'9') in the file's name.
;; - The file's name contains exactly one dot '.'
;; - The substring before the dot should not be empty, and it starts with a letter from 
;; the latin alphapet ('a'-'z' and 'A'-'Z').
;; - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
;; Examples:
;; >>> (file_name_check "example.txt")
;; "Yes"
;; >>> (file_name_check "1example.dll")
;; "No"
(define (file_name_check file_name)
  (define (check_extension file_name)
    (cond
      [(string=? (substring file_name (- (string-length file_name) 3)) "txt") #t]
      [(string=? (substring file_name (- (string-length file_name) 3)) "exe") #t]
      [(string=? (substring file_name (- (string-length file_name) 3)) "dll") #t]
      [else #f]))
  (define (check_name file_name)
    (cond
      [(string=? (substring file_name 0 1) "0") #f]
      [(string=? (substring file_name 0 1) "1") #f]
      [(string=? (substring file_name 0 1) "2") #f]
      [(string=? (substring file_name 0 1) "3") #f]
      [(string=? (substring file_name 0 1) "4") #f]
      [(string=? (substring file_name 0 1) "5") #f]
      [(string=? (substring file_name 0 1) "6") #f]
      [(string=? (substring file_name 0 1) "7") #f]
      [(string=? (substring file_name 0 1) "8") #f]
      [(string=? (substring file_name 0 1) "9") #f]
      [else #t]))
  (define (check_dot file_name)
    (cond
      [(string=? (substring file_name (- (string-length file_name) 4) (- (string-length file_name) 3)) ".") #t]
      [else #f]))
  (define (check_digits file_name)
    (cond
      [(string-length (regexp-replace* #rx"[^0-9]" file_name "")) 3]
      [else #f]))
  (cond
    [(and (check_extension file_name) (check_name file_name) (check_dot file_name) (check_digits file_name)) "Yes"]
    [else "
(require rackunit)

(define (test-humaneval) 

  (let (( candidate file_name_check))
    (check-equal? (candidate "example.txt") "Yes")
    (check-equal? (candidate "1example.dll") "No")
    (check-equal? (candidate "s1sdf3.asd") "No")
    (check-equal? (candidate "K.dll") "Yes")
    (check-equal? (candidate "MY16FILE3.exe") "Yes")
    (check-equal? (candidate "His12FILE94.exe") "No")
    (check-equal? (candidate "_Y.txt") "No")
    (check-equal? (candidate "?aREYA.exe") "No")
    (check-equal? (candidate "/this_is_valid.dll") "No")
    (check-equal? (candidate "this_is_valid.wow") "No")
    (check-equal? (candidate "this_is_valid.txt") "Yes")
    (check-equal? (candidate "this_is_valid.txtexe") "No")
    (check-equal? (candidate "#this2_i4s_5valid.ten") "No")
    (check-equal? (candidate "@this1_is6_valid.exe") "No")
    (check-equal? (candidate "this_is_12valid.6exe4.txt") "No")
    (check-equal? (candidate "all.exe.txt") "No")
    (check-equal? (candidate "I563_No.exe") "Yes")
    (check-equal? (candidate "Is3youfault.txt") "Yes")
    (check-equal? (candidate "no_one#knows.dll") "Yes")
    (check-equal? (candidate "1I563_Yes3.exe") "No")
    (check-equal? (candidate "I563_Yes3.txtt") "No")
    (check-equal? (candidate "final..txt") "No")
    (check-equal? (candidate "final132") "No")
    (check-equal? (candidate "_f4indsartal132.") "No")
    (check-equal? (candidate ".txt") "No")
    (check-equal? (candidate "s.") "No")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpwevvgvq4.rkt:65:30: read-syntax: bad syntax `#th`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_141_file_name_check --------
#lang racket

;; Create a function which takes a string representing a file's name, and returns
;; 'Yes' if the the file's name is valid, and returns 'No' otherwise.
;; A file's name is considered to be valid if and only if all the following conditions 
;; are met:
;; - There should not be more than three digits ('0'-'9') in the file's name.
;; - The file's name contains exactly one dot '.'
;; - The substring before the dot should not be empty, and it starts with a letter from 
;; the latin alphapet ('a'-'z' and 'A'-'Z').
;; - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
;; Examples:
;; >>> (file_name_check "example.txt")
;; "Yes"
;; >>> (file_name_check "1example.dll")
;; "No"
(define (file_name_check file_name)
  (define (is_valid_file_name? file_name)
    (define (is_valid_extension? extension)
      (member extension '("txt" "exe" "dll")))
    (define (is_valid_name? name)
      (and (not (empty? name))
           (regexp-match #rx"^[a-zA-Z]" name)))
    (define (is_valid_number_of_digits? file_name)
      (define (count-digits file_name)
        (if (empty? file_name)
            0
            (if (regexp-match #rx"^[0-9]" file_name)
                (+ 1 (count-digits (string-drop file_name 1)))
                (count-digits (string-drop file_name 1)))))
      (<= (count-digits file_name) 3))
    (define (is_valid_dot? file_name)
      (string-contains file_name #\.))
    (define (split-file-name file_name)
      (define (split-file-name-helper file_name name extension)
        (if (empty? file_name)
            (list name extension)
            (if (string=? (string-take file_name 1) ".")
                (list name (string-drop file_name 1))
                (split-file-name-helper (string-drop file_name 1) (string-append name (string-take file_name 1)) extension))))
      (split-file-name-helper file_name "" ""))
    (define (is_valid_file_name file_name)
      (let ((name (car (split-file-name file_name)))
            (extension (cadr (split-file-name file_name))))
        (and (is_valid_number_of_digits? file_name)
             (is_valid_dot? file_name)
             (is_valid_name? name)
             (is_valid_extension? extension))))
    (if (is_valid_file_name file_name)
        "Yes"
        "No
(require rackunit)

(define (test-humaneval) 

  (let (( candidate file_name_check))
    (check-equal? (candidate "example.txt") "Yes")
    (check-equal? (candidate "1example.dll") "No")
    (check-equal? (candidate "s1sdf3.asd") "No")
    (check-equal? (candidate "K.dll") "Yes")
    (check-equal? (candidate "MY16FILE3.exe") "Yes")
    (check-equal? (candidate "His12FILE94.exe") "No")
    (check-equal? (candidate "_Y.txt") "No")
    (check-equal? (candidate "?aREYA.exe") "No")
    (check-equal? (candidate "/this_is_valid.dll") "No")
    (check-equal? (candidate "this_is_valid.wow") "No")
    (check-equal? (candidate "this_is_valid.txt") "Yes")
    (check-equal? (candidate "this_is_valid.txtexe") "No")
    (check-equal? (candidate "#this2_i4s_5valid.ten") "No")
    (check-equal? (candidate "@this1_is6_valid.exe") "No")
    (check-equal? (candidate "this_is_12valid.6exe4.txt") "No")
    (check-equal? (candidate "all.exe.txt") "No")
    (check-equal? (candidate "I563_No.exe") "Yes")
    (check-equal? (candidate "Is3youfault.txt") "Yes")
    (check-equal? (candidate "no_one#knows.dll") "Yes")
    (check-equal? (candidate "1I563_Yes3.exe") "No")
    (check-equal? (candidate "I563_Yes3.txtt") "No")
    (check-equal? (candidate "final..txt") "No")
    (check-equal? (candidate "final132") "No")
    (check-equal? (candidate "_f4indsartal132.") "No")
    (check-equal? (candidate ".txt") "No")
    (check-equal? (candidate "s.") "No")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpww0u44nf.rkt:69:30: read-syntax: bad syntax `#th`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_6_parse_nested_parens --------
#lang racket

;; Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
;; For each of the group, output the deepest level of nesting of parentheses.
;; E.g. (()()) has maximum two levels of nesting while ((())) has three.
;; >>> (parse_nested_parens "(()()) ((())) () ((())()())")
;; (list 2 3 1 3)
(define (parse_nested_parens paren_string)
  (map (lambda (paren_group)
         (let ([paren_stack '()])
           (for ([paren (in-string paren_group)])
             (cond
               [(equal? paren "(") (push paren paren_stack)]
               [(equal? paren ")") (pop paren_stack)]
               [else (error "Invalid character")]))
           (length paren_stack)))
       (regexp-split #rx" " paren_string)))
```

## Problem 2

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_nested_parens))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list 2 3 1 3))
    (check-equal? (candidate "() (()) ((())) (((())))") (list 1 2 3 4))
    (check-equal? (candidate "(()(())((())))") (list 4))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpxbo9qvf4.rkt:20:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (cons (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (cons (car interval1) (cadr interval2))]
        [else
         #f]))
    (intersection-helper-helper interval1 interval2)
    (intersection-helper-helper interval2 interval1))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (is-prime-helper n (- i 1))]))
  (is-prime-helper n (floor (/ n 2))))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(not (intersection-helper interval1 interval2))
     "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2)))
     "YES"]
    [else
     "NO"]))
```

## Problem 3

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpxt0wgy0j.rkt:55:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate l)
    (append (cdr l) (list (car l))))
  (define (rotate-n l n)
    (if (zero? n)
        l
        (rotate-n (rotate l) (- n 1))))
  (define (is-substring? a b)
    (if (empty? b)
        #t
        (if (empty? a)
            #f
            (if (equal? (car a) (car b))
                (is-substring? (cdr a) (cdr b))
                (is-substring? (cdr a) b)))))
  (define (rotations l)
    (if (empty? l)
        (list '())
        (append (rotations (cdr l)) (list (rotate-n l (length l))))))
  (define (check-rotations l)
    (if (empty? l)
        #f
        (if (is-substring? a (car l))
            #t
            (check-rotations (cdr l)))))
  (check-rotations (rotations (string->list b))))
```

### [Problem #5](https://www.reddit.com/r/dailyprogrammer/comments/3q9vpn/20151026_challenge_238_easy_consonants_and_vowels/)

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpy0d_mlmv.rkt:44:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_59_largest_prime_factor --------
#lang racket

;; Return the largest prime factor of n. Assume n > 1 and is not a prime.
;; >>> (largest_prime_factor 13195)
;; 29
;; >>> (largest_prime_factor 2048)
;; 2
(define (largest_prime_factor n)
  (define (prime? n)
    (define (iter i)
      (cond ((> i (sqrt n)) #t)
            ((zero? (modulo n i)) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((> i (sqrt n)) n)
          ((and (zero? (modulo n i)) (prime? i)) (iter i))
          (else (iter (+ i 1)))))
  (iter 2))
```

### Problem 4

```racket
#lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_prime_factor))
    (check-equal? (candidate 15) 5)
    (check-equal? (candidate 27) 3)
    (check-equal? (candidate 63) 7)
    (check-equal? (candidate 330) 11)
    (check-equal? (candidate 13195) 29)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpykxre64r.rkt:22:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_117_select_words --------
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")
(define (select_words s n)
  (define (count-consonants s)
    (define (is-consonant? c)
      (member c '(#\b #\c #\d #\f #\g #\h #\j #\k #\l #\m #
                  #
                  n #\p #\q #\r #\s #\t #\v #\w #\x #\y #\z)))
    (define (count-consonants-helper s count)
      (cond ((string-empty? s) count)
            ((is-consonant? (string-ref s 0))
             (count-consonants-helper (substring s 1) (+ count 1)))
            (else (count-consonants-helper (substring s 1) count))))
    (count-consonants-helper s 0))
  (define (select-words-helper s n lst)
    (cond ((string-empty? s) lst)
          ((= n (count-consonants (string-take-while (compose not space?) s)))
           (select-words-helper (substring s (string-length (string-take-while (compose not space?) s))) n (cons (string-take-while (compose not space?) s) lst)))
          (else (select-words-helper (substring s (string-length (string-take-while (compose not space?) s))) n lst))))
  (select-words-helper s n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-equal? (candidate "Mary had a little lamb" 4) (list "little"))
    (check-equal? (candidate "Mary had a little lamb" 3) (list "Mary" "lamb"))
    (check-equal? (candidate "simple white space" 2) (list ))
    (check-equal? (candidate "Hello world" 4) (list "world"))
    (check-equal? (candidate "Uncle sam" 3) (list "Uncle"))
    (check-equal? (candidate "" 4) (list ))
    (check-equal? (candidate "a b c d e f" 1) (list "b" "c" "d" "f"))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpz6rl88in.rkt:22:58: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_117_select_words --------
#lang racket

;; Given a string s and a natural number n, you have been tasked to implement 
;; a function that returns a list of all words from string s that contain exactly 
;; n consonants, in order these words appear in the string s.
;; If the string s is empty then the function should return an empty list.
;; Note: you may assume the input string contains only letters and spaces.
;; Examples:
;; >>> (select_words "Mary had a little lamb" 4)
;; (list "little")
;; >>> (select_words "Mary had a little lamb" 3)
;; (list "Mary" "lamb")
;; >>> (select_words "simple white space" 2)
;; (list )
;; >>> (select_words "Hello world" 4)
;; (list "world")
;; >>> (select_words "Uncle sam" 3)
;; (list "Uncle")
(define (select_words s n)
  (define (is_consonant c)
    (member c '(#\b #\c #\d #\f #\g #\h #\j #\k #\l #\m #
                #
                n #\p #\q #\r #\s #\t #\v #\w #\x #\y #\z)))
  (define (count-consonants word)
    (if (empty? word)
        0
        (+ (if (is_consonant (first word)) 1 0)
           (count-consonants (rest word)))))
  (define (select-words-iter words n)
    (if (empty? words)
        '()
        (if (= n (count-consonants (first words)))
            (cons (first words) (select-words-iter (rest words) n))
            (select-words-iter (rest words) n))))
  (select-words-iter (string-split s) n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate select_words))
    (check-equal? (candidate "Mary had a little lamb" 4) (list "little"))
    (check-equal? (candidate "Mary had a little lamb" 3) (list "Mary" "lamb"))
    (check-equal? (candidate "simple white space" 2) (list ))
    (check-equal? (candidate "Hello world" 4) (list "world"))
    (check-equal? (candidate "Uncle sam" 3) (list "Uncle"))
    (check-equal? (candidate "" 4) (list ))
    (check-equal? (candidate "a b c d e f" 1) (list "b" "c" "d" "f"))
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpzg7xv541.rkt:21:56: read-syntax: bad syntax `#
`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-all lst)
    (map (lambda (x) (rotate-n lst x)) (range (length lst))))
  (define (substring? a b)
    (define (substring?-helper a b)
      (if (or (null? a) (null? b))
          #t
          (if (= (car a) (car b))
              (substring?-helper (cdr a) (cdr b))
              #f)))
    (or (substring?-helper a b)
        (substring?-helper (cdr a) b)))
  (define (any? lst pred)
    (if (null? lst)
        #f
        (or (pred (car lst))
            (any? (cdr lst) pred))))
  (any? (rotate-all (string->list b)) (lambda (x) (substring? (string->list a) x))))
```

## Problem 3

``` #lang racket

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpztro7619.rkt:42:0: read-syntax: bad syntax `##`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

