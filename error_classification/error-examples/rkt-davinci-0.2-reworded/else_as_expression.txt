HumanEval_67_fruit_distribution: 1
HumanEval_119_match_parens: 1
==========================
------- Program HumanEval_67_fruit_distribution --------
#lang racket

;; In this task, you will be given a string that represents a number of apples and oranges 
;; that are distributed in a basket of fruit this basket contains 
;; apples, oranges, and mango fruits. Given the string that represents the total number of 
;; the oranges and apples and an integer that represent the total number of the fruits 
;; in the basket return the number of the mango fruits in the basket.
;; for examble:
;; >>> (fruit_distribution "5 apples and 6 oranges" 19)
;; 8
;; >>> (fruit_distribution "0 apples and 1 oranges" 3)
;; 2
;; >>> (fruit_distribution "2 apples and 3 oranges" 100)
;; 95
;; >>> (fruit_distribution "100 apples and 1 oranges" 120)
;; 19
(define (fruit_distribution s n)
  (define (split s)
    (string-split s " "))
  (define (get-num s)
    (string->number (car (cdr (split s)))))
  (define (get-fruit s)
    (car (split s)))
  (define (get-total-fruit s)
    (cond
      [(equal? (get-fruit s) "apples") (+ (get-num s) (get-num (car (cdr (split s)))))
       (else (get-num s))]))
  (- n (get-total-fruit s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fruit_distribution))
    (check-equal? (candidate "5 apples and 6 oranges" 19) 8)
    (check-equal? (candidate "5 apples and 6 oranges" 21) 10)
    (check-equal? (candidate "0 apples and 1 oranges" 3) 2)
    (check-equal? (candidate "1 apples and 0 oranges" 3) 2)
    (check-equal? (candidate "2 apples and 3 oranges" 100) 95)
    (check-equal? (candidate "2 apples and 3 oranges" 5) 0)
    (check-equal? (candidate "1 apples and 100 oranges" 120) 19)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmprxosmlf1.rkt:27:7: else: not allowed as an expression
  in: (else (get-num s))
  location...:
   /tmp/tmprxosmlf1.rkt:27:7

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (let ((s1 (car lst))
        (s2 (cadr lst)))
    (cond ((and (string=? s1 "") (string=? s2 "")) "Yes")
          ((and (string=? s1 "") (not (string=? s2 ""))) "No")
          ((and (not (string=? s1 "")) (string=? s2 "")) "No")
          ((and (not (string=? s1 "")) (not (string=? s2 "")))
           (let ((c1 (string-ref s1 0))
                 (c2 (string-ref s2 0)))
             (cond ((and (char=? c1 #\() (char=? c2 #\()))
                    (match_parens (list (substring s1 1) (substring s2 1))))
                   ((and (char=? c1 #\() (char=? c2 #\)))
                    (match_parens (list (substring s1 1) (substring s2 1))))
                   ((and (char=? c1 #\)) (char=? c2 #\()))
                   ((and (char=? c1 #\)) (char=? c2 #\)))
                   (else "No")))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzmp1oamg.rkt:31:19: else: not allowed as an expression
  in: (else "No")
  location...:
   /tmp/tmpzmp1oamg.rkt:31:19

