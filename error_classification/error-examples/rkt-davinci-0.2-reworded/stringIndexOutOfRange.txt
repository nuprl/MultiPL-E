HumanEval_17_parse_music: 49
HumanEval_1_separate_paren_groups: 3
HumanEval_11_string_xor: 11
HumanEval_91_is_bored: 70
HumanEval_161_solve: 28
HumanEval_10_make_palindrome: 37
HumanEval_80_is_happy: 6
HumanEval_48_is_palindrome: 99
HumanEval_66_digitSum: 65
HumanEval_89_encrypt: 38
HumanEval_98_count_upper: 9
HumanEval_14_all_prefixes: 2
HumanEval_78_hex_key: 5
HumanEval_67_fruit_distribution: 2
HumanEval_118_get_closest_vowel: 8
HumanEval_65_circular_shift: 3
HumanEval_56_correct_bracketing: 1
HumanEval_51_remove_vowels: 1
HumanEval_99_closest_integer: 1
HumanEval_140_fix_spaces: 1
HumanEval_124_valid_date: 2
HumanEval_61_correct_bracketing: 6
HumanEval_119_match_parens: 1
==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (define (parse_music_helper music_string)
    (if (empty? music_string)
        (list)
        (cons (cond
               ((string=? (substring music_string 0 1) "o") 4)
               ((string=? (substring music_string 0 1) ".") 1)
               ((string=? (substring music_string 0 2) "o|") 2)
               (else 0))
              (parse_music_helper (substring music_string 1)))))
  (parse_music_helper music_string))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ldj7wyl.rkt:29:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ldj7wyl.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ldj7wyl.rkt:31:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ldj7wyl.rkt:32:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0ldj7wyl.rkt:33:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_1_separate_paren_groups --------
#lang racket

;; Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
;; separate those group into separate strings and return the list of those.
;; Separate groups are balanced (each open brace is properly closed) and not nested within each other
;; Ignore any spaces in the input string.
;; >>> (separate_paren_groups "( ) (( )) (( )( ))")
;; (list "()" "(())" "(()())")
(define (separate_paren_groups paren_string)
  (define (separate_paren_groups-helper paren_string paren_list)
    (cond
      [(empty? paren_string) paren_list]
      [(string=? (substring paren_string 0 1) " ") (separate_paren_groups-helper (substring paren_string 1) paren_list)]
      [(string=? (substring paren_string 0 1) "(") (separate_paren_groups-helper (substring paren_string 1) (cons (separate_paren_groups-helper-parens paren_string) paren_list))]
      [else (separate_paren_groups-helper (substring paren_string 1) paren_list)]))
  (define (separate_paren_groups-helper-parens paren_string)
    (cond
      [(string=? (substring paren_string 0 1) ")") (substring paren_string 0 1)]
      [else (string-append (substring paren_string 0 1) (separate_paren_groups-helper-parens (substring paren_string 1)))]))
  (reverse (separate_paren_groups-helper paren_string '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate separate_paren_groups))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list "(()())" "((()))" "()" "((())()())"))
    (check-equal? (candidate "() (()) ((())) (((())))") (list "()" "(())" "((()))" "(((())))"))
    (check-equal? (candidate "(()(())((())))") (list "(()(())((())))"))
    (check-equal? (candidate "( ) (( )) (( )( ))") (list "()" "(())" "(()())"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0x0ywfrq.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0x0ywfrq.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0x0ywfrq.rkt:29:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0x0ywfrq.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (cond
      [(char=? a b) "0"]
      [else "1"]))
  (define (xor-string a b)
    (cond
      [(empty? a) b]
      [(empty? b) a]
      [else (string-append (xor-char (string-ref a 0) (string-ref b 0))
                           (xor-string (substring a 1) (substring b 1)))]))
  (xor-string a b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp15v8wi7w.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp15v8wi7w.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp15v8wi7w.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (length (filter (lambda (x) (string=? (substring x 0 1) "I"))
                  (regexp-split #rx"[.?!]" S))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1_752uzh.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1_752uzh.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1_752uzh.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (length (filter (lambda (x) (string=? (substring x 0 1) "I"))
                  (regexp-split #rx"[.?!]" S))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1_752uzh.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1_752uzh.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1_752uzh.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else
     (string-append
      (string (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:43:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else
     (string-append
      (string (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:43:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else
     (string-append
      (string (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:43:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else
     (string-append
      (string (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:43:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else
     (string-append
      (string (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dw4p5du.rkt:43:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (is_palindrome? string)
    (define (is_palindrome?-iter string left right)
      (if (= left right)
          #t
          (if (= (string-ref string left) (string-ref string right))
              (is_palindrome?-iter string (+ left 1) (- right 1))
              #f)))
    (is_palindrome?-iter string 0 (- (string-length string) 1)))
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-iter string suffix-length)
      (if (is_palindrome? (substring string 0 suffix-length))
          (find-longest-palindrome-suffix-iter string (+ suffix-length 1))
          (- suffix-length 1)))
    (find-longest-palindrome-suffix-iter string 1))
  (define (reverse string)
    (define (reverse-iter string result)
      (if (string=? string "")
          result
          (reverse-iter (substring string 1) (string-append (substring string 0 1) result))))
    (reverse-iter string ""))
  (string-append string (reverse (substring string 0 (- (string-length string) (find-longest-palindrome-suffix string))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h4ma0ad.rkt:41:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h4ma0ad.rkt:42:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h4ma0ad.rkt:43:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h4ma0ad.rkt:44:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h4ma0ad.rkt:45:4

=: contract violation
  expected: number?
  given: #\j
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h_agdui.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h_agdui.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h_agdui.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h_agdui.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1h_agdui.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_80_is_happy --------
#lang racket

;; You are given a string s.
;; Your task is to check if the string is haprkt or not.
;; A string is haprkt if its length is at least 3 and every 3 consecutive letters are distinct
;; For example:
;; >>> (is_happy a)
;; #f
;; >>> (is_happy aa)
;; #f
;; >>> (is_happy abcd)
;; #t
;; >>> (is_happy aabb)
;; #f
;; >>> (is_happy adb)
;; #t
;; >>> (is_happy xyy)
;; #f
(define (is_happy s)
  (cond
    [(<= (string-length s) 2) #f]
    [(equal? (substring s 0 3) (substring s 1 4)) #f]
    [else (is_happy (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_happy))
    (check-equal? (candidate "a") #f)
    (check-equal? (candidate "aa") #f)
    (check-equal? (candidate "abcd") #t)
    (check-equal? (candidate "aabb") #f)
    (check-equal? (candidate "adb") #t)
    (check-equal? (candidate "xyy") #f)
    (check-equal? (candidate "iopaxpoi") #t)
    (check-equal? (candidate "iopaxioi") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2j8sk_f8.rkt:32:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "bcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2j8sk_f8.rkt:33:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "abb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2j8sk_f8.rkt:34:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "adb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2j8sk_f8.rkt:35:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2j8sk_f8.rkt:36:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "poi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2j8sk_f8.rkt:37:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "ioi"
--------------------

==========================
------- Program HumanEval_1_separate_paren_groups --------
#lang racket

;; Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
;; separate those group into separate strings and return the list of those.
;; Separate groups are balanced (each open brace is properly closed) and not nested within each other
;; Ignore any spaces in the input string.
;; >>> (separate_paren_groups "( ) (( )) (( )( ))")
;; (list "()" "(())" "(()())")
(define (separate_paren_groups paren_string)
  (define (separate_paren_groups_helper paren_string paren_list)
    (cond
      [(empty? paren_string) paren_list]
      [(string=? (substring paren_string 0 1) " ") (separate_paren_groups_helper (substring paren_string 1) paren_list)]
      [(string=? (substring paren_string 0 1) "(") (separate_paren_groups_helper (substring paren_string 1) (cons (separate_paren_groups_helper_2 paren_string) paren_list))]
      [else (separate_paren_groups_helper (substring paren_string 1) paren_list)]))
  (define (separate_paren_groups_helper_2 paren_string)
    (cond
      [(string=? (substring paren_string 0 1) ")") (substring paren_string 0 1)]
      [(string=? (substring paren_string 0 1) " ") (separate_paren_groups_helper_2 (substring paren_string 1))]
      [(string=? (substring paren_string 0 1) "(") (string-append (substring paren_string 0 1) (separate_paren_groups_helper_2 (substring paren_string 1)))]
      [else (string-append (substring paren_string 0 1) (separate_paren_groups_helper_2 (substring paren_string 1)))]))
  (separate_paren_groups_helper paren_string '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate separate_paren_groups))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list "(()())" "((()))" "()" "((())()())"))
    (check-equal? (candidate "() (()) ((())) (((())))") (list "()" "(())" "((()))" "(((())))"))
    (check-equal? (candidate "(()(())((())))") (list "(()(())((())))"))
    (check-equal? (candidate "( ) (( )) (( )( ))") (list "()" "(())" "(()())"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2kb3joja.rkt:29:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2kb3joja.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2kb3joja.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2kb3joja.rkt:32:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_80_is_happy --------
#lang racket

;; You are given a string s.
;; Your task is to check if the string is haprkt or not.
;; A string is haprkt if its length is at least 3 and every 3 consecutive letters are distinct
;; For example:
;; >>> (is_happy a)
;; #f
;; >>> (is_happy aa)
;; #f
;; >>> (is_happy abcd)
;; #t
;; >>> (is_happy aabb)
;; #f
;; >>> (is_happy adb)
;; #t
;; >>> (is_happy xyy)
;; #f
(define (is_happy s)
  (define (is_happy-helper s i)
    (cond
      [(= i (- (string-length s) 2)) #t]
      [(string=? (substring s i (+ i 3)) (substring s (+ i 1) (+ i 4))) #f]
      [else (is_happy-helper s (+ i 1))]))
  (cond
    [(< (string-length s) 3) #f]
    [else (is_happy-helper s 0)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_happy))
    (check-equal? (candidate "a") #f)
    (check-equal? (candidate "aa") #f)
    (check-equal? (candidate "abcd") #t)
    (check-equal? (candidate "aabb") #f)
    (check-equal? (candidate "adb") #t)
    (check-equal? (candidate "xyy") #f)
    (check-equal? (candidate "iopaxpoi") #t)
    (check-equal? (candidate "iopaxioi") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3d9y7wgh.rkt:36:4

substring: ending index is out of range
  ending index: 5
  valid range: [0, 4]
  string: "abcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3d9y7wgh.rkt:37:4

substring: ending index is out of range
  ending index: 5
  valid range: [0, 4]
  string: "aabb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3d9y7wgh.rkt:38:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "adb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3d9y7wgh.rkt:39:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3d9y7wgh.rkt:40:4

substring: ending index is out of range
  ending index: 9
  valid range: [0, 8]
  string: "iopaxpoi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3d9y7wgh.rkt:41:4

substring: ending index is out of range
  ending index: 9
  valid range: [0, 8]
  string: "iopaxioi"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (helper text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (helper text (+ left 1) (- right 1))
            #f)))
  (helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3l16r52y.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (= len 1)
        #t
        (if (= len 2)
            (equal? (string-ref text 0) (string-ref text 1))
            (if (equal? (string-ref text 0) (string-ref text (- len 1)))
                (is_palindrome_iter (substring text 1 (- len 1)) (- len 2))
                #f))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3lkyq62m.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (or (= left right)
            (= left (- right 1)))
        #t
        (and (char=? (string-ref text left) (string-ref text right))
             (is_palindrome_iter text (+ left 1) (- right 1)))))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3mm1zyc8.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (equal? (string-upcase (substring x 0 1)) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3mmbpkcp.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3mmbpkcp.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3mmbpkcp.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0))
     (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3syqumzm.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome-iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3tp29pde.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome-iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3tp29pde.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome-iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3tp29pde.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        string
        (string-append (reverse (substring string 1)) (string (string-ref string 0)))))
  (define (is_palindrome? string)
    (define (helper string1 string2)
      (if (or (empty? string1) (empty? string2))
          #t
          (and (char=? (string-ref string1 0) (string-ref string2 0))
               (helper (substring string1 1) (substring string2 1)))))
    (helper string (reverse string)))
  (define (find_longest_palindrome string)
    (define (helper string)
      (if (is_palindrome? string)
          string
          (helper (substring string 0 (- (string-length string) 1)))))
    (helper string))
  (string-append string (reverse (substring string 0 (- (string-length (find_longest_palindrome string)) 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40l0_eif.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40l0_eif.rkt:39:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40l0_eif.rkt:40:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40l0_eif.rkt:41:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40l0_eif.rkt:42:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (if (= i j)
        #t
        (if (= (string-ref text i) (string-ref text j))
            (is_palindrome_iter text (+ i 1) (- j 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp41fhhw9d.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (if (char=? a b)
        #\0
        #\1))
  (define (xor-string a b)
    (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))
                   (xor-string (substring a 1) (substring b 1))))
  (if (string=? a "")
      ""
      (xor-string a b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4_j23328.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4_j23328.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4_j23328.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        string
        (string-append (reverse (substring string 1)) (string (string-ref string 0)))))
  (define (find-longest-palindrome string)
    (define (is-palindrome string)
      (if (empty? string)
          #t
          (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
               (is-palindrome (substring string 1 (- (string-length string) 1))))))
    (if (is-palindrome string)
        string
        (find-longest-palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4bj92osz.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4bj92osz.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4bj92osz.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4bj92osz.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4bj92osz.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (longest_palindrome string)
    (if (empty? string)
        ""
        (if (is_palindrome string)
            string
            (longest_palindrome (substring string 0 (- (string-length string) 1))))))
  (define (make_palindrome_helper string)
    (string-append string (reverse (substring string 0 (- (string-length string) (string-length (longest_palindrome string)))))))
  (make_palindrome_helper string))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ilo0ii5.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ilo0ii5.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ilo0ii5.rkt:40:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ilo0ii5.rkt:41:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ilo0ii5.rkt:42:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_80_is_happy --------
#lang racket

;; You are given a string s.
;; Your task is to check if the string is haprkt or not.
;; A string is haprkt if its length is at least 3 and every 3 consecutive letters are distinct
;; For example:
;; >>> (is_happy a)
;; #f
;; >>> (is_happy aa)
;; #f
;; >>> (is_happy abcd)
;; #t
;; >>> (is_happy aabb)
;; #f
;; >>> (is_happy adb)
;; #t
;; >>> (is_happy xyy)
;; #f
(define (is_happy s)
  (define (is_happy-helper s i)
    (cond
      [(= i (- (string-length s) 2)) #t]
      [(equal? (substring s i (+ i 3)) (substring s (+ i 1) (+ i 4))) #f]
      [else (is_happy-helper s (+ i 1))]))
  (cond
    [(< (string-length s) 3) #f]
    [else (is_happy-helper s 0)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_happy))
    (check-equal? (candidate "a") #f)
    (check-equal? (candidate "aa") #f)
    (check-equal? (candidate "abcd") #t)
    (check-equal? (candidate "aabb") #f)
    (check-equal? (candidate "adb") #t)
    (check-equal? (candidate "xyy") #f)
    (check-equal? (candidate "iopaxpoi") #t)
    (check-equal? (candidate "iopaxioi") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4r1ufg58.rkt:36:4

substring: ending index is out of range
  ending index: 5
  valid range: [0, 4]
  string: "abcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4r1ufg58.rkt:37:4

substring: ending index is out of range
  ending index: 5
  valid range: [0, 4]
  string: "aabb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4r1ufg58.rkt:38:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "adb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4r1ufg58.rkt:39:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4r1ufg58.rkt:40:4

substring: ending index is out of range
  ending index: 9
  valid range: [0, 8]
  string: "iopaxpoi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4r1ufg58.rkt:41:4

substring: ending index is out of range
  ending index: 9
  valid range: [0, 8]
  string: "iopaxioi"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_helper text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_helper text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_helper text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5dr9e2dq.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string-upcase (string-ref s 0))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string-ref s 0)
      (solve (substring s 1)))]
    [else
     (string-append
      (string-downcase (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:36:4

string-upcase: contract violation
  expected: string?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:38:4

string-upcase: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:39:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:40:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:41:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:42:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5ilvom0z.rkt:43:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond [(empty? s) 0]
        [else (+ (char->integer (string-ref s 0))
                 (digitSum (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond [(empty? s) 0]
        [else (+ (char->integer (string-ref s 0))
                 (digitSum (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond [(empty? s) 0]
        [else (+ (char->integer (string-ref s 0))
                 (digitSum (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond [(empty? s) 0]
        [else (+ (char->integer (string-ref s 0))
                 (digitSum (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond [(empty? s) 0]
        [else (+ (char->integer (string-ref s 0))
                 (digitSum (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5t2mv1ab.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (= len 1)
        #t
        (if (= len 2)
            (if (= (string-ref text 0) (string-ref text 1))
                #t
                #f)
            (if (and (= (string-ref text 0) (string-ref text (- len 1)))
                     (is_palindrome_iter (substring text 1 (- len 1)) (- len 2)))
                #t
                #f))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:32:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:33:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:34:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:35:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:36:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp661p6hlq.rkt:37:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (if (= n 0)
        s
        (rotate (- n 1)
                (string-append (substring s 1)
                               (substring s 0 1)))))
  (define (encrypt-helper s)
    (if (empty? s)
        ""
        (string-append (rotate 2 (string-append (substring s 0 1) ""))
                       (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:35:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:36:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:37:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:38:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:39:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:40:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:41:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp66fida15.rkt:42:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o") (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|") (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|") (cons 1 (parse_music (substring music_string 2)))]
    [else (parse_music (substring music_string 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:29:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o") (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|") (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|") (cons 1 (parse_music (substring music_string 2)))]
    [else (parse_music (substring music_string 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:29:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o") (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|") (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|") (cons 1 (parse_music (substring music_string 2)))]
    [else (parse_music (substring music_string 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:29:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o") (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|") (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|") (cons 1 (parse_music (substring music_string 2)))]
    [else (parse_music (substring music_string 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:29:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o") (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|") (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|") (cons 1 (parse_music (substring music_string 2)))]
    [else (parse_music (substring music_string 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:29:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o") (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|") (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|") (cons 1 (parse_music (substring music_string 2)))]
    [else (parse_music (substring music_string 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6cpm7j70.rkt:29:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j)) (iter text (+ i 1) (- j 1))]
      [else #f]))
  (iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6gdb0q8_.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (null? string)
        string
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (find-palindrome-suffix string)
    (if (null? string)
        ""
        (if (equal? string (reverse string))
            string
            (find-palindrome-suffix (substring string 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6tlsgs_8.rkt:31:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6tlsgs_8.rkt:32:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6tlsgs_8.rkt:33:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6tlsgs_8.rkt:34:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6tlsgs_8.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ucxu4ib.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (define (find_prefix string)
    (substring string 0 (- (string-length (find_longest_palindrome string)) 1)))
  (string-append string (reverse (find_prefix string))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7ycgday4.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7ycgday4.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7ycgday4.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7ycgday4.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7ycgday4.rkt:40:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome-helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome-helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80c8cx3s.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (palindrome-helper text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (palindrome-helper text (+ left 1) (- right 1))
            #f)))
  (palindrome-helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fnstuk_.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-helper text left right)
    (cond
      [(= left right) #t]
      [(= (+ left 1) right) #t]
      [(char=? (string-ref text left) (string-ref text right))
       (is_palindrome-helper text (+ left 1) (- right 1))]
      [else #f]))
  (is_palindrome-helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8kqdhx77.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8u1oi8gj.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (string (char-downcase (rotate (string (char-upcase (string-ref s 0)))) 2))
                       (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "H"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:32:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "A"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:33:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "G"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:34:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "E"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:35:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "F"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:36:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "H"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "D"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8wjdc85a.rkt:38:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "A"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (cond
      [(= left right) #t]
      [(= (+ left 1) right) #t]
      [(char=? (string-ref text left) (string-ref text right))
       (is_palindrome_iter text (+ left 1) (- right 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp95ubpr2u.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 1) (substring s 1 2))
                 (string-append (substring s 2 3) (substring s 3 4))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:25:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:26:4
actual:     "asdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:27:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:28:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:29:4
actual:     "faew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:30:4
actual:     "hell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:31:4
actual:     "dxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 1) (substring s 1 2))
                 (string-append (substring s 2 3) (substring s 3 4))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:25:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:26:4
actual:     "asdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:27:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:28:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:29:4
actual:     "faew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:30:4
actual:     "hell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:31:4
actual:     "dxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 1) (substring s 1 2))
                 (string-append (substring s 2 3) (substring s 3 4))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:25:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:26:4
actual:     "asdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:27:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:28:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:29:4
actual:     "faew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:30:4
actual:     "hell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:31:4
actual:     "dxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp98pwjse_.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (cond
    [(empty? s) 0]
    [(= (remainder (string-length s) 2) 0)
     (cond
       [(char-upper-case? (string-ref s 0)) (+ 1 (count_upper (substring s 1)))]
       [else (count_upper (substring s 1))])]
    [else (count_upper (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (cond
    [(empty? s) 0]
    [(= (remainder (string-length s) 2) 0)
     (cond
       [(char-upper-case? (string-ref s 0)) (+ 1 (count_upper (substring s 1)))]
       [else (count_upper (substring s 1))])]
    [else (count_upper (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (cond
    [(empty? s) 0]
    [(= (remainder (string-length s) 2) 0)
     (cond
       [(char-upper-case? (string-ref s 0)) (+ 1 (count_upper (substring s 1)))]
       [else (count_upper (substring s 1))])]
    [else (count_upper (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9ezbjil5.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(string-ref text i) (string-ref text j)]
      [else (is_palindrome_helper text (+ i 1) (- j 1))]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:27:4
actual:     #\a
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:28:4
actual:     #\a
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:29:4
actual:     #\d
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:30:4
actual:     #\x
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:31:4
actual:     #\z
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9mdhq4xx.rkt:32:4
actual:     #\x
expected:   #f
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (find-palindrome-suffix string)
    (let loop ((string string)
               (suffix ""))
      (if (empty? string)
          suffix
          (if (equal? (reverse (substring string 0 (add1 (string-length suffix))))
                      (substring string 0 (add1 (string-length suffix))))
              (loop (substring string 1) (string-append (substring string 0 1) suffix))
              suffix))))
  (string-append string (reverse (substring string 0 (sub1 (string-length (find-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9pwle2ye.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9pwle2ye.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9pwle2ye.rkt:36:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9pwle2ye.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9pwle2ye.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_14_all_prefixes --------
#lang racket

;; Return list of all prefixes from shortest to longest of the input string
;; >>> (all_prefixes "abc")
;; (list "a" "ab" "abc")
(define (all_prefixes string)
  (define (all_prefixes_helper string prefixes)
    (if (empty? string)
        prefixes
        (all_prefixes_helper (substring string 1) (cons (substring string 0 1) prefixes))))
  (all_prefixes_helper string '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate all_prefixes))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "asdfgh") (list "a" "as" "asd" "asdf" "asdfg" "asdfgh"))
    (check-equal? (candidate "WWW") (list "W" "WW" "WWW"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9va3jdql.rkt:18:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9va3jdql.rkt:19:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9va3jdql.rkt:20:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond
    [(empty? music_string) empty]
    [(string=? (substring music_string 0 1) "o")
     (cons 4 (parse_music (substring music_string 1)))]
    [(string=? (substring music_string 0 2) "o|")
     (cons 2 (parse_music (substring music_string 2)))]
    [(string=? (substring music_string 0 2) ".|")
     (cons 1 (parse_music (substring music_string 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:28:4
actual:     '(4 . #<void>)
expected:   '(4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:29:4
actual:     '(1 . #<void>)
expected:   '(1 1 1 1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:30:4
actual:     '(4 . #<void>)
expected:   '(2 2 1 1 4 4 4 4)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zrtbwhh.rkt:31:4
actual:     '(4 . #<void>)
expected:   '(2 1 2 1 4 2 4 2)
--------------------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (cond
    [(empty? num) 0]
    [(char-numeric? (string-ref num 0))
     (hex_key (substring num 1))]
    [(char=? (string-ref num 0) #\A)
     (hex_key (substring num 1))]
    [(char=? (string-ref num 0) #\B)
     (+ 1 (hex_key (substring num 1)))]
    [(char=? (string-ref num 0) #\C)
     (hex_key (substring num 1))]
    [(char=? (string-ref num 0) #\D)
     (+ 1 (hex_key (substring num 1)))]
    [(char=? (string-ref num 0) #\E)
     (hex_key (substring num 1))]
    [(char=? (string-ref num 0) #\F)
     (hex_key (substring num 1))]
    [else (+ 1 (hex_key (substring num 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_33ir6gf.rkt:48:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_33ir6gf.rkt:49:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_33ir6gf.rkt:50:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_33ir6gf.rkt:51:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_33ir6gf.rkt:52:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_33ir6gf.rkt:53:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (char-upcase (string-ref s 0)) (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string-ref s 0) (solve (substring s 1)))]
    [else (string-append (char-downcase (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a8x2ld0.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (if (or (= i j) (= i (- j 1)))
        #t
        (if (char=? (string-ref text i) (string-ref text j))
            (is_palindrome_helper text (+ i 1) (- j 1))
            #f)))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_mr6s1qm.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-iter string suffix)
      (if (string=? (reverse suffix) string)
          suffix
          (find-longest-palindrome-suffix-iter string (string-append suffix (substring string (string-length suffix) (add1 (string-length suffix)))))))
    (find-longest-palindrome-suffix-iter string ""))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_tvq_q2a.rkt:33:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_tvq_q2a.rkt:35:4

substring: ending index is out of range
  ending index: 6
  valid range: [0, 5]
  string: "jerry"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 2) (substring s 4 6))
                 (substring s 2 4)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:25:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:26:4
actual:     "asghdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:27:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:29:4
actual:     "fafaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:30:4
actual:     "heomll"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:31:4
actual:     "dxlmzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 2) (substring s 4 6))
                 (substring s 2 4)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:25:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:26:4
actual:     "asghdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:27:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:29:4
actual:     "fafaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:30:4
actual:     "heomll"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:31:4
actual:     "dxlmzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 2) (substring s 4 6))
                 (substring s 2 4)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:25:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:26:4
actual:     "asghdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:27:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:29:4
actual:     "fafaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:30:4
actual:     "heomll"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:31:4
actual:     "dxlmzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_w7yvku7.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(= (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:29:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:30:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:33:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(= (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:29:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:30:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0jpx_tf.rkt:33:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_1_separate_paren_groups --------
#lang racket

;; Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
;; separate those group into separate strings and return the list of those.
;; Separate groups are balanced (each open brace is properly closed) and not nested within each other
;; Ignore any spaces in the input string.
;; >>> (separate_paren_groups "( ) (( )) (( )( ))")
;; (list "()" "(())" "(()())")
(define (separate_paren_groups paren_string)
  (cond
    [(empty? paren_string) empty]
    [(string=? (substring paren_string 0 1) " ") (separate_paren_groups (substring paren_string 1))]
    [(string=? (substring paren_string 0 1) "(")
     (cons (separate_paren_groups (substring paren_string 1))
           (separate_paren_groups (substring paren_string 1)))]
    [(string=? (substring paren_string 0 1) ")")
     (cons (substring paren_string 0 1)
           (separate_paren_groups (substring paren_string 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate separate_paren_groups))
    (check-equal? (candidate "(()()) ((())) () ((())()())") (list "(()())" "((()))" "()" "((())()())"))
    (check-equal? (candidate "() (()) ((())) (((())))") (list "()" "(())" "((()))" "(((())))"))
    (check-equal? (candidate "(()(())((())))") (list "(()(())((())))"))
    (check-equal? (candidate "( ) (( )) (( )( ))") (list "()" "(())" "(()())"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpab42l5_g.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpab42l5_g.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpab42l5_g.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpab42l5_g.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (cond [(string=? num "") 0]
        [else (let ([n (string->number num 16)])
                (cond [(member n '(2 3 5 7 11 13)) 1]
                      [else (+ (hex_key (substring num 1))
                               (hex_key (substring num 2)))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpapfcm7rb.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "E"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpapfcm7rb.rkt:38:4
actual:     21
expected:   4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpapfcm7rb.rkt:39:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "0"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpapfcm7rb.rkt:40:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "0"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpapfcm7rb.rkt:41:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "0"
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (string-append
   (if (string=? (substring a 0 1) "1") "0" "1")
   (if (string=? (substring a 1 1) "1") "0" "1")
   (if (string=? (substring a 2 1) "1") "0" "1")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpawaft7hg.rkt:18:4

substring: ending index is smaller than starting index
  ending index: 1
  starting index: 2
  valid range: [0, 6]
  string: "111000"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpawaft7hg.rkt:19:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "1"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpawaft7hg.rkt:20:4

substring: ending index is smaller than starting index
  ending index: 1
  starting index: 2
  valid range: [0, 4]
  string: "0101"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (iter text left right)
    (cond
      [(or (empty? text) (= left right)) #t]
      [(char=? (string-ref text left) (string-ref text right))
       (iter text (+ left 1) (- right 1))]
      [else #f]))
  (iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb9ajc36r.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (or (= len 0) (= len 1))
        #t
        (and (char=? (string-ref text 0) (string-ref text (- len 1)))
             (is_palindrome_iter (substring text 1 (- len 2)) (- len 2)))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbipgwidb.rkt:27:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbipgwidb.rkt:29:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbipgwidb.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (or (= len 0) (= len 1))
        #t
        (and (char=? (string-ref text 0) (string-ref text (- len 1)))
             (is_palindrome_iter (substring text 1 (- len 2)) (- len 2)))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbipgwidb.rkt:27:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbipgwidb.rkt:29:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbipgwidb.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (define (is-upper? c)
    (and (char-alphabetic? c) (char-upper-case? c)))
  (define (is-vowel? c)
    (or (char=? c #\a) (char=? c #\e) (char=? c #\i) (char=? c #\o) (char=? c #\u)))
  (define (is-even? n)
    (= (remainder n 2) 0))
  (define (count-upper-vowels-in-even-indices s)
    (cond
      [(empty? s) 0]
      [(is-even? (string-length s))
       (if (and (is-upper? (string-ref s 0)) (is-vowel? (string-ref s 0)))
           (+ 1 (count-upper-vowels-in-even-indices (substring s 1)))
           (count-upper-vowels-in-even-indices (substring s 1)))]
      [else (count-upper-vowels-in-even-indices (substring s 1))]))
  (count-upper-vowels-in-even-indices s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbsrh8jka.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (null? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (null? string)
        #t
        (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbvk_gk54.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbvk_gk54.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbvk_gk54.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbvk_gk54.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbvk_gk54.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (longest_palindrome_suffix string)
    (if (empty? string)
        ""
        (if (equal? (reverse string) string)
            string
            (longest_palindrome_suffix (substring string 1)))))
  (define (longest_palindrome_prefix string)
    (if (empty? string)
        ""
        (if (equal? (reverse string) string)
            string
            (longest_palindrome_prefix (substring string 0 (- (string-length string) 1))))))
  (string-append string (reverse (longest_palindrome_prefix string))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2rwdlhz.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2rwdlhz.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2rwdlhz.rkt:39:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2rwdlhz.rkt:40:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2rwdlhz.rkt:41:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j)) (helper text (+ i 1) (- j 1))]
      [else #f]))
  (helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc575x3wm.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j)) (helper text (+ i 1) (- j 1))]
      [else #f]))
  (helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc575x3wm.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (define (is_palindrome_helper string1 string2)
      (if (empty? string1)
          #t
          (and (char=? (string-ref string1 0) (string-ref string2 0))
               (is_palindrome_helper (substring string1 1) (substring string2 1)))))
    (is_palindrome_helper string (reverse string)))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (define (find_prefix string)
    (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))
  (string-append string (reverse (find_prefix string))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6txw940.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6txw940.rkt:39:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6txw940.rkt:40:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6txw940.rkt:41:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc6txw940.rkt:42:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (= len 1)
        #t
        (if (= len 2)
            (equal? (string-ref text 0) (string-ref text 1))
            (and (equal? (string-ref text 0) (string-ref text (- len 1)))
                 (is_palindrome_iter (substring text 1 (- len 2)) (- len 2))))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:29:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:33:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (= len 1)
        #t
        (if (= len 2)
            (equal? (string-ref text 0) (string-ref text 1))
            (and (equal? (string-ref text 0) (string-ref text (- len 1)))
                 (is_palindrome_iter (substring text 1 (- len 2)) (- len 2))))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:29:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:33:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (= len 1)
        #t
        (if (= len 2)
            (equal? (string-ref text 0) (string-ref text 1))
            (and (equal? (string-ref text 0) (string-ref text (- len 1)))
                 (is_palindrome_iter (substring text 1 (- len 2)) (- len 2))))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:29:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:33:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (if (= len 1)
        #t
        (if (= len 2)
            (equal? (string-ref text 0) (string-ref text 1))
            (and (equal? (string-ref text 0) (string-ref text (- len 1)))
                 (is_palindrome_iter (substring text 1 (- len 2)) (- len 2))))))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:29:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcbf0r969.rkt:33:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (string (rotate s)) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:30:4

string: contract violation
  expected: char?
  given: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:31:4

string: contract violation
  expected: char?
  given: "dfghjklas"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:32:4

string: contract violation
  expected: char?
  given: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:33:4

string: contract violation
  expected: char?
  given: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:34:4

string: contract violation
  expected: char?
  given: "ewfawefaewgfa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:35:4

string: contract violation
  expected: char?
  given: "llomyfriendhe"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:36:4

string: contract violation
  expected: char?
  given: "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (string (rotate s)) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:30:4

string: contract violation
  expected: char?
  given: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:31:4

string: contract violation
  expected: char?
  given: "dfghjklas"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:32:4

string: contract violation
  expected: char?
  given: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:33:4

string: contract violation
  expected: char?
  given: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:34:4

string: contract violation
  expected: char?
  given: "ewfawefaewgfa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:35:4

string: contract violation
  expected: char?
  given: "llomyfriendhe"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:36:4

string: contract violation
  expected: char?
  given: "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (string (rotate s)) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:30:4

string: contract violation
  expected: char?
  given: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:31:4

string: contract violation
  expected: char?
  given: "dfghjklas"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:32:4

string: contract violation
  expected: char?
  given: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:33:4

string: contract violation
  expected: char?
  given: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:34:4

string: contract violation
  expected: char?
  given: "ewfawefaewgfa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:35:4

string: contract violation
  expected: char?
  given: "llomyfriendhe"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:36:4

string: contract violation
  expected: char?
  given: "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (string (rotate s)) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:30:4

string: contract violation
  expected: char?
  given: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:31:4

string: contract violation
  expected: char?
  given: "dfghjklas"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:32:4

string: contract violation
  expected: char?
  given: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:33:4

string: contract violation
  expected: char?
  given: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:34:4

string: contract violation
  expected: char?
  given: "ewfawefaewgfa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:35:4

string: contract violation
  expected: char?
  given: "llomyfriendhe"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:36:4

string: contract violation
  expected: char?
  given: "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcg8r7qgz.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse-string string)
    (define (reverse-string-helper string reversed-string)
      (if (string=? string "")
          reversed-string
          (reverse-string-helper (substring string 1) (string-append (substring string 0 1) reversed-string))))
    (reverse-string-helper string ""))
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-helper string suffix)
      (if (string=? string "")
          suffix
          (if (string=? (substring string 0 1) (substring string (string-length string) (- (string-length string) 1)))
              (find-longest-palindrome-suffix-helper (substring string 1) (substring string 0 1))
              (find-longest-palindrome-suffix-helper (substring string 1) suffix))))
    (find-longest-palindrome-suffix-helper string ""))
  (string-append string (reverse-string (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcmw8v1b5.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcmw8v1b5.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 2
  starting index: 3
  valid range: [0, 3]
  string: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcmw8v1b5.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 2
  starting index: 3
  valid range: [0, 3]
  string: "xyx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcmw8v1b5.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 4
  starting index: 5
  valid range: [0, 5]
  string: "jerry"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        string
        (string-append (reverse (substring string 1)) (string (string-ref string 0)))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (define (find_longest_palindrome_prefix string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome_prefix (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpco5b9e22.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpco5b9e22.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpco5b9e22.rkt:40:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpco5b9e22.rkt:41:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpco5b9e22.rkt:42:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (define (parse_music_helper music_string acc)
    (cond
      [(empty? music_string) (reverse acc)]
      [(string=? (substring music_string 0 1) "o") (parse_music_helper (substring music_string 1) (cons 4 acc))]
      [(string=? (substring music_string 0 2) "o|") (parse_music_helper (substring music_string 2) (cons 2 acc))]
      [(string=? (substring music_string 0 2) ".|") (parse_music_helper (substring music_string 2) (cons 1 acc))]
      [else (parse_music_helper (substring music_string 1) acc)]))
  (parse_music_helper music_string '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvl0yvy2.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvl0yvy2.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvl0yvy2.rkt:29:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvl0yvy2.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvl0yvy2.rkt:31:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond [(empty? S) 0]
        [else
         (cond [(string=? (substring S 0 2) "I ")
                (+ 1 (is_bored (substring S 2 (string-length S))))]
               [else (is_bored (substring S 1 (string-length S)))])]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd6oa6745.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd6oa6745.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd6oa6745.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd6oa6745.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd6oa6745.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd6oa6745.rkt:28:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (rotate s) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:30:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "l"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:32:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "f"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:33:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:34:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "g"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:35:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:36:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "h"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (rotate s) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:30:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "l"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:32:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "f"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:33:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:34:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "g"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:35:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:36:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "h"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (if (string=? s "")
        ""
        (string-append (rotate s) (encrypt-helper (substring s 1)))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:30:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "l"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:32:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "f"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:33:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:34:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "g"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:35:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:36:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "h"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpd7fcsjnc.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_67_fruit_distribution --------
#lang racket

;; In this task, you will be given a string that represents a number of apples and oranges 
;; that are distributed in a basket of fruit this basket contains 
;; apples, oranges, and mango fruits. Given the string that represents the total number of 
;; the oranges and apples and an integer that represent the total number of the fruits 
;; in the basket return the number of the mango fruits in the basket.
;; for examble:
;; >>> (fruit_distribution "5 apples and 6 oranges" 19)
;; 8
;; >>> (fruit_distribution "0 apples and 1 oranges" 3)
;; 2
;; >>> (fruit_distribution "2 apples and 3 oranges" 100)
;; 95
;; >>> (fruit_distribution "100 apples and 1 oranges" 120)
;; 19
(define (fruit_distribution s n)
  (define (count-fruit s)
    (cond
      [(empty? s) 0]
      [(string=? (substring s 0 6) "apples")
       (+ (string->number (substring s 0 1)) (count-fruit (substring s 7)))]
      [(string=? (substring s 0 7) "oranges")
       (+ (string->number (substring s 0 1)) (count-fruit (substring s 8)))]
      [else (count-fruit (substring s 1))]))
  (- n (count-fruit s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fruit_distribution))
    (check-equal? (candidate "5 apples and 6 oranges" 19) 8)
    (check-equal? (candidate "5 apples and 6 oranges" 21) 10)
    (check-equal? (candidate "0 apples and 1 oranges" 3) 2)
    (check-equal? (candidate "1 apples and 0 oranges" 3) 2)
    (check-equal? (candidate "2 apples and 3 oranges" 100) 95)
    (check-equal? (candidate "2 apples and 3 oranges" 5) 0)
    (check-equal? (candidate "1 apples and 100 oranges" 120) 19)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:33:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:34:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:35:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:36:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:37:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:38:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdetg4hfs.rkt:39:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string-append
       (string (char-downcase (string-ref s 0)))
       (string (char-upcase (string-ref s 0))))
      (solve (substring s 1)))]
    [else
     (string-append
      (string (string-ref s 0))
      (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdw87e2qv.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (is-vowel? c)
    (or (char=? c #\a)
        (char=? c #\e)
        (char=? c #\i)
        (char=? c #\o)
        (char=? c #\u)))
  (define (is-consonant? c)
    (not (is-vowel? c)))
  (define (get-vowel-index word)
    (let loop ((i (sub1 (string-length word))))
      (cond ((< i 0) #f)
            ((and (is-vowel? (string-ref word i))
                  (is-consonant? (string-ref word (sub1 i)))
                  (is-consonant? (string-ref word (add1 i))))
             i)
            (else (loop (sub1 i))))))
  (define (get-vowel word)
    (let ((i (get-vowel-index word)))
      (if i (string (string-ref word i)) "")))
  (get-vowel word))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:46:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "easy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:47:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "eAsy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:48:4

string-ref: index is out of range
  index: 3
  valid range: [0, 2]
  string: "ali"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:51:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "ab"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:52:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ba"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:54:4

string-ref: index is out of range
  index: 5
  valid range: [0, 4]
  string: "anime"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdyc0koy7.rkt:56:4

string-ref: index is out of range
  index: 5
  valid range: [0, 4]
  string: "Above"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate-string s n)
    (string-append (substring s n) (substring s 0 n)))
  (define (rotate-char c n)
    (integer->char (+ (char->integer c) n)))
  (define (rotate-char-string s n)
    (map (lambda (c) (rotate-char c n)) s))
  (define (rotate-char-string-by-two s)
    (rotate-char-string s (* 2 2)))
  (string->list (rotate-string s 2))
  (rotate-char-string-by-two s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:33:4

map: contract violation
  expected: list?
  given: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:34:4

map: contract violation
  expected: list?
  given: "asdfghjkl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:35:4

map: contract violation
  expected: list?
  given: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:36:4

map: contract violation
  expected: list?
  given: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:37:4

map: contract violation
  expected: list?
  given: "faewfawefaewg"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:38:4

map: contract violation
  expected: list?
  given: "hellomyfriend"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:39:4

map: contract violation
  expected: list?
  given: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe9ozb3_f.rkt:40:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate-string s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (rotate-char c)
    (integer->char (+ (char->integer c) 2)))
  (define (rotate-char-list l)
    (map rotate-char l))
  (string-append (rotate-string s) (rotate-char-list s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:30:4

map: contract violation
  expected: list?
  given: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:31:4

map: contract violation
  expected: list?
  given: "asdfghjkl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:32:4

map: contract violation
  expected: list?
  given: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:33:4

map: contract violation
  expected: list?
  given: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:34:4

map: contract violation
  expected: list?
  given: "faewfawefaewg"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:35:4

map: contract violation
  expected: list?
  given: "hellomyfriend"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:36:4

map: contract violation
  expected: list?
  given: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefjz_r8r.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (is_palindrome string)
    (define (iter string left right)
      (cond
        [(= left right) #t]
        [(= (string-ref string left) (string-ref string right)) (iter string (+ left 1) (- right 1))]
        [else #f]))
    (iter string 0 (- (string-length string) 1)))
  (define (find_longest_palindrome string)
    (define (iter string left right)
      (cond
        [(= left right) string]
        [(is_palindrome string) string]
        [else (iter (substring string 0 (- right 1)) left (- right 1))]))
    (iter string 0 (- (string-length string) 1)))
  (define (reverse string)
    (define (iter string result)
      (cond
        [(empty? string) result]
        [else (iter (rest string) (string-append (list (first string)) result))]))
    (iter string ""))
  (string-append string (reverse (substring string 0 (- (string-length (find_longest_palindrome string)) 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeka4td05.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeka4td05.rkt:42:4

rest: contract violation
  expected: (and/c list? (not/c empty?))
  given: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeka4td05.rkt:43:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeka4td05.rkt:44:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeka4td05.rkt:45:4

=: contract violation
  expected: number?
  given: #\j
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse-string string)
    (define (reverse-string-iter string result)
      (if (string=? string "")
          result
          (reverse-string-iter (substring string 1) (string-append (substring string 0 1) result))))
    (reverse-string-iter string ""))
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-iter string result)
      (if (string=? (substring string 0 1) (substring string (string-length string) (- (string-length string) 1)))
          (find-longest-palindrome-suffix-iter (substring string 1) (string-append (substring string 0 1) result))
          result))
    (find-longest-palindrome-suffix-iter string ""))
  (string-append string (reverse-string (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf25bko1o.rkt:32:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf25bko1o.rkt:33:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf25bko1o.rkt:34:4

substring: ending index is smaller than starting index
  ending index: 2
  starting index: 3
  valid range: [0, 3]
  string: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf25bko1o.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 2
  starting index: 3
  valid range: [0, 3]
  string: "xyx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf25bko1o.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 4
  starting index: 5
  valid range: [0, 5]
  string: "jerry"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-helper text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((= (string-ref text i) (string-ref text j))
           (is_palindrome-helper text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome-helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf70vy90w.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (string-append (substring s n) (substring s 0 n)))
  (rotate (* 2 2) s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (string-append (substring s n) (substring s 0 n)))
  (rotate (* 2 2) s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (string-append (substring s n) (substring s 0 n)))
  (rotate (* 2 2) s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (string-append (substring s n) (substring s 0 n)))
  (rotate (* 2 2) s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (string-append (substring s n) (substring s 0 n)))
  (rotate (* 2 2) s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpflhzy0sl.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (make_palindrome-helper string)
    (if (string=? string "")
        (values "" "")
        (let* ([first-char (substring string 0 1)]
               [rest-string (substring string 1)])
          (let-values ([(longest-palindrome-suffix rest-string-without-longest-palindrome-suffix) (make_palindrome-helper rest-string)])
            (if (string=? first-char (substring longest-palindrome-suffix 0 1))
                (values (string-append first-char longest-palindrome-suffix) rest-string-without-longest-palindrome-suffix)
                (values longest-palindrome-suffix (string-append first-char rest-string-without-longest-palindrome-suffix)))))))
  (let-values ([(longest-palindrome-suffix rest-string-without-longest-palindrome-suffix) (make_palindrome-helper string)])
    (string-append string (reverse rest-string-without-longest-palindrome-suffix))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwnnb33j.rkt:31:4

reverse: contract violation
  expected: list?
  given: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwnnb33j.rkt:32:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwnnb33j.rkt:33:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwnnb33j.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfwnnb33j.rkt:35:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 2) (substring s 4 6)) (substring s 2 4)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:24:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:25:4
actual:     "asghdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:27:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:28:4
actual:     "fafaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:29:4
actual:     "heomll"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:30:4
actual:     "dxlmzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg8vktagq.rkt:31:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string-ref s 0) (solve (substring s 1)))]
    [else
     (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:30:4

string-upcase: contract violation
  expected: string?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:32:4

string-upcase: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:33:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:34:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:35:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:36:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpglr7ylq9.rkt:37:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (sub1 (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append
           (string (string-ref s 0))
           (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:36:4

sub1: contract violation
  expected: number?
  given: #\1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:39:4

sub1: contract violation
  expected: number?
  given: #\4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:40:4

sub1: contract violation
  expected: number?
  given: #\6
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph4t40bvl.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (string-upcase (substring S 0 1)) "I") (+ 1 (is_bored (substring S 1)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph5hv74vr.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph5hv74vr.rkt:23:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph5hv74vr.rkt:24:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph5hv74vr.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph5hv74vr.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph5hv74vr.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (cond
    [(empty? num) 0]
    [(char-numeric? (string-ref num 0)) (hex_key (substring num 1))]
    [(char-alphabetic? (string-ref num 0))
     (cond
       [(or (= (string-ref num 0) #\A)
            (= (string-ref num 0) #\B)
            (= (string-ref num 0) #\C)
            (= (string-ref num 0) #\D)
            (= (string-ref num 0) #\E)
            (= (string-ref num 0) #\F))
        (+ 1 (hex_key (substring num 1)))]
       [else (hex_key (substring num 1))])]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph688ap8f.rkt:44:4

=: contract violation
  expected: number?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph688ap8f.rkt:45:4

=: contract violation
  expected: number?
  given: #\E
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph688ap8f.rkt:46:4

=: contract violation
  expected: number?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph688ap8f.rkt:47:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph688ap8f.rkt:48:4

=: contract violation
  expected: number?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph688ap8f.rkt:49:4

=: contract violation
  expected: number?
  given: #\A
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (let loop ([music_string music_string]
             [result '()])
    (cond
      [(empty? music_string) (reverse result)]
      [(string=? (substring music_string 0 1) "o")
       (loop (substring music_string 1) (cons 4 result))]
      [(string=? (substring music_string 0 2) "o|")
       (loop (substring music_string 2) (cons 2 result))]
      [(string=? (substring music_string 0 2) ".|")
       (loop (substring music_string 2) (cons 1 result))]
      [else (error 'loop "Invalid music string")])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:31:4

loop: Invalid music string
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:32:4

loop: Invalid music string
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:33:4

loop: Invalid music string
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_k9megb.rkt:34:4

loop: Invalid music string
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (iter text left right)
    (cond ((= left right) #t)
          ((= (+ left 1) right) #t)
          ((char=? (string-ref text left) (string-ref text right))
           (iter text (+ left 1) (- right 1)))
          (else #f)))
  (iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphr0_gbn0.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (null? string)
        ""
        (string-append (reverse (substring string 1)) (string (string-ref string 0)))))
  (define (longest_palindrome_suffix string)
    (define (is_palindrome? string)
      (if (or (null? string) (= (string-length string) 1))
          #t
          (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
               (is_palindrome? (substring string 1 (- (string-length string) 1))))))
    (if (is_palindrome? string)
        string
        (longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphs6fpbxo.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphs6fpbxo.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphs6fpbxo.rkt:36:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphs6fpbxo.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphs6fpbxo.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (longest-palindrome string)
    (define (palindrome? string)
      (if (empty? string)
          #t
          (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
               (palindrome? (substring string 1 (- (string-length string) 1))))))
    (define (longest-palindrome-helper string)
      (if (palindrome? string)
          string
          (longest-palindrome-helper (substring string 0 (- (string-length string) 1)))))
    (longest-palindrome-helper string))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (longest-palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphsb40gxp.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphsb40gxp.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphsb40gxp.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphsb40gxp.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphsb40gxp.rkt:40:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (cond
    [(empty? a) b]
    [(empty? b) a]
    [else
     (string-append
      (if (char=? (string-ref a 0) (string-ref b 0)) "0" "1")
      (string_xor (substring a 1) (substring b 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvd9oaiv.rkt:21:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvd9oaiv.rkt:22:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvd9oaiv.rkt:23:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (cond
    [(empty? a) b]
    [(empty? b) a]
    [else
     (string-append
      (if (char=? (string-ref a 0) (string-ref b 0)) "0" "1")
      (string_xor (substring a 1) (substring b 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvd9oaiv.rkt:21:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvd9oaiv.rkt:22:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvd9oaiv.rkt:23:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_helper text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14w1yi6.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) (char=? (string-ref text i) (string-ref text j))]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpie0covf1.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text len)
    (cond ((= len 0) #t)
          ((= len 1) #t)
          ((char=? (string-ref text 0) (string-ref text (- len 1)))
           (is_palindrome_iter (substring text 1 (- len 2)) (- len 2)))
          (else #f)))
  (is_palindrome_iter text (string-length text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpikfd4uaq.rkt:28:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "aa"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpikfd4uaq.rkt:30:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpikfd4uaq.rkt:32:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "yw"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (cond ((string=? s "") "")
          (else (string-append (rotate s) (encrypt-helper (substring s 1))))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:29:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:30:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "l"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "f"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:32:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:33:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "g"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:34:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:35:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "h"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpir3cd3vm.rkt:36:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-helper text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome-helper text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyqwlhvu.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj9abxw5o.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond [(= i j) #t]
          [(= (+ i 1) j) #t]
          [(char=? (string-ref text i) (string-ref text j))
           (is_palindrome_iter text (+ i 1) (- j 1))]
          [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj_aauj08.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond [(= i j) #t]
          [(= (+ i 1) j) #t]
          [(char=? (string-ref text i) (string-ref text j))
           (is_palindrome_iter text (+ i 1) (- j 1))]
          [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj_aauj08.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (cond
    [(empty? a) b]
    [(empty? b) a]
    [else
     (string-append
      (string
       (if (eq? (string-ref a 0) (string-ref b 0))
           #\0
           #\1))
      (string_xor (substring a 1) (substring b 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjduzbepi.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjduzbepi.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjduzbepi.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (if (empty? s)
      0
      (+ (if (char-upper-case? (string-ref s 0))
             (char->integer (string-ref s 0))
             0)
         (digitSum (substring s 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjdwq46n2.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (if (equal? a b)
        #\0
        #\1))
  (define (xor-string a b)
    (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))
                   (xor-string (substring a 1) (substring b 1))))
  (xor-string a b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjw7j66h.rkt:22:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjw7j66h.rkt:23:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjjw7j66h.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (null? string)
        ""
        (string-append (reverse (substring string 1)) (string (string-ref string 0)))))
  (define (is_palindrome string)
    (string=? string (reverse string)))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjtp1y232.rkt:31:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjtp1y232.rkt:32:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjtp1y232.rkt:33:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjtp1y232.rkt:34:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjtp1y232.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyzw0dtz.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(string=? S "") 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(string=? S "") 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(string=? S "") 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(string=? S "") 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk1le65sw.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text left right)
    (cond
      [(= left right) #t]
      [(= (+ left 1) right) #t]
      [(= (string-ref text left) (string-ref text right))
       (is_palindrome_helper text (+ left 1) (- right 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:29:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:30:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkmyogegf.rkt:33:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((= (string-ref text i) (string-ref text j))
           (is_palindrome_helper text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkr_hlxnw.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (if (or (= left right) (= left (- right 1)))
        #t
        (if (char=? (string-ref text left) (string-ref text right))
            (is_palindrome-iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl25dsauy.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (cond
    [(empty? num) 0]
    [(char-numeric? (string-ref num 0))
     (hex_key (substring num 1))]
    [(char-alphabetic? (string-ref num 0))
     (cond
       [(or (= (string-ref num 0) #\B)
            (= (string-ref num 0) #\D))
        (+ 1 (hex_key (substring num 1)))]
       [else (hex_key (substring num 1))])]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl8g7ala_.rkt:41:4

=: contract violation
  expected: number?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl8g7ala_.rkt:42:4

=: contract violation
  expected: number?
  given: #\E
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl8g7ala_.rkt:43:4

=: contract violation
  expected: number?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl8g7ala_.rkt:44:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl8g7ala_.rkt:45:4

=: contract violation
  expected: number?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl8g7ala_.rkt:46:4

=: contract violation
  expected: number?
  given: #\A
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) s]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string-ref s 0) (solve (substring s 1)))]
    [else (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:29:4

string-upcase: contract violation
  expected: string?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:31:4

string-upcase: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:32:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:33:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:34:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:35:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmple5xqn0a.rkt:36:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (or (= left right)
            (= (- right left) 1))
        #t
        (if (string-ci=? (string-ref text left)
                         (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:29:4

string-ci=?: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:30:4

string-ci=?: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:31:4

string-ci=?: contract violation
  expected: string?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:32:4

string-ci=?: contract violation
  expected: string?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:33:4

string-ci=?: contract violation
  expected: string?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplnvs41g_.rkt:34:4

string-ci=?: contract violation
  expected: string?
  given: #\x
--------------------

==========================
------- Program HumanEval_14_all_prefixes --------
#lang racket

;; Return list of all prefixes from shortest to longest of the input string
;; >>> (all_prefixes "abc")
;; (list "a" "ab" "abc")
(define (all_prefixes string)
  (define (all_prefixes_iter string prefixes)
    (if (empty? string)
        prefixes
        (all_prefixes_iter (substring string 1) (cons (substring string 0 1) prefixes))))
  (all_prefixes_iter string '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate all_prefixes))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "asdfgh") (list "a" "as" "asd" "asdf" "asdfg" "asdfgh"))
    (check-equal? (candidate "WWW") (list "W" "WW" "WWW"))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpma7ctt0u.rkt:18:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpma7ctt0u.rkt:19:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpma7ctt0u.rkt:20:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string-ref s 0) (solve (substring s 1)))]
    [else
     (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:30:4

string-downcase: contract violation
  expected: string?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:32:4

string-downcase: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:33:4

string-upcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:34:4

string-upcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:35:4

string-upcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:36:4

string-upcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmgdcuwcy.rkt:37:4

string-upcase: contract violation
  expected: string?
  given: #\#
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (if (empty? s)
      ""
      (let ([c (string-ref s 0)])
        (if (char-alphabetic? c)
            (string-append (string (char-upcase c)) (solve (substring s 1)))
            (string-append (string c) (solve (substring s 1)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmq7rxg3z.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (= left right)
        #t
        (if (= (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmu3nqp0z.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (number->string (string->number (reverse (string-append (substring (number->string x) shift) (substring (number->string x) 0 shift))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8wy5d0d.rkt:18:4

reverse: contract violation
  expected: list?
  given: "010"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8wy5d0d.rkt:19:4

reverse: contract violation
  expected: list?
  given: "12"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8wy5d0d.rkt:20:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 2]
  string: "97"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8wy5d0d.rkt:21:4

reverse: contract violation
  expected: list?
  given: "21"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8wy5d0d.rkt:22:4

substring: starting index is out of range
  starting index: 101
  valid range: [0, 2]
  string: "11"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond
      [(> j i) #t]
      [(not (char=? (string-ref text i) (string-ref text j))) #f]
      [else (is_palindrome-iter text (+ i 1) (- j 1))]))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpndvoytut.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpndvoytut.rkt:28:4
actual:     #t
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpndvoytut.rkt:30:4
actual:     #t
expected:   #f
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpndvoytut.rkt:31:4
actual:     #t
expected:   #f
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (cond
      [(empty? text) #t]
      [(= left right) #t]
      [(char=? (string-ref text left) (string-ref text right))
       (is_palindrome_iter text (+ left 1) (- right 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnuj082q2.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text start end)
    (cond
      [(= start end) #t]
      [(= (+ start 1) end) #t]
      [(char=? (string-ref text start) (string-ref text end))
       (is_palindrome_helper text (+ start 1) (- end 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnvsyu0nl.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_helper text start end)
    (cond
      [(= start end) #t]
      [(= (+ start 1) end) #t]
      [(char=? (string-ref text start) (string-ref text end))
       (is_palindrome_helper text (+ start 1) (- end 1))]
      [else #f]))
  (is_palindrome_helper text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnvsyu0nl.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 1) (substring s 1 2))
                 (substring s 2 3)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:25:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:26:4
actual:     "asd"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:27:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:28:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:29:4
actual:     "fae"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:30:4
actual:     "hel"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:31:4
actual:     "dxz"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnyvmrcc2.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo0oolbcg.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (equal? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpodwj19lu.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpodwj19lu.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpodwj19lu.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (cond
    [(empty? s) 0]
    [(and (eq? (modulo (string-length s) 2) 0)
          (member (string-ref s 0) '("A" "E" "I" "O" "U")))
     (+ 1 (count_upper (substring s 1)))]
    [else (count_upper (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoq343r_x.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(string=? (string-ref text i) (string-ref text j))
       (is_palindrome-iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:28:4

string=?: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:29:4

string=?: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:30:4

string=?: contract violation
  expected: string?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:31:4

string=?: contract violation
  expected: string?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:32:4

string=?: contract violation
  expected: string?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoyp5rym0.rkt:33:4

string=?: contract violation
  expected: string?
  given: #\x
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) s]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string (char-upcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string (char-downcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0))
                         (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp8b6zh7y.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (define (parse_music_helper music_string acc)
    (cond ((null? music_string) acc)
          ((string=? (substring music_string 0 1) "o")
           (parse_music_helper (substring music_string 1) (append acc (list 4))))
          ((string=? (substring music_string 0 2) "o|")
           (parse_music_helper (substring music_string 2) (append acc (list 2))))
          ((string=? (substring music_string 0 2) ".|")
           (parse_music_helper (substring music_string 2) (append acc (list 1))))
          (else (parse_music_helper (substring music_string 1) acc))))
  (parse_music_helper music_string '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaydpusu.rkt:29:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaydpusu.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaydpusu.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaydpusu.rkt:32:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaydpusu.rkt:33:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "|"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate-char c)
    (integer->char (+ (char->integer c) (* 2 2))))
  (define (rotate-string s)
    (if (empty? s)
        ""
        (string-append (string (rotate-char (string-ref s 0)))
                       (rotate-string (substring s 1)))))
  (rotate-string s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppeeauw1s.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (is_vowel? c)
    (member c '("a" "e" "i" "o" "u" "A" "E" "I" "O" "U")))
  (define (is_consonant? c)
    (not (is_vowel? c)))
  (define (get-closest-vowel-helper word)
    (if (is_vowel? (string-ref word 0))
        (get-closest-vowel-helper (substring word 1))
        (if (is_consonant? (string-ref word 0))
            (if (is_vowel? (string-ref word 1))
                (string-ref word 1)
                (get-closest-vowel-helper (substring word 1)))
            "")))
  (get-closest-vowel-helper word))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:37:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:38:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "l"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:39:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:40:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:41:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:42:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:43:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:44:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "b"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:45:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "a"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:46:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "k"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppnjptf30.rkt:47:4

string-ref: index is out of
==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (string-append (substring s 0 1) (substring s 1 2))
                 (substring s 3)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:25:4

substring: starting index is out of range
  starting index: 3
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:26:4
actual:     "asfghjkl"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:27:4

substring: starting index is out of range
  starting index: 3
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:28:4

substring: starting index is out of range
  starting index: 3
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:29:4
actual:     "fawfawefaewg"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:30:4
actual:     "helomyfriend"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:31:4
actual:     "dxdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppurx7rr1.rkt:32:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s n)
    (string-append (substring s n) (substring s 0 n)))
  (rotate s (* 2 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s n)
    (string-append (substring s n) (substring s 0 n)))
  (rotate s (* 2 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:26:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:28:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:29:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppwffewcx.rkt:33:4

substring: starting index is out of range
  starting index: 4
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append
           (string (string-ref s 0))
           (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append
      (string (char-upcase (string-ref s 0)))
      (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append
      (string (char-downcase (string-ref s 0)))
      (solve (substring s 1)))]
    [else (string-append
           (string (string-ref s 0))
           (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq77bfu_a.rkt:42:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"\\.|\\?|!" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"\\.|\\?|!" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"\\.|\\?|!" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"\\.|\\?|!" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpqg_d3tgh.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (longest_palindrome string)
    (define (is_palindrome string)
      (if (empty? string)
          #t
          (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
               (is_palindrome (substring string 1 (- (string-length string) 1))))))
    (define (longest_palindrome_helper string)
      (if (is_palindrome string)
          string
          (longest_palindrome_helper (substring string 0 (- (string-length string) 1)))))
    (longest_palindrome_helper string))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlrd7zzs.rkt:36:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlrd7zzs.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlrd7zzs.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlrd7zzs.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlrd7zzs.rkt:40:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate-char c)
    (define (rotate-char-helper c)
      (cond
        [(char=? c #\a) #\c]
        [(char=? c #\b) #\d]
        [(char=? c #\c) #\e]
        [(char=? c #\d) #\f]
        [(char=? c #\e) #\g]
        [(char=? c #\f) #\h]
        [(char=? c #\g) #\i]
        [(char=? c #\h) #\j]
        [(char=? c #\i) #\k]
        [(char=? c #\j) #\l]
        [(char=? c #\k) #\m]
        [(char=? c #\l) #\n]
        [(char=? c #\m) #\o]
        [(char=? c #\n) #\p]
        [(char=? c #\o) #\q]
        [(char=? c #\p) #\r]
        [(char=? c #\q) #\s]
        [(char=? c #\r) #\t]
        [(char=? c #\s) #\u]
        [(char=? c #\t) #\v]
        [(char=? c #\u) #\w]
        [(char=? c #\v) #\x]
        [(char=? c #\w) #\y]
        [(char=? c #\x) #\z]
        [(char=? c #\y) #\a]
        [(char=? c #\z) #\b]
        [else c]))
    (rotate-char-helper (rotate-char-helper c)))
  (define (rotate-string s)
    (if (empty? s)
        ""
        (string-append (string (rotate-char (string-ref s 0)))
                       (rotate-string (substring s 1)))))
  (rotate-string s))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:59:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:60:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:61:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:62:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:63:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:64:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:65:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqz56cgrg.rkt:66:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_17_parse_music --------
#lang racket

;; Input to this function is a string representing musical notes in a special ASCII format.
;; Your task is to parse this string and return list of integers corresponding to how many beats does each
;; not last.
;; Here is a legend:
;; 'o' - whole note, lasts four beats
;; 'o|' - half note, lasts two beats
;; '.|' - quater note, lasts one beat
;; >>> (parse_music "o o| .| o| o| .| .| .| .| o o")
;; (list 4 2 1 2 2 1 1 1 1 4 4)
(define (parse_music music_string)
  (cond ((null? music_string) '())
        ((string=? (substring music_string 0 1) "o")
         (cons 4 (parse_music (substring music_string 1))))
        ((string=? (substring music_string 0 2) "o|")
         (cons 2 (parse_music (substring music_string 2))))
        ((string=? (substring music_string 0 2) ".|")
         (cons 1 (parse_music (substring music_string 2))))
        (else (error "Unknown character"))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate parse_music))
    (check-equal? (candidate "") (list ))
    (check-equal? (candidate "o o o o") (list 4 4 4 4))
    (check-equal? (candidate ".| .| .| .|") (list 1 1 1 1))
    (check-equal? (candidate "o| o| .| .| o o o o") (list 2 2 1 1 4 4 4 4))
    (check-equal? (candidate "o| .| o| .| o o| o o|") (list 2 1 2 1 4 2 4 2))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:28:4

Unknown character
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:29:4

Unknown character
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:30:4

Unknown character
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr23bsqqy.rkt:31:4

Unknown character
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text start end)
    (cond
      [(= start end) #t]
      [(= (string-ref text start) (string-ref text end))
       (is_palindrome_iter text (+ start 1) (- end 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr4g5vt1q.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) (reverse s)]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string (char-upcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [else
     (string-append (string (char-downcase (string-ref s 0)))
                    (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr7ruu0ip.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome? string)
    (if (empty? string)
        #t
        (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome? (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome? string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprbg0rg8v.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprbg0rg8v.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprbg0rg8v.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprbg0rg8v.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprbg0rg8v.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond [(empty? s) 0]
        [else (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprfl8upsv.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_56_correct_bracketing --------
#lang racket

;; brackets is a string of "<" and ">".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "<")
;; #f
;; >>> (correct_bracketing "<>")
;; #t
;; >>> (correct_bracketing "<<><>>")
;; #t
;; >>> (correct_bracketing "><<>")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) "<")
     (correct_bracketing (substring brackets 1))]
    [(string=? (substring brackets 0 1) ">")
     (correct_bracketing (substring brackets 1))]
    [else #f]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "<>") #t)
    (check-equal? (candidate "<<><>>") #t)
    (check-equal? (candidate "<><><<><>><>") #t)
    (check-equal? (candidate "<><><<<><><>><>><<><><<>>>") #t)
    (check-equal? (candidate "<<<><>>>>") #f)
    (check-equal? (candidate "><<>") #f)
    (check-equal? (candidate "<") #f)
    (check-equal? (candidate "<<<<") #f)
    (check-equal? (candidate ">") #f)
    (check-equal? (candidate "<<>") #f)
    (check-equal? (candidate "<><><<><>><>><<>") #f)
    (check-equal? (candidate "<><><<><>><>>><>") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:28:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:29:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:32:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:33:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:35:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprjdkef_d.rkt:36:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
-------------------
==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text left right)
    (if (or (= left right) (= left (- right 1)))
        #t
        (if (equal? (string-ref text left) (string-ref text right))
            (is_palindrome_iter text (+ left 1) (- right 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprk0bl6we.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 1) "I") (+ 1 (is_bored (substring S 1)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:23:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:24:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 1) "I") (+ 1 (is_bored (substring S 1)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:23:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:24:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 1) "I") (+ 1 (is_bored (substring S 1)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:23:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:24:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 1) "I") (+ 1 (is_bored (substring S 1)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:23:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:24:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:25:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:26:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps_lk5odn.rkt:27:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_67_fruit_distribution --------
#lang racket

;; In this task, you will be given a string that represents a number of apples and oranges 
;; that are distributed in a basket of fruit this basket contains 
;; apples, oranges, and mango fruits. Given the string that represents the total number of 
;; the oranges and apples and an integer that represent the total number of the fruits 
;; in the basket return the number of the mango fruits in the basket.
;; for examble:
;; >>> (fruit_distribution "5 apples and 6 oranges" 19)
;; 8
;; >>> (fruit_distribution "0 apples and 1 oranges" 3)
;; 2
;; >>> (fruit_distribution "2 apples and 3 oranges" 100)
;; 95
;; >>> (fruit_distribution "100 apples and 1 oranges" 120)
;; 19
(define (fruit_distribution s n)
  (define (count-fruit s)
    (cond
      [(empty? s) 0]
      [(string=? (substring s 0 6) "apples") (+ (string->number (substring s 0 1)) (count-fruit (substring s 7 (string-length s))))]
      [(string=? (substring s 0 7) "oranges") (+ (string->number (substring s 0 1)) (count-fruit (substring s 8 (string-length s))))]
      [else (count-fruit (substring s 1 (string-length s)))]))
  (- n (count-fruit s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fruit_distribution))
    (check-equal? (candidate "5 apples and 6 oranges" 19) 8)
    (check-equal? (candidate "5 apples and 6 oranges" 21) 10)
    (check-equal? (candidate "0 apples and 1 oranges" 3) 2)
    (check-equal? (candidate "1 apples and 0 oranges" 3) 2)
    (check-equal? (candidate "2 apples and 3 oranges" 100) 95)
    (check-equal? (candidate "2 apples and 3 oranges" 5) 0)
    (check-equal? (candidate "1 apples and 100 oranges" 120) 19)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:31:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:32:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:33:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:34:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:35:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:36:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsb09k0uu.rkt:37:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 7]
  string: "oranges"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-helper string suffix)
      (if (string=? suffix "")
          ""
          (if (string=? (substring string 0 (string-length suffix)) suffix)
              suffix
              (find-longest-palindrome-suffix-helper string (substring suffix 1)))))
    (find-longest-palindrome-suffix-helper string (substring string 1)))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsr71ztye.rkt:29:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsr71ztye.rkt:30:4

reverse: contract violation
  expected: list?
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsr71ztye.rkt:31:4

reverse: contract violation
  expected: list?
  given: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsr71ztye.rkt:32:4

reverse: contract violation
  expected: list?
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsr71ztye.rkt:33:4

reverse: contract violation
  expected: list?
  given: "jerry"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((char=? (string-ref text i) (string-ref text j))
           (is_palindrome-iter text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsrqz9lb5.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((char=? (string-ref text i) (string-ref text j))
           (is_palindrome-iter text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsrqz9lb5.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (if (equal? a b)
        #\0
        #\1))
  (define (xor-string a b)
    (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))
                   (xor-string (substring a 1) (substring b 1))))
  (if (equal? (string-length a) (string-length b))
      (xor-string a b)
      (error "string_xor: strings not of equal length")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstbdhvnd.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstbdhvnd.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpstbdhvnd.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (define (is-upper? c)
    (and (char-alphabetic? c) (char-upper-case? c)))
  (define (is-vowel? c)
    (member c '(#\a #\e #\i #\o #\u)))
  (define (is-even? n)
    (= (remainder n 2) 0))
  (define (count-upper-vowels-in-even-indices s)
    (cond
      [(empty? s) 0]
      [(is-even? (string-length s))
       (+ (if (and (is-upper? (string-ref s 0))
                   (is-vowel? (string-ref s 0)))
              1
              0)
          (count-upper-vowels-in-even-indices (substring s 1)))]
      [else (count-upper-vowels-in-even-indices (substring s 1))]))
  (count-upper-vowels-in-even-indices s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:40:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt7lgbi5c.rkt:41:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond [(empty? s) ""]
        [(char-alphabetic? (string-ref s 0))
         (string-append (string (char-downcase (string-ref s 0)))
                        (solve (substring s 1)))]
        [(char-numeric? (string-ref s 0))
         (string-append (string (char-upcase (string-ref s 0)))
                        (solve (substring s 1)))]
        [else (string-append (string (string-ref s 0))
                             (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt9eu2ycn.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (cond
    [(empty? s) 0]
    [(and (even? (string-length s)) (char-upper-case? (string-ref s 0)))
     (+ 1 (count_upper (substring s 1)))]
    [else (count_upper (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:23:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (cond
    [(empty? s) 0]
    [(and (even? (string-length s)) (char-upper-case? (string-ref s 0)))
     (+ 1 (count_upper (substring s 1)))]
    [else (count_upper (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:23:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:28:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_zbjji.rkt:29:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_51_remove_vowels --------
#lang racket

;; remove_vowels is a function that takes string and returns string without vowels.
;; >>> (remove_vowels "")
;; ""
;; >>> (remove_vowels "abcdef")
;; "bcdf"
;; >>> (remove_vowels "aaaaa")
;; ""
;; >>> (remove_vowels "aaBAA")
;; "B"
;; >>> (remove_vowels "zbcd")
;; "zbcd"
(define (remove_vowels text)
  (if (empty? text)
      ""
      (if (member (string-ref text 0) "aeiouAEIOU")
          (remove_vowels (substring text 1))
          (string-append (string (string-ref text 0)) (remove_vowels (substring text 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_vowels))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "abcdef
ghijklm") "bcdf
ghjklm")
    (check-equal? (candidate "fedcba") "fdcb")
    (check-equal? (candidate "eeeee") "")
    (check-equal? (candidate "acBAA") "cB")
    (check-equal? (candidate "EcBOO") "cB")
    (check-equal? (candidate "ybcd") "ybcd")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:27:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:30:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:31:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:32:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:33:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:34:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------

==========================
------- Program HumanEval_80_is_happy --------
#lang racket

;; You are given a string s.
;; Your task is to check if the string is haprkt or not.
;; A string is haprkt if its length is at least 3 and every 3 consecutive letters are distinct
;; For example:
;; >>> (is_happy a)
;; #f
;; >>> (is_happy aa)
;; #f
;; >>> (is_happy abcd)
;; #t
;; >>> (is_happy aabb)
;; #f
;; >>> (is_happy adb)
;; #t
;; >>> (is_happy xyy)
;; #f
(define (is_happy s)
  (cond
    [(< (string-length s) 3) #f]
    [(equal? (substring s 0 3) (substring s 1 4)) #f]
    [else (is_happy (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_happy))
    (check-equal? (candidate "a") #f)
    (check-equal? (candidate "aa") #f)
    (check-equal? (candidate "abcd") #t)
    (check-equal? (candidate "aabb") #f)
    (check-equal? (candidate "adb") #t)
    (check-equal? (candidate "xyy") #f)
    (check-equal? (candidate "iopaxpoi") #t)
    (check-equal? (candidate "iopaxioi") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptutkypam.rkt:32:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "bcd"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptutkypam.rkt:33:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "abb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptutkypam.rkt:34:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "adb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptutkypam.rkt:35:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptutkypam.rkt:36:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "poi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptutkypam.rkt:37:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "ioi"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome-iter text left right)
    (cond ((= left right) #t)
          ((= (+ left 1) right) #t)
          ((char=? (string-ref text left) (string-ref text right))
           (is_palindrome-iter text (+ left 1) (- right 1)))
          (else #f)))
  (is_palindrome-iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu943u9uj.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (define (xor-char a b)
    (if (equal? a b)
        #\0
        #\1))
  (define (xor-string a b)
    (string-append (list (xor-char (string-ref a 0) (string-ref b 0)))
                   (xor-string (substring a 1) (substring b 1))))
  (if (equal? (string-length a) (string-length b))
      (xor-string a b)
      (error "Strings are not of equal length")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupnme65f.rkt:24:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupnme65f.rkt:25:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupnme65f.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse-string string)
    (define (reverse-string-helper string reversed-string)
      (if (string=? string "")
          reversed-string
          (reverse-string-helper (substring string 1) (string-append (substring string 0 1) reversed-string))))
    (reverse-string-helper string ""))
  (define (find-palindrome-suffix string)
    (define (find-palindrome-suffix-helper string suffix)
      (if (string=? string "")
          suffix
          (if (string=? (substring string 0 1) (substring string (string-length string) (- (string-length string) 1)))
              (find-palindrome-suffix-helper (substring string 1) (string-append (substring string 0 1) suffix))
              suffix)))
    (find-palindrome-suffix-helper string ""))
  (string-append string (reverse-string (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvk76430.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvk76430.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 2
  starting index: 3
  valid range: [0, 3]
  string: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvk76430.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 2
  starting index: 3
  valid range: [0, 3]
  string: "xyx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvk76430.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 4
  starting index: 5
  valid range: [0, 5]
  string: "jerry"
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (string-split (string-append a b) "")) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvsqzuwj.rkt:15:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvsqzuwj.rkt:16:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvsqzuwj.rkt:17:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_11_string_xor --------
#lang racket

;; Input are two strings a and b consisting only of 1s and 0s.
;; Perform binary XOR on these inputs and return result also as a string.
;; >>> (string_xor "010" "110")
;; "100"
(define (string_xor a b)
  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (string-split (string-append a b) "")) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate string_xor))
    (check-equal? (candidate "111000" "101010") "010010")
    (check-equal? (candidate "1" "1") "0")
    (check-equal? (candidate "0101" "0000") "0101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvsqzuwj.rkt:15:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvsqzuwj.rkt:16:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuvsqzuwj.rkt:17:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        string
        (string-append (reverse (substring string 1)) (string (string-ref string 0)))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (if (equal? (string-ref string 0) (string-ref (reverse string) 0))
            (is_palindrome (substring string 1 (sub1 (string-length string))))
            #f)))
  (define (find_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (sub1 (string-length (find_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuz1p5y4d.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuz1p5y4d.rkt:36:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuz1p5y4d.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuz1p5y4d.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuz1p5y4d.rkt:39:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_66_digitSum --------
#lang racket

;; Task
;; Write a function that takes a string as input and returns the sum of the upper characters only'
;; ASCII codes.
;; Examples:
;; >>> (digitSum "")
;; 0
;; >>> (digitSum "abAB")
;; 131
;; >>> (digitSum "abcCd")
;; 67
;; >>> (digitSum "helloE")
;; 69
;; >>> (digitSum "woArBld")
;; 131
;; >>> (digitSum "aAaaaXa")
;; 153
(define (digitSum s)
  (cond
    [(empty? s) 0]
    [(char-upper-case? (string-ref s 0)) (+ (char->integer (string-ref s 0)) (digitSum (substring s 1)))]
    [else (digitSum (substring s 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate digitSum))
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "abAB") 131)
    (check-equal? (candidate "abcCd") 67)
    (check-equal? (candidate "helloE") 69)
    (check-equal? (candidate "woArBld") 131)
    (check-equal? (candidate "aAaaaXa") 153)
    (check-equal? (candidate " How are yOu?") 151)
    (check-equal? (candidate "You arE Very Smart") 327)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:30:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:31:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv42g_j8s.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string-upcase (string-ref s 0))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string-ref s 0)
                    (solve (substring s 1)))]
    [else
     (string-append (string-downcase (string-ref s 0))
                    (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:33:4

string-upcase: contract violation
  expected: string?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:35:4

string-upcase: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:36:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:37:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:38:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:39:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:40:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string-upcase (string-ref s 0))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string-ref s 0)
                    (solve (substring s 1)))]
    [else
     (string-append (string-downcase (string-ref s 0))
                    (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:33:4

string-upcase: contract violation
  expected: string?
  given: #\A
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:35:4

string-upcase: contract violation
  expected: string?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:36:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:37:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:38:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:39:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv_5sxxwk.rkt:40:4

string-downcase: contract violation
  expected: string?
  given: #\#
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgm0wmny.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgm0wmny.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgm0wmny.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgm0wmny.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgm0wmny.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (is-vowel? c)
    (member c '("a" "e" "i" "o" "u" "A" "E" "I" "O" "U")))
  (define (is-consonant? c)
    (not (is-vowel? c)))
  (define (is-consonant-vowel-consonant? word)
    (and (is-consonant? (string-ref word 0))
         (is-vowel? (string-ref word 1))
         (is-consonant? (string-ref word 2))))
  (define (find-closest-vowel word)
    (if (is-consonant-vowel-consonant? word)
        (string-ref word 1)
        (find-closest-vowel (substring word 1))))
  (if (is-consonant-vowel-consonant? word)
      (string-ref word 1)
      (find-closest-vowel (substring word 1))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:39:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:40:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "l"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:41:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:42:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:43:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:44:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:45:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:46:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "b"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:47:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "a"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:48:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "k"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvomfxqqm.rkt:49:4

string-ref: index is out of
==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2 (string-length S))))]
    [else (is_bored (substring S 1 (string-length S)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2 (string-length S))))]
    [else (is_bored (substring S 1 (string-length S)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvsa7pkl7.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (count (lambda (x) (string=? (substring x 0 1) "I"))
         (regexp-split #rx"[.?!]" S)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:21:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:22:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw2m05pnj.rkt:24:4
actual:     1
expected:   2
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((char=? (string-ref text i) (string-ref text j))
           (is_palindrome_iter text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwa98y822.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((char=? (string-ref text i) (string-ref text j))
           (is_palindrome_iter text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwa98y822.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((char=? (string-ref text i) (string-ref text j))
           (is_palindrome_iter text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwa98y822.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond ((= i j) #t)
          ((= (+ i 1) j) #t)
          ((char=? (string-ref text i) (string-ref text j))
           (is_palindrome_iter text (+ i 1) (- j 1)))
          (else #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwa98y822.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (find-palindrome-suffix string)
    (define (find-palindrome-suffix-iter string suffix)
      (if (empty? string)
          suffix
          (if (equal? (reverse (substring string 0 (string-length suffix))) suffix)
              (find-palindrome-suffix-iter (substring string 1) (substring string 0 1))
              (find-palindrome-suffix-iter (substring string 1) (string-append (substring string 0 1) suffix)))))
    (find-palindrome-suffix-iter string ""))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwbzox452.rkt:33:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwbzox452.rkt:34:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwbzox452.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwbzox452.rkt:36:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwbzox452.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome? string)
    (if (empty? string)
        #t
        (if (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
            (is_palindrome? (substring string 1 (- (string-length string) 1)))
            #f)))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome? string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd2j_r74.rkt:35:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd2j_r74.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd2j_r74.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd2j_r74.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd2j_r74.rkt:39:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_91_is_bored --------
#lang racket

;; You'll be given a string of words, and your task is to count the number
;; of boredoms. A boredom is a sentence that starts with the word "I".
;; Sentences are delimited by '.', '?' or '!'.
;; For example:
;; >>> (is_bored "Hello world")
;; 0
;; >>> (is_bored "The sky is blue. The sun is shining. I love this weather")
;; 1
(define (is_bored S)
  (cond
    [(empty? S) 0]
    [(string=? (substring S 0 2) "I ") (+ 1 (is_bored (substring S 2)))]
    [else (is_bored (substring S 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_bored))
    (check-equal? (candidate "Hello world") 0)
    (check-equal? (candidate "Is the sky blue?") 0)
    (check-equal? (candidate "I love It !") 1)
    (check-equal? (candidate "bIt") 0)
    (check-equal? (candidate "I feel good today. I will be productive. will kill It") 2)
    (check-equal? (candidate "You and I are going for a walk") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:22:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:23:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "?"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:24:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "!"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:25:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:26:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "t"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwp86l8rp.rkt:27:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "k"
--------------------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (cond
    [(empty? num) 0]
    [(char-numeric? (string-ref num 0)) (hex_key (substring num 1))]
    [(char-alphabetic? (string-ref num 0))
     (cond
       [(or (equal? (string-ref num 0) #\A)
            (equal? (string-ref num 0) #\B)
            (equal? (string-ref num 0) #\C)
            (equal? (string-ref num 0) #\D)
            (equal? (string-ref num 0) #\E)
            (equal? (string-ref num 0) #\F))
        (+ 1 (hex_key (substring num 1)))]
       [else (hex_key (substring num 1))])]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwvn302he.rkt:44:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwvn302he.rkt:45:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwvn302he.rkt:46:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwvn302he.rkt:47:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwvn302he.rkt:48:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwvn302he.rkt:49:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string (char-upcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string (char-downcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0))
                         (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string (char-upcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string (char-downcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0))
                         (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string (char-upcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string (char-downcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0))
                         (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_161_solve --------
#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; >>> (solve "1234")
;; "4321"
;; >>> (solve "ab")
;; "AB"
;; >>> (solve "#a@C")
;; "#A@c"
(define (solve s)
  (cond
    [(empty? s) ""]
    [(char-alphabetic? (string-ref s 0))
     (string-append (string (char-upcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [(char-numeric? (string-ref s 0))
     (string-append (string (char-downcase (string-ref s 0)))
                    (solve (substring s 1)))]
    [else (string-append (string (string-ref s 0))
                         (solve (substring s 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:32:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:33:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:35:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:36:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:37:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:38:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx052h4_e.rkt:39:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_99_closest_integer --------
#lang racket

;; Create a function that takes a value (string) representing a number
;; and returns the closest integer to it. If the number is equidistant
;; from two integers, round it away from zero.
;; Examples
;; >>> (closest_integer "10")
;; 10
;; >>> (closest_integer "15.3")
;; 15
;; Note:
;; Rounding away from zero means that if the given number is equidistant
;; from two integers, the one you should return is the one that is the
;; farthest from zero. For example closest_integer("14.5") should
;; return 15 and closest_integer("-14.5") should return -15.
(define (closest_integer value)
  (if (string=? (substring value (add1 (string-length value)) (string-length value)) ".")
      (round (string->number value))
      (string->number value)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate closest_integer))
    (check-equal? (candidate "10") 10)
    (check-equal? (candidate "14.5") 15)
    (check-equal? (candidate "-15.5") -16)
    (check-equal? (candidate "15.3") 15)
    (check-equal? (candidate "0") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7oenusu.rkt:26:4

substring: starting index is out of range
  starting index: 3
  valid range: [0, 2]
  string: "10"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7oenusu.rkt:27:4

substring: starting index is out of range
  starting index: 5
  valid range: [0, 4]
  string: "14.5"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7oenusu.rkt:28:4

substring: starting index is out of range
  starting index: 6
  valid range: [0, 5]
  string: "-15.5"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7oenusu.rkt:29:4

substring: starting index is out of range
  starting index: 5
  valid range: [0, 4]
  string: "15.3"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx7oenusu.rkt:30:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "0"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (find-longest-palindrome-postfix string)
    (if (empty? string)
        ""
        (if (equal? (reverse string) string)
            string
            (find-longest-palindrome-postfix (substring string 0 (- (string-length string) 1))))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-postfix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxfwnta9s.rkt:31:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxfwnta9s.rkt:32:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxfwnta9s.rkt:33:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxfwnta9s.rkt:34:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxfwnta9s.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (null? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (null? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy20aecw4.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy20aecw4.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy20aecw4.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy20aecw4.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy20aecw4.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------

==========================
------- Program HumanEval_140_fix_spaces --------
#lang racket

;; Given a string text, replace all spaces in it with underscores, 
;; and if a string has more than 2 consecutive spaces, 
;; then replace all consecutive spaces with - 
;; >>> (fix_spaces " Example")
;; "Example"
;; >>> (fix_spaces " Example 1")
;; "Example_1"
;; >>> (fix_spaces " Example 2")
;; "_Example_2"
;; >>> (fix_spaces " Example 3")
;; "_Example-3"
(define (fix_spaces text)
  (cond
    [(string=? text "") text]
    [(string=? (substring text 0 1) " ")
     (string-append "_" (fix_spaces (substring text 1)))]
    [(string=? (substring text 0 2) "  ")
     (string-append "_" (fix_spaces (substring text 2)))]
    [(string=? (substring text 0 3) "   ")
     (string-append "_" (fix_spaces (substring text 3)))]
    [else
     (string-append (substring text 0 1) (fix_spaces (substring text 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fix_spaces))
    (check-equal? (candidate "Example") "Example")
    (check-equal? (candidate "Mudasir Hanif ") "Mudasir_Hanif_")
    (check-equal? (candidate "Yellow Yellow  Dirty  Fellow") "Yellow_Yellow__Dirty__Fellow")
    (check-equal? (candidate "Exa   mple") "Exa-mple")
    (check-equal? (candidate "   Exa 1 2 2 mple") "-Exa_1_2_2_mple")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpycrtuqhy.rkt:31:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "le"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpycrtuqhy.rkt:32:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "f "
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpycrtuqhy.rkt:33:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "ow"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpycrtuqhy.rkt:34:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "le"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpycrtuqhy.rkt:35:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "le"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text i j)
    (cond
      [(= i j) #t]
      [(= (+ i 1) j) #t]
      [(char=? (string-ref text i) (string-ref text j))
       (is_palindrome_iter text (+ i 1) (- j 1))]
      [else #f]))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyj7wtmcy.rkt:27:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (empty? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (empty? string)
        #t
        (and (equal? (substring string 0 1) (substring string (- (string-length string) 1) (string-length string)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (longest_palindrome string)
    (if (is_palindrome string)
        string
        (longest_palindrome (substring string 0 (- (string-length string) 1)))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (longest_palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz8feknf4.rkt:34:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz8feknf4.rkt:35:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz8feknf4.rkt:36:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz8feknf4.rkt:37:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz8feknf4.rkt:38:4

substring: ending index is smaller than starting index
  ending index: 0
  starting index: 1
  valid range: [0, 1]
  string: "j"
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text start end)
    (if (= start end)
        #t
        (if (= (string-ref text start) (string-ref text end))
            (is_palindrome_iter text (+ start 1) (- end 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_48_is_palindrome --------
#lang racket

;; Checks if given string is a palindrome
;; >>> (is_palindrome "")
;; #t
;; >>> (is_palindrome "aba")
;; #t
;; >>> (is_palindrome "aaaaa")
;; #t
;; >>> (is_palindrome "zbcd")
;; #f
(define (is_palindrome text)
  (define (is_palindrome_iter text start end)
    (if (= start end)
        #t
        (if (= (string-ref text start) (string-ref text end))
            (is_palindrome_iter text (+ start 1) (- end 1))
            #f)))
  (is_palindrome_iter text 0 (- (string-length text) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:27:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:28:4

=: contract violation
  expected: number?
  given: #\a
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:29:4

=: contract violation
  expected: number?
  given: #\z
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:30:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:31:4

=: contract violation
  expected: number?
  given: #\x
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzjgz5tez.rkt:32:4

=: contract violation
  expected: number?
  given: #\x
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append
   (string-append
    (substring s 0 1)
    (substring s 1 2))
   (string-append
    (substring s 2 3)
    (substring s 3 4))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:30:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "hi"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:31:4
actual:     "asdf"
expected:   "ewhjklnop"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:32:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:33:4

substring: ending index is out of range
  ending index: 3
  valid range: [0, 2]
  string: "et"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:34:4
actual:     "faew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:35:4
actual:     "hell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:36:4
actual:     "dxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzoxsc6on.rkt:37:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (null? string)
        ""
        (string-append (reverse (substring string 1)) (substring string 0 1))))
  (define (is_palindrome string)
    (if (or (null? string) (= (string-length string) 1))
        #t
        (and (char=? (string-ref string 0) (string-ref string (- (string-length string) 1)))
             (is_palindrome (substring string 1 (- (string-length string) 1))))))
  (define (find_longest_palindrome_suffix string)
    (if (is_palindrome string)
        string
        (find_longest_palindrome_suffix (substring string 1))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find_longest_palindrome_suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzy5c9f3o.rkt:34:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzy5c9f3o.rkt:35:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzy5c9f3o.rkt:36:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzy5c9f3o.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzy5c9f3o.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_124_valid_date --------
#lang racket

;; You have to write a function which validates a given date string and
;; returns #t if the date is valid otherwise #f.
;; The date is valid if all of the following rules are satisfied:
;; 1. The date string is not empty.
;; 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
;; 3. The months should not be less than 1 or higher than 12.
;; 4. The date should be in the format: mm-dd-yyyy
;; >>> (valid_date "03-11-2000")
;; #t
;; >>> (valid_date "15-01-2012")
;; #f
;; >>> (valid_date "04-0-2040")
;; #f
;; >>> (valid_date "06-04-2020")
;; #t
;; >>> (valid_date "06/04/2020")
;; #f
(define (valid_date date)
  (define (valid-month month)
    (and (integer? month)
         (and (>= month 1) (<= month 12))))
  (define (valid-day month day)
    (and (integer? day)
         (and (>= day 1)
              (cond
                [(or (= month 1) (= month 3) (= month 5) (= month 7) (= month 8) (= month 10) (= month 12)) (<= day 31)]
                [(or (= month 4) (= month 6) (= month 9) (= month 11)) (<= day 30)]
                [(= month 2) (<= day 29)]))))
  (define (valid-year year)
    (and (integer? year)
         (>= year 0)))
  (define (valid-date-format date)
    (and (string? date)
         (regexp-match? #rx"^[0-9]{2}-[0-9]{2}-[0-9]{4}$" date)))
  (let ([month (string->number (substring date 0 2))]
        [day (string->number (substring date 3 5))]
        [year (string->number (substring date 6 10))])
    (and (valid-date-format date)
         (valid-month month)
         (valid-day month day)
         (valid-year year))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate valid_date))
    (check-equal? (candidate "03-11-2000") #t)
    (check-equal? (candidate "15-01-2012") #f)
    (check-equal? (candidate "04-0-2040") #f)
    (check-equal? (candidate "06-04-2020") #t)
    (check-equal? (candidate "01-01-2007") #t)
    (check-equal? (candidate "03-32-2011") #f)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "04-31-3000") #f)
    (check-equal? (candidate "06-06-2005") #t)
    (check-equal? (candidate "21-31-2000") #f)
    (check-equal? (candidate "04-12-2003") #t)
    (check-equal? (candidate "04122003") #f)
    (check-equal? (candidate "20030412") #f)
    (check-equal? (candidate "2003-04") #f)
    (check-equal? (candidate "2003-04-12") #f)
    (check-equal? (candidate "04-2003") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:50:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:52:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 9]
  string: "04-0-2040"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:53:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:54:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:56:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:58:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:60:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:61:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 8]
  string: "04122003"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:62:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 8]
  string: "20030412"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:63:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 7]
  string: "2003-04"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0amiixac.rkt:65:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 7]
  string: "04-2003"
--------------------

==========================
------- Program HumanEval_124_valid_date --------
#lang racket

;; You have to write a function which validates a given date string and
;; returns #t if the date is valid otherwise #f.
;; The date is valid if all of the following rules are satisfied:
;; 1. The date string is not empty.
;; 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
;; 3. The months should not be less than 1 or higher than 12.
;; 4. The date should be in the format: mm-dd-yyyy
;; >>> (valid_date "03-11-2000")
;; #t
;; >>> (valid_date "15-01-2012")
;; #f
;; >>> (valid_date "04-0-2040")
;; #f
;; >>> (valid_date "06-04-2020")
;; #t
;; >>> (valid_date "06/04/2020")
;; #f
(define (valid_date date)
  (define (valid-month month)
    (and (integer? month)
         (and (>= month 1) (<= month 12))))
  (define (valid-day month day)
    (and (integer? day)
         (and (>= day 1)
              (cond
                [(or (= month 1) (= month 3) (= month 5) (= month 7) (= month 8) (= month 10) (= month 12)) (<= day 31)]
                [(or (= month 4) (= month 6) (= month 9) (= month 11)) (<= day 30)]
                [(= month 2) (<= day 29)]))))
  (define (valid-year year)
    (and (integer? year)
         (and (>= year 1) (<= year 9999))))
  (define (valid-date-format date)
    (and (string? date)
         (and (regexp-match? #rx"^[0-9]{2}-[0-9]{2}-[0-9]{4}$" date)
              #t)))
  (define (parse-date date)
    (define (parse-month date)
      (string->number (substring date 0 2)))
  (define (parse-day date)
    (string->number (substring date 3 5)))
  (define (parse-year date)
    (string->number (substring date 6 10)))
  (values (parse-month date) (parse-day date) (parse-year date)))
  (define (valid-date-parts month day year)
    (and (valid-month month)
         (and (valid-day month day)
              (and (valid-year year)
                   #t))))
  (define (valid-date-parts-and-format date)
    (define-values (month day year) (parse-date date))
    (and (valid-date-parts month day year)
         (and (valid-date-format date)
              #t)))
  (valid-date-parts-and-format date))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate valid_date))
    (check-equal? (candidate "03-11-2000") #t)
    (check-equal? (candidate "15-01-2012") #f)
    (check-equal? (candidate "04-0-2040") #f)
    (check-equal? (candidate "06-04-2020") #t)
    (check-equal? (candidate "01-01-2007") #t)
    (check-equal? (candidate "03-32-2011") #f)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "04-31-3000") #f)
    (check-equal? (candidate "06-06-2005") #t)
    (check-equal? (candidate "21-31-2000") #f)
    (check-equal? (candidate "04-12-2003") #t)
    (check-equal? (candidate "04122003") #f)
    (check-equal? (candidate "20030412") #f)
    (check-equal? (candidate "2003-04") #f)
    (check-equal? (candidate "2003-04-12") #f)
    (check-equal? (candidate "04-2003") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:62:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:64:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 9]
  string: "04-0-2040"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:65:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:66:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:68:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:70:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:72:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:73:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 8]
  string: "04122003"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:74:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 8]
  string: "20030412"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:75:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 7]
  string: "2003-04"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1qa_dbw0.rkt:77:4

substring: ending index is out of range
  ending index: 10
  valid range: [0, 7]
  string: "04-2003"
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (let ([vowels (list #\a #\e #\i #\o #\u #\A #\E #\I #\O #\U)])
    (for/first ([i (in-range (sub1 (string-length word)) -1 -1)]
                [c (in-list (string->list word))])
      (cond
        [(and (member c vowels)
              (not (member (string-ref word (sub1 i)) vowels))
              (not (member (string-ref word (add1 i)) vowels)))
         (string c)]
        [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:33:4
actual:     #f
expected:   "u"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:34:4
actual:     #f
expected:   "u"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:35:4

string-ref: index is out of range
  index: 4
  valid range: [0, 3]
  string: "easy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:36:4

string-ref: index is out of range
  index: 4
  valid range: [0, 3]
  string: "eAsy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:37:4

string-ref: index is out of range
  index: 3
  valid range: [0, 2]
  string: "ali"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:38:4
actual:     #f
expected:   "a"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:39:4
actual:     #f
expected:   "o"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:40:4
actual:     #f
expected:   ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:41:4
actual:     #f
expected:   ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:42:4
actual:     #f
expected:   ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:43:4

string-ref: index is out of range
  index: 5
  valid range: [0, 4]
  string: "anime"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:44:4
actual:     #f
expected:   ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2zyexdht.rkt:45:4

string-ref: index is out 
==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) ")") #f]
    [else (correct_bracketing (substring brackets 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:24:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:25:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:26:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:27:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) ")") #f]
    [else (correct_bracketing (substring brackets 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:24:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:25:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:26:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:27:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) ")") #f]
    [else (correct_bracketing (substring brackets 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:24:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:25:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:26:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:27:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) ")") #f]
    [else (correct_bracketing (substring brackets 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:24:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:25:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:26:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:27:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) ")") #f]
    [else (correct_bracketing (substring brackets 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:24:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:25:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:26:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:27:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_61_correct_bracketing --------
#lang racket

;; brackets is a string of "(" and ")".
;; return #t if every opening bracket has a corresponding closing bracket.
;; >>> (correct_bracketing "(")
;; #f
;; >>> (correct_bracketing "()")
;; #t
;; >>> (correct_bracketing "(()())")
;; #t
;; >>> (correct_bracketing ")(()")
;; #f
(define (correct_bracketing brackets)
  (cond
    [(empty? brackets) #t]
    [(string=? (substring brackets 0 1) ")") #f]
    [else (correct_bracketing (substring brackets 1))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate correct_bracketing))
    (check-equal? (candidate "()") #t)
    (check-equal? (candidate "(()())") #t)
    (check-equal? (candidate "()()(()())()") #t)
    (check-equal? (candidate "()()((()()())())(()()(()))") #t)
    (check-equal? (candidate "((()())))") #f)
    (check-equal? (candidate ")(()") #f)
    (check-equal? (candidate "(") #f)
    (check-equal? (candidate "((((") #f)
    (check-equal? (candidate ")") #f)
    (check-equal? (candidate "(()") #f)
    (check-equal? (candidate "()()(()())())(()") #f)
    (check-equal? (candidate "()()(()())()))()") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:24:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:25:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:26:4
actual:     #f
expected:   #t
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:27:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:30:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6nnrjq19.rkt:31:4

substring: ending index is out of range
  ending index: 1
  valid range: [0, 0]
  string: ""
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (rotate-n s 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:30:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:31:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:32:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:33:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:34:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:35:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:36:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (rotate-n s 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:30:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:31:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:32:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:33:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:34:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:35:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:36:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9crtndos.rkt:37:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_80_is_happy --------
#lang racket

;; You are given a string s.
;; Your task is to check if the string is haprkt or not.
;; A string is haprkt if its length is at least 3 and every 3 consecutive letters are distinct
;; For example:
;; >>> (is_happy a)
;; #f
;; >>> (is_happy aa)
;; #f
;; >>> (is_happy abcd)
;; #t
;; >>> (is_happy aabb)
;; #f
;; >>> (is_happy adb)
;; #t
;; >>> (is_happy xyy)
;; #f
(define (is_happy s)
  (cond
    [(< (string-length s) 3) #f]
    [(string=? (substring s 0 3) (substring s 1 4)) #f]
    [else #t]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_happy))
    (check-equal? (candidate "a") #f)
    (check-equal? (candidate "aa") #f)
    (check-equal? (candidate "abcd") #t)
    (check-equal? (candidate "aabb") #f)
    (check-equal? (candidate "adb") #t)
    (check-equal? (candidate "xyy") #f)
    (check-equal? (candidate "iopaxpoi") #t)
    (check-equal? (candidate "iopaxioi") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbcrlxn53.rkt:33:4
actual:     #t
expected:   #f
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbcrlxn53.rkt:34:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "adb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbcrlxn53.rkt:35:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyy"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbcrlxn53.rkt:37:4
actual:     #t
expected:   #f
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (get-closest-vowel-iter word i)
    (if (or (= i -1) (= i (string-length word)))
        ""
        (let ((c (string-ref word i)))
          (if (or (char=? c #\a) (char=? c #\e) (char=? c #\i) (char=? c #\o) (char=? c #\u))
              (if (or (and (not (char=? (string-ref word (+ i 1)) #\a))
                           (not (char=? (string-ref word (+ i 1)) #\e))
                           (not (char=? (string-ref word (+ i 1)) #\i))
                           (not (char=? (string-ref word (+ i 1)) #\o))
                           (not (char=? (string-ref word (+ i 1)) #\u)))
                      (and (not (char=? (string-ref word (- i 1)) #\a))
                           (not (char=? (string-ref word (- i 1)) #\e))
                           (not (char=? (string-ref word (- i 1)) #\i))
                           (not (char=? (string-ref word (- i 1)) #\o))
                           (not (char=? (string-ref word (- i 1)) #\u))))
                  (string c)
                  (get-closest-vowel-iter word (- i 1)))
              (get-closest-vowel-iter word (- i 1))))))
  (get-closest-vowel-iter word (- (string-length word) 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:45:4
actual:     "a"
expected:   ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:46:4
actual:     "e"
expected:   ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:47:4

string-ref: index is out of range
  index: 3
  valid range: [0, 2]
  string: "ali"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:50:4
actual:     "a"
expected:   ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:51:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ba"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:52:4
actual:     "i"
expected:   ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:53:4

string-ref: index is out of range
  index: 5
  valid range: [0, 4]
  string: "anime"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:54:4

string-ref: index is out of range
  index: 4
  valid range: [0, 3]
  string: "Asia"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcd9zjg06.rkt:55:4

string-ref: index is out of range
  index: 5
  valid range: [0, 4]
  string: "Above"
--------------------

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (cs x shift)
    (if (zero? shift)
        (number->string x)
        (let ([s (number->string x)])
          (string-append (substring s shift) (substring s 0 shift)))))
  (let ([n (string-length (number->string x))])
    (if (> shift n)
        (reverse (cs x shift))
        (cs x shift))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpepw877sh.rkt:26:4
actual:     "010"
expected:   "001"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpepw877sh.rkt:28:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 2]
  string: "97"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpepw877sh.rkt:30:4

substring: starting index is out of range
  starting index: 101
  valid range: [0, 2]
  string: "11"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate-string s)
    (string-append (substring s 2) (substring s 0 2)))
  (define (encrypt-helper s)
    (cond ((string=? s "") "")
          (else (string-append (rotate-string (substring s 0 2))
                               (encrypt-helper (substring s 2))))))
  (encrypt-helper s))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:30:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:31:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "l"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:32:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:33:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:34:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "g"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:35:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "d"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:36:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "h"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph_lsw7iq.rkt:37:4

substring: ending index is out of range
  ending index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (get-closest-vowel-helper word i)
    (if (= i (string-length word))
        ""
        (let ((char (string-ref word i)))
          (if (or (char=? char #\a) (char=? char #\e) (char=? char #\i) (char=? char #\o) (char=? char #\u))
              (if (and (not (char=? (string-ref word (- i 1)) #\a))
                       (not (char=? (string-ref word (- i 1)) #\e))
                       (not (char=? (string-ref word (- i 1)) #\i))
                       (not (char=? (string-ref word (- i 1)) #\o))
                       (not (char=? (string-ref word (- i 1)) #\u)))
                  (if (and (not (char=? (string-ref word (+ i 1)) #\a))
                           (not (char=? (string-ref word (+ i 1)) #\e))
                           (not (char=? (string-ref word (+ i 1)) #\i))
                           (not (char=? (string-ref word (+ i 1)) #\o))
                           (not (char=? (string-ref word (+ i 1)) #\u)))
                      (string char)
                      (get-closest-vowel-helper word (+ i 1)))
                  (get-closest-vowel-helper word (+ i 1)))
              (get-closest-vowel-helper word (+ i 1))))))
  (get-closest-vowel-helper word 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:44:4
actual:     "o"
expected:   "u"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:46:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "easy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:47:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "eAsy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:48:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "ali"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:51:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "ab"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:52:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ba"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj5oord3m.rkt:54:4

string-ref: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 2nd
  first argument...:
   "anime"
--------------------

==========================
------- Program HumanEval_80_is_happy --------
#lang racket

;; You are given a string s.
;; Your task is to check if the string is haprkt or not.
;; A string is haprkt if its length is at least 3 and every 3 consecutive letters are distinct
;; For example:
;; >>> (is_happy a)
;; #f
;; >>> (is_happy aa)
;; #f
;; >>> (is_happy abcd)
;; #t
;; >>> (is_happy aabb)
;; #f
;; >>> (is_happy adb)
;; #t
;; >>> (is_happy xyy)
;; #f
(define (is_happy s)
  (let ([len (string-length s)])
    (cond
      [(< len 3) #f]
      [(equal? (substring s 0 3) (substring s 1 4)) #f]
      [else #t])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_happy))
    (check-equal? (candidate "a") #f)
    (check-equal? (candidate "aa") #f)
    (check-equal? (candidate "abcd") #t)
    (check-equal? (candidate "aabb") #f)
    (check-equal? (candidate "adb") #t)
    (check-equal? (candidate "xyy") #f)
    (check-equal? (candidate "iopaxpoi") #t)
    (check-equal? (candidate "iopaxioi") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpklm311at.rkt:34:4
actual:     #t
expected:   #f
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpklm311at.rkt:35:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "adb"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpklm311at.rkt:36:4

substring: ending index is out of range
  ending index: 4
  valid range: [0, 3]
  string: "xyy"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpklm311at.rkt:38:4
actual:     #t
expected:   #f
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (substring s 2) (substring s 0 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:24:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:25:4
actual:     "dfghjklas"
expected:   "ewhjklnop"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:26:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:27:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:28:4
actual:     "ewfawefaewgfa"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:29:4
actual:     "llomyfriendhe"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:30:4
actual:     "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (substring s 2) (substring s 0 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:24:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:25:4
actual:     "dfghjklas"
expected:   "ewhjklnop"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:26:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:27:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:28:4
actual:     "ewfawefaewgfa"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:29:4
actual:     "llomyfriendhe"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:30:4
actual:     "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (string-append (substring s 2) (substring s 0 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:24:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:25:4
actual:     "dfghjklas"
expected:   "ewhjklnop"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:26:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:27:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:28:4
actual:     "ewfawefaewgfa"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:29:4
actual:     "llomyfriendhe"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:30:4
actual:     "zdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdx"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpldab1yhw.rkt:31:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (string-append (substring (number->string x) shift)
                 (substring (number->string x) 0 shift)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn44ecxit.rkt:19:4
actual:     "010"
expected:   "001"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn44ecxit.rkt:21:4

substring: starting index is out of range
  starting index: 8
  valid range: [0, 2]
  string: "97"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn44ecxit.rkt:23:4

substring: starting index is out of range
  starting index: 101
  valid range: [0, 2]
  string: "11"
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (is-vowel? c)
    (or (equal? c #\a)
        (equal? c #\e)
        (equal? c #\i)
        (equal? c #\o)
        (equal? c #\u)))
  (define (is-consonant? c)
    (not (is-vowel? c)))
  (define (is-consonant-vowel-consonant? w)
    (and (is-consonant? (string-ref w 0))
         (is-vowel? (string-ref w 1))
         (is-consonant? (string-ref w 2))))
  (define (get-closest-vowel-from-right w)
    (if (is-consonant-vowel-consonant? w)
        (string-ref w 1)
        (get-closest-vowel-from-right (substring w 1))))
  (if (is-consonant-vowel-consonant? word)
      (string-ref word 1)
      (get-closest-vowel-from-right (substring word 1))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:43:4
actual:     #\o
expected:   "u"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:44:4
actual:     #\u
expected:   "u"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:45:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:46:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "y"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:47:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "li"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:48:4
actual:     #\a
expected:   "a"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:49:4
actual:     #\o
expected:   "o"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:50:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "b"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:51:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ba"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:52:4

string-ref: index is out of range
  index: 1
  valid range: [0, 0]
  string: "k"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:53:4
actual:     #\i
expected:   "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6pqloec.rkt:54:4

string-ref: index is out of range for empty string
  index: 0
  string: 
==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (is_vowel? c)
    (member c '(#\a #\e #\i #\o #\u #\A #\E #\I #\O #\U)))
  (define (is_consonant? c)
    (not (is_vowel? c)))
  (define (is_consonant_vowel_consonant? c1 c2 c3)
    (and (is_consonant? c1) (is_vowel? c2) (is_consonant? c3)))
  (define (get-closest-vowel-helper word)
    (if (is_consonant_vowel_consonant? (string-ref word 0) (string-ref word 1) (string-ref word 2))
        (string-ref word 1)
        (get-closest-vowel-helper (substring word 1))))
  (if (or (= (string-length word) 0) (= (string-length word) 1))
      ""
      (get-closest-vowel-helper word)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:37:4
actual:     #\o
expected:   "u"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:38:4
actual:     #\u
expected:   "u"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:39:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "sy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:40:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "sy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:41:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "li"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:42:4
actual:     #\a
expected:   "a"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:43:4
actual:     #\o
expected:   "o"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:44:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ab"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:45:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ba"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:46:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
  string: "ck"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:47:4
actual:     #\i
expected:   "i"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpve_87zmz.rkt:48:4

string-ref: index is out of range
  index: 2
  valid range: [0, 1]
 
==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (define (is_upper c)
    (and (char-upper-case? c)
         (member c '(#\A #\E #\I #\O #\U))))
  (define (count_upper_helper s i)
    (if (or (equal? i (string-length s))
            (not (is_upper (string-ref s i))))
        0
        (+ 1 (count_upper_helper s (+ i 2)))))
  (count_upper_helper s 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvgbj4gmt.rkt:27:4
actual:     0
expected:   1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgbj4gmt.rkt:31:4

string-ref: index is out of range
  index: 2
  valid range: [0, 0]
  string: "U"
--------------------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (let ([s1 (car lst)]
        [s2 (cadr lst)])
    (if (and (string=? s1 "") (string=? s2 ""))
        "Yes"
        (if (string=? s1 "")
            (if (string=? (substring s2 0 1) "(")
                (match_parens (list s1 (substring s2 1)))
                (match_parens (list (substring s2 1) "")))
            (if (string=? (substring s1 0 1) "(")
                (match_parens (list (substring s1 1) s2))
                (match_parens (list "" (substring s2 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:35:4
actual:     "Yes"
expected:   "No"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:36:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:37:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:38:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:39:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:40:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:41:4

substring: starting index is out of range
  starting index: 1
  valid range: [0, 0]
  string: ""
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:42:4
actual:     "Yes"
expected:   "No"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvgfjx6fl.rkt:43:4
actual:     "Yes"
expected:   "No"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (string-append (substring s n) (substring s 0 n)))
  (rotate 2 (rotate 2 s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:26:4
actual:     "hi"
expected:   "lm"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:27:4
actual:     "ghjklasdf"
expected:   "ewhjklnop"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:28:4
actual:     "gf"
expected:   "kj"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:29:4
actual:     "et"
expected:   "ix"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:30:4
actual:     "fawefaewgfaew"
expected:   "jeiajeaijeiak"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:31:4
actual:     "omyfriendhell"
expected:   "lippsqcjvmirh"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:32:4
actual:     "lmnilfuhmilufhlihufnmlimnufhlimnufhfucufhdxzd"
expected:   "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzd9pm9f0.rkt:33:4

substring: starting index is out of range
  starting index: 2
  valid range: [0, 1]
  string: "a"
--------------------

