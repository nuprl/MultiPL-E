HumanEval_154_cycpattern_check: 3
HumanEval_111_histogram: 1
HumanEval_103_rounded_avg: 14
HumanEval_73_smallest_change: 1
HumanEval_41_car_race_collision: 7
HumanEval_62_derivative: 4
HumanEval_143_words_in_sentence: 1
HumanEval_98_count_upper: 3
HumanEval_20_find_closest_elements: 26
HumanEval_99_closest_integer: 2
HumanEval_57_monotonic: 1
HumanEval_19_sort_numbers: 3
HumanEval_51_remove_vowels: 1
HumanEval_89_encrypt: 1
HumanEval_118_get_closest_vowel: 1
==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotate-all s)
    (map (lambda (n) (rotate-n s n)) (range (string-length s))))
  (define (substring? a b)
    (regexp-match? (regexp (string-append ".*" b ".*")) a))
  (ormap substring? (rotate-all b) (list a)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1lgx6n6q.rkt:34:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1lgx6n6q.rkt:35:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1lgx6n6q.rkt:36:4

ormap: all lists must have same size
  first list length: 4
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1lgx6n6q.rkt:37:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1lgx6n6q.rkt:38:4

ormap: all lists must have same size
  first list length: 4
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1lgx6n6q.rkt:39:4

ormap: all lists must have same size
  first list length: 5
  other list length: 1
  procedure: #<procedure:substring?>
--------------------

==========================
------- Program HumanEval_111_histogram --------
#lang racket

;; Given a string representing a space separated lowercase letters, return a hash
;; of the letter with the most repetition and containing the corresponding count.
;; If several letters have the same occurrence, return all of them.
;; Example:
;; >>> (histogram "a b c")
;; #hash(("a" .  1) ("b" .  1) ("c" .  1))
;; >>> (histogram "a b b a")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "a b c a b")
;; #hash(("a" .  2) ("b" .  2))
;; >>> (histogram "b b b b a")
;; #hash(("b" .  4))
;; >>> (histogram "")
;; #hash()
(define (histogram test)
  (hash '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate histogram))
    (check-equal? (candidate "a b b a") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c a b") #hash(("a" .  2) ("b" .  2)))
    (check-equal? (candidate "a b c d g") #hash(("a" .  1) ("b" .  1) ("c" .  1) ("d" .  1) ("g" .  1)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "b b b b a") #hash(("b" .  4)))
    (check-equal? (candidate "r t g") #hash(("r" .  1) ("t" .  1) ("g" .  1)))
    (check-equal? (candidate "") #hash())
    (check-equal? (candidate "a") #hash(("a" .  1)))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:25:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:26:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:27:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:28:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:29:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:30:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:31:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2oxrw6g0.rkt:32:4

hash: key does not have a value (i.e., an odd number of arguments were provided)
  key: '()
--------------------

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond [(> n m) -1]
        [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:25:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:36:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond [(> n m) -1]
        [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:25:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:36:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond [(> n m) -1]
        [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:25:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:36:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond [(> n m) -1]
        [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:25:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:36:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond [(> n m) -1]
        [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:25:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp31zp9gvo.rkt:36:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotations s)
    (for/list ([i (in-range (string-length s))])
      (rotate-n s i)))
  (define (substring? s1 s2)
    (regexp-match? (regexp (string-append ".*" s2 ".*")) s1))
  (define (any-substring? s1 s2)
    (ormap substring? (rotations s2) (list s1)))
  (any-substring? a b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:37:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:38:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:39:4

ormap: all lists must have same size
  first list length: 4
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:40:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:41:4

ormap: all lists must have same size
  first list length: 4
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:42:4

ormap: all lists must have same size
  first list length: 5
  other list length: 1
  procedure: #<procedure:substring?>
--------------------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotations s)
    (for/list ([i (in-range (string-length s))])
      (rotate-n s i)))
  (define (substring? s1 s2)
    (regexp-match? (regexp (string-append ".*" s2 ".*")) s1))
  (define (any-substring? s1 s2)
    (ormap substring? (rotations s2) (list s1)))
  (any-substring? a b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:37:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:38:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:39:4

ormap: all lists must have same size
  first list length: 4
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:40:4

ormap: all lists must have same size
  first list length: 3
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:41:4

ormap: all lists must have same size
  first list length: 4
  other list length: 1
  procedure: #<procedure:substring?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp43u43x5m.rkt:42:4

ormap: all lists must have same size
  first list length: 5
  other list length: 1
  procedure: #<procedure:substring?>
--------------------

==========================
------- Program HumanEval_73_smallest_change --------
#lang racket

;; Given a list arr of integers, find the minimum number of elements that
;; need to be changed to make the list palindromic. A palindromic list is a list that
;; is read the same backwards and forwards. In one change, you can change one element to any other element.
;; For example:
;; >>> (smallest_change (list 1 2 3 5 4 7 9 6))
;; 4
;; >>> (smallest_change (list 1 2 3 4 3 2 2))
;; 1
;; >>> (smallest_change (list 1 2 3 2 1))
;; 0
(define (smallest_change arr)
  (let loop ((arr arr) (i 0) (j (sub1 (length arr))))
    (cond
      [(= i j) 0]
      [(= i (sub1 j)) 0]
      [(= (list-ref arr i) (list-ref arr j)) (loop arr (add1 i) (sub1 j))]
      [else (add1 (min (loop (list-ref arr i) (add1 i) j)
                       (loop (list-ref arr j) i (sub1 j))))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate smallest_change))
    (check-equal? (candidate (list 1 2 3 5 4 7 9 6)) 4)
    (check-equal? (candidate (list 1 2 3 4 3 2 2)) 1)
    (check-equal? (candidate (list 1 4 2)) 1)
    (check-equal? (candidate (list 1 4 4 2)) 1)
    (check-equal? (candidate (list 1 2 3 2 1)) 0)
    (check-equal? (candidate (list 3 1 1 3)) 0)
    (check-equal? (candidate (list 1)) 0)
    (check-equal? (candidate (list 0 1)) 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4j9cyh66.rkt:27:4

list-ref: index reaches a non-pair
  index: 1
  in: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4j9cyh66.rkt:28:4

list-ref: index reaches a non-pair
  index: 1
  in: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4j9cyh66.rkt:30:4

list-ref: index reaches a non-pair
  index: 1
  in: 1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp4j9cyh66.rkt:34:4
actual:     0
expected:   1
--------------------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(or (member left right) (member right left))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (+ right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (+ right 1))]))
  (car_race_collision_helper n 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:25:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:26:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:27:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:28:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:29:4

member: not a proper list
  in: 0
--------------------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(or (member left right) (member right left))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (+ right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (+ right 1))]))
  (car_race_collision_helper n 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:25:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:26:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:27:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:28:4

member: not a proper list
  in: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp55txb36x.rkt:29:4

member: not a proper list
  in: 0
--------------------

==========================
------- Program HumanEval_62_derivative --------
#lang racket

;; xs represent coefficients of a polynomial.
;; xs[0] + xs[1] * x + xs[2] * x^2 + ....
;; Return derivative of this polynomial in the same form.
;; >>> (derivative (list 3 1 2 4 5))
;; (list 1 4 12 20)
;; >>> (derivative (list 1 2 3))
;; (list 2 6)
(define (derivative xs)
  (map (lambda (x i) (* i x)) xs (range 1 (length xs))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate derivative))
    (check-equal? (candidate (list 3 1 2 4 5)) (list 1 4 12 20))
    (check-equal? (candidate (list 1 2 3)) (list 2 6))
    (check-equal? (candidate (list 3 2 1)) (list 2 2))
    (check-equal? (candidate (list 3 2 1 0 4)) (list 2 2 0 16))
    (check-equal? (candidate (list 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5vdzmsv6.rkt:18:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmp5vdzmsv6.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5vdzmsv6.rkt:19:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmp5vdzmsv6.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5vdzmsv6.rkt:20:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmp5vdzmsv6.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5vdzmsv6.rkt:21:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmp5vdzmsv6.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5vdzmsv6.rkt:22:4

map: all lists must have same size
  first list length: 1
  other list length: 0
  procedure: #<procedure:...tmp/tmp5vdzmsv6.rkt:11:7>
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (- i 1)))))
    (is-prime-helper n (- n 1)))
  (define (word-lengths sentence)
    (map string-length (string-split sentence)))
  (define (word-lengths-in-sentence sentence)
    (filter is-prime? (word-lengths sentence)))
  (define (words-in-sentence sentence)
    (map string-ref (string-split sentence)))
  (define (words-with-prime-lengths sentence)
    (map list-ref (words-in-sentence sentence) (word-lengths-in-sentence sentence)))
  (string-join (words-with-prime-lengths sentence) " "))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6uh29s61.rkt:39:4

map: argument mismatch;
 the given procedure's expected number of arguments does not match the given number of lists
  given procedure: string-ref
  expected: 2
  given: 1
  argument lists...: 
   '("This" "is" "a" "test")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6uh29s61.rkt:40:4

map: argument mismatch;
 the given procedure's expected number of arguments does not match the given number of lists
  given procedure: string-ref
  expected: 2
  given: 1
  argument lists...: 
   '("lets" "go" "for" "swimming")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6uh29s61.rkt:41:4

map: argument mismatch;
 the given procedure's expected number of arguments does not match the given number of lists
  given procedure: string-ref
  expected: 2
  given: 1
  argument lists...: 
   '("there" "is" "no" "place" "available" "here")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6uh29s61.rkt:42:4

map: argument mismatch;
 the given procedure's expected number of arguments does not match the given number of lists
  given procedure: string-ref
  expected: 2
  given: 1
  argument lists...: 
   '("Hi" "I" "am" "Hussein")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6uh29s61.rkt:43:4

map: argument mismatch;
 the given procedure's expected number of arguments does not match the given number of lists
  given procedure: string-ref
  expected: 2
  given: 1
  argument lists...: 
   '("go" "for" "it")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6uh29s61.rkt:44:4

map: argument mismatch;
 the given procedure's expected number of arguments does not match the given number of lists
  given procedure: string-ref
  expected: 2
  given: 1
  argument lists...: 
   '("here")
--------------------
--------------------
ERROR
name:
==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(and (member left right) (not (member right left)))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (- right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (- right 1))]))
  (car_race_collision_helper n 0 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_j2oxey1.rkt:25:4

member: not a proper list
  in: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_j2oxey1.rkt:26:4

member: not a proper list
  in: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_j2oxey1.rkt:27:4

member: not a proper list
  in: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_j2oxey1.rkt:28:4

member: not a proper list
  in: 8
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_j2oxey1.rkt:29:4

member: not a proper list
  in: 10
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (let ([s (string-upcase s)])
    (for/sum ([i (in-range (string-length s))]
              #:when (and (even? i)
                          (member (string-ref s i) "AEIOU")))
      1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa48ihgt6.rkt:23:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa48ihgt6.rkt:24:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa48ihgt6.rkt:25:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa48ihgt6.rkt:26:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa48ihgt6.rkt:27:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa48ihgt6.rkt:29:4

member: not a proper list
  in: "AEIOU"
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ((min-diff (abs (- (car numbers) (cadr numbers))))
        (min-pair (list (car numbers) (cadr numbers))))
    (for ((n (cddr numbers))
          (i (cadr numbers)))
      (let ((diff (abs (- i n))))
        (when (< diff min-diff)
          (set! min-diff diff)
          (set! min-pair (list i n)))))
    min-pair))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpay4a9m0m.rkt:25:4

for: expected a sequence for i, got something else: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpay4a9m0m.rkt:26:4

for: expected a sequence for i, got something else: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpay4a9m0m.rkt:27:4

for: expected a sequence for i, got something else: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpay4a9m0m.rkt:28:4

for: expected a sequence for i, got something else: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpay4a9m0m.rkt:29:4

for: expected a sequence for i, got something else: 2.2
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))]
         [min-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers (cdr numbers))])
    (list (apply min min-pair) (apply max min-pair))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb1_pt2ap.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpb1_pt2ap.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb1_pt2ap.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpb1_pt2ap.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb1_pt2ap.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpb1_pt2ap.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb1_pt2ap.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpb1_pt2ap.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb1_pt2ap.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpb1_pt2ap.rkt:10:35>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (first (filter (lambda (x) (= (abs (- x (second numbers))) min-diff)) numbers))
          (second (filter (lambda (x) (= (abs (- x (first numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbf00d3ye.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpbf00d3ye.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbf00d3ye.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpbf00d3ye.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbf00d3ye.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpbf00d3ye.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbf00d3ye.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpbf00d3ye.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbf00d3ye.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpbf00d3ye.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))]
         [closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers (cdr numbers))])
    (if (= (length closest-pair) 2)
        closest-pair
        (list (car closest-pair) (car closest-pair)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdd6jbdog.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpdd6jbdog.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdd6jbdog.rkt:22:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdd6jbdog.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdd6jbdog.rkt:23:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpdd6jbdog.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdd6jbdog.rkt:24:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpdd6jbdog.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdd6jbdog.rkt:25:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdd6jbdog.rkt:10:35>
--------------------

==========================
------- Program HumanEval_62_derivative --------
#lang racket

;; xs represent coefficients of a polynomial.
;; xs[0] + xs[1] * x + xs[2] * x^2 + ....
;; Return derivative of this polynomial in the same form.
;; >>> (derivative (list 3 1 2 4 5))
;; (list 1 4 12 20)
;; >>> (derivative (list 1 2 3))
;; (list 2 6)
(define (derivative xs)
  (map (lambda (x i) (* x i)) xs (range 1 (length xs))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate derivative))
    (check-equal? (candidate (list 3 1 2 4 5)) (list 1 4 12 20))
    (check-equal? (candidate (list 1 2 3)) (list 2 6))
    (check-equal? (candidate (list 3 2 1)) (list 2 2))
    (check-equal? (candidate (list 3 2 1 0 4)) (list 2 2 0 16))
    (check-equal? (candidate (list 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:18:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:19:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:20:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:21:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:22:4

map: all lists must have same size
  first list length: 1
  other list length: 0
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------

==========================
------- Program HumanEval_62_derivative --------
#lang racket

;; xs represent coefficients of a polynomial.
;; xs[0] + xs[1] * x + xs[2] * x^2 + ....
;; Return derivative of this polynomial in the same form.
;; >>> (derivative (list 3 1 2 4 5))
;; (list 1 4 12 20)
;; >>> (derivative (list 1 2 3))
;; (list 2 6)
(define (derivative xs)
  (map (lambda (x i) (* x i)) xs (range 1 (length xs))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate derivative))
    (check-equal? (candidate (list 3 1 2 4 5)) (list 1 4 12 20))
    (check-equal? (candidate (list 1 2 3)) (list 2 6))
    (check-equal? (candidate (list 3 2 1)) (list 2 2))
    (check-equal? (candidate (list 3 2 1 0 4)) (list 2 2 0 16))
    (check-equal? (candidate (list 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:18:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:19:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:20:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:21:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:22:4

map: all lists must have same size
  first list length: 1
  other list length: 0
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------

==========================
------- Program HumanEval_62_derivative --------
#lang racket

;; xs represent coefficients of a polynomial.
;; xs[0] + xs[1] * x + xs[2] * x^2 + ....
;; Return derivative of this polynomial in the same form.
;; >>> (derivative (list 3 1 2 4 5))
;; (list 1 4 12 20)
;; >>> (derivative (list 1 2 3))
;; (list 2 6)
(define (derivative xs)
  (map (lambda (x i) (* x i)) xs (range 1 (length xs))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate derivative))
    (check-equal? (candidate (list 3 1 2 4 5)) (list 1 4 12 20))
    (check-equal? (candidate (list 1 2 3)) (list 2 6))
    (check-equal? (candidate (list 3 2 1)) (list 2 2))
    (check-equal? (candidate (list 3 2 1 0 4)) (list 2 2 0 16))
    (check-equal? (candidate (list 1)) (list ))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:18:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:19:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:20:4

map: all lists must have same size
  first list length: 3
  other list length: 2
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:21:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdr33uhby.rkt:22:4

map: all lists must have same size
  first list length: 1
  other list length: 0
  procedure: #<procedure:...tmp/tmpdr33uhby.rkt:11:7>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (cond
    [(empty? numbers) empty]
    [(empty? (rest numbers)) empty]
    [else
     (let* ([numbers (sort numbers <)]
            [min-diff (apply min (map (lambda (x y) (- y x)) numbers (rest numbers)))]
            [min-index (apply min (map (lambda (x y) (if (= (- y x) min-diff) x empty)) numbers (rest numbers)))])
       (list (list-ref numbers min-index) (list-ref numbers (+ min-index 1))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpedyb2jth.rkt:24:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpedyb2jth.rkt:15:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpedyb2jth.rkt:25:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpedyb2jth.rkt:15:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpedyb2jth.rkt:26:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpedyb2jth.rkt:15:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpedyb2jth.rkt:27:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpedyb2jth.rkt:15:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpedyb2jth.rkt:28:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpedyb2jth.rkt:15:38>
--------------------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(or (member left right) (member right left))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (- right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (- right 1))]))
  (car_race_collision_helper n 0 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:25:4

member: not a proper list
  in: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:26:4

member: not a proper list
  in: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:27:4

member: not a proper list
  in: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:28:4

member: not a proper list
  in: 8
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:29:4

member: not a proper list
  in: 10
--------------------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(or (member left right) (member right left))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (- right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (- right 1))]))
  (car_race_collision_helper n 0 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:25:4

member: not a proper list
  in: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:26:4

member: not a proper list
  in: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:27:4

member: not a proper list
  in: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:28:4

member: not a proper list
  in: 8
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:29:4

member: not a proper list
  in: 10
--------------------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(or (member left right) (member right left))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (- right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (- right 1))]))
  (car_race_collision_helper n 0 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:25:4

member: not a proper list
  in: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:26:4

member: not a proper list
  in: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:27:4

member: not a proper list
  in: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:28:4

member: not a proper list
  in: 8
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:29:4

member: not a proper list
  in: 10
--------------------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (car_race_collision_helper n left right)
    (cond
      [(zero? n) 0]
      [(or (member left right) (member right left))
       (+ 1 (car_race_collision_helper (- n 1) (+ left 1) (- right 1)))]
      [else (car_race_collision_helper (- n 1) (+ left 1) (- right 1))]))
  (car_race_collision_helper n 0 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:25:4

member: not a proper list
  in: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:26:4

member: not a proper list
  in: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:27:4

member: not a proper list
  in: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:28:4

member: not a proper list
  in: 8
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevxdii9j.rkt:29:4

member: not a proper list
  in: 10
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([closest-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) closest-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) closest-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([closest-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) closest-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) closest-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgi130kw1.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpgi130kw1.rkt:10:38>
--------------------

==========================
------- Program HumanEval_99_closest_integer --------
#lang racket

;; Create a function that takes a value (string) representing a number
;; and returns the closest integer to it. If the number is equidistant
;; from two integers, round it away from zero.
;; Examples
;; >>> (closest_integer "10")
;; 10
;; >>> (closest_integer "15.3")
;; 15
;; Note:
;; Rounding away from zero means that if the given number is equidistant
;; from two integers, the one you should return is the one that is the
;; farthest from zero. For example closest_integer("14.5") should
;; return 15 and closest_integer("-14.5") should return -15.
(define (closest_integer value)
  (cond
    [(< (string->number value) 0) (round (string->number value) #:direction '-) ]
    [else (round (string->number value) #:direction '+)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate closest_integer))
    (check-equal? (candidate "10") 10)
    (check-equal? (candidate "14.5") 15)
    (check-equal? (candidate "-15.5") -16)
    (check-equal? (candidate "15.3") 15)
    (check-equal? (candidate "0") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgvw5v67m.rkt:26:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   10
   #:direction '+
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgvw5v67m.rkt:27:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   14.5
   #:direction '+
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgvw5v67m.rkt:28:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   -15.5
   #:direction '-
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgvw5v67m.rkt:29:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   15.3
   #:direction '+
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgvw5v67m.rkt:30:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   0
   #:direction '+
--------------------

==========================
------- Program HumanEval_57_monotonic --------
#lang racket

;; Return #t is list elements are monotonically increasing or decreasing.
;; >>> (monotonic (list 1 2 4 20))
;; #t
;; >>> (monotonic (list 1 20 4 10))
;; #f
;; >>> (monotonic (list 4 1 0 -10))
;; #t
(define (monotonic l)
  (cond
    [(empty? l) #t]
    [(empty? (rest l)) #t]
    [(< (first l) (second l))
     (and (monotonic (rest l))
          (not (member (first l) (rest l)) #:test <))]
    [(> (first l) (second l))
     (and (monotonic (rest l))
          (not (member (first l) (rest l)) #:test >))]
    [else #f]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate monotonic))
    (check-equal? (candidate (list 1 2 4 10)) #t)
    (check-equal? (candidate (list 1 2 4 20)) #t)
    (check-equal? (candidate (list 1 20 4 10)) #f)
    (check-equal? (candidate (list 4 1 0 -10)) #t)
    (check-equal? (candidate (list 4 1 1 0)) #t)
    (check-equal? (candidate (list 1 2 3 2 5 60)) #f)
    (check-equal? (candidate (list 1 2 3 4 5 60)) #t)
    (check-equal? (candidate (list 9 9 9 9)) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:27:4

application: procedure does not accept keyword arguments
  procedure: not
  arguments...:
   #f
   #:test #<procedure:<>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:28:4

application: procedure does not accept keyword arguments
  procedure: not
  arguments...:
   #f
   #:test #<procedure:<>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:29:4

application: procedure does not accept keyword arguments
  procedure: not
  arguments...:
   #f
   #:test #<procedure:<>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:30:4

application: procedure does not accept keyword arguments
  procedure: not
  arguments...:
   #f
   #:test #<procedure:>>
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:31:4
actual:     #f
expected:   #t
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:32:4

application: procedure does not accept keyword arguments
  procedure: not
  arguments...:
   #f
   #:test #<procedure:<>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:33:4

application: procedure does not accept keyword arguments
  procedure: not
  arguments...:
   #f
   #:test #<procedure:<>
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpiyndegw5.rkt:34:4
actual:     #f
expected:   #t
--------------------

==========================
------- Program HumanEval_19_sort_numbers --------
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"
(define (sort_numbers numbers)
  (string-join (sort (string-split numbers) string<? #:key (lambda (x) (string->number (number->string (string->number x)))) #:key-compare string<? #:key-type string?) " "))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "three") "three")
    (check-equal? (candidate "three five nine") "three five nine")
    (check-equal? (candidate "five zero four seven nine eight") "zero four five seven eight nine")
    (check-equal? (candidate "six five four three two one zero") "zero one two three four five six")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk2f98t58.rkt:16:4

application: procedure does not expect an argument with given keyword
  procedure: sort
  given keyword: #:key-compare
  arguments...:
   '()
   #<procedure:string<?>
   #:key #<procedure:...tmp/tmpk2f98t58.rkt:9:59>
   #:key-compare #<procedure:string<?>
   #:key-type #<procedure:string?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk2f98t58.rkt:17:4

application: procedure does not expect an argument with given keyword
  procedure: sort
  given keyword: #:key-compare
  arguments...:
   '("three")
   #<procedure:string<?>
   #:key #<procedure:...tmp/tmpk2f98t58.rkt:9:59>
   #:key-compare #<procedure:string<?>
   #:key-type #<procedure:string?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk2f98t58.rkt:18:4

application: procedure does not expect an argument with given keyword
  procedure: sort
  given keyword: #:key-compare
  arguments...:
   '("three" "five" "nine")
   #<procedure:string<?>
   #:key #<procedure:...tmp/tmpk2f98t58.rkt:9:59>
   #:key-compare #<procedure:string<?>
   #:key-type #<procedure:string?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk2f98t58.rkt:19:4

application: procedure does not expect an argument with given keyword
  procedure: sort
  given keyword: #:key-compare
  arguments...:
   '("five" "zero" "four" "seven" "nine" "eight")
   #<procedure:string<?>
   #:key #<procedure:...tmp/tmpk2f98t58.rkt:9:59>
   #:key-compare #<procedure:string<?>
   #:key-type #<procedure:string?>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk2f98t58.rkt:20:4

application: procedure does not expect an argument with given keyword
  procedure: sort
  given keyword: #:key-compare
  arguments...:
   '("six" "five" "four" "three" "two" "one" "zero")
   #<procedure:string<?>
   #:key #<procedure:...tmp/tmpk2f98t58.rkt:9:59>
   #:key-co
==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))]
         [min-diff-index (index-of min-diff (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (list-ref numbers min-diff-index) (list-ref numbers (+ min-diff-index 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplfcdct0k.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmplfcdct0k.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplfcdct0k.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmplfcdct0k.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplfcdct0k.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmplfcdct0k.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplfcdct0k.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmplfcdct0k.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplfcdct0k.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmplfcdct0k.rkt:10:35>
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (let ([s (string-upcase s)])
    (for/sum ([i (in-range (string-length s))]
              #:when (even? i)
              #:when (member (string-ref s i) "AEIOU"))
      1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:23:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:24:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:25:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:26:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:27:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:29:4

member: not a proper list
  in: "AEIOU"
--------------------

==========================
------- Program HumanEval_98_count_upper --------
#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; >>> (count_upper "aBCdEf")
;; 1
;; >>> (count_upper "abcdefg")
;; 0
;; >>> (count_upper "dBBE")
;; 0
(define (count_upper s)
  (let ([s (string-upcase s)])
    (for/sum ([i (in-range (string-length s))]
              #:when (even? i)
              #:when (member (string-ref s i) "AEIOU"))
      1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:23:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:24:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:25:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:26:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:27:4

member: not a proper list
  in: "AEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpntlc3ykr.rkt:29:4

member: not a proper list
  in: "AEIOU"
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (cond
    [(empty? numbers) empty]
    [(empty? (rest numbers)) empty]
    [else
     (let* ([smallest-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))]
            [closest-pair (filter (lambda (x y) (= (abs (- x y)) smallest-diff)) numbers (rest numbers))])
       closest-pair)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpog4_rwa6.rkt:23:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpog4_rwa6.rkt:14:43>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpog4_rwa6.rkt:24:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpog4_rwa6.rkt:14:43>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpog4_rwa6.rkt:25:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpog4_rwa6.rkt:14:43>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpog4_rwa6.rkt:26:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpog4_rwa6.rkt:14:43>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpog4_rwa6.rkt:27:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpog4_rwa6.rkt:14:43>
--------------------

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond
    [(> n m) -1]
    [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:37:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond
    [(> n m) -1]
    [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:37:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond
    [(> n m) -1]
    [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:37:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond
    [(> n m) -1]
    [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:37:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (cond
    [(> n m) -1]
    [else (number->string (round (/ (+ n m) 2.0)) 2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:26:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:27:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:28:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoxzwdil1.rkt:37:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcdulp0r.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcdulp0r.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))]
         [min-pair (for/first ([x numbers] [y (rest numbers)])
                     (when (= (abs (- x y)) min-diff)
                       (list x y)))])
    (sort min-pair <)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcnho4nf.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcnho4nf.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcnho4nf.rkt:22:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcnho4nf.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcnho4nf.rkt:23:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcnho4nf.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcnho4nf.rkt:24:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmppcnho4nf.rkt:10:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppcnho4nf.rkt:25:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmppcnho4nf.rkt:10:35>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpskl52ejj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpskl52ejj.rkt:10:34>
--------------------

==========================
------- Program HumanEval_19_sort_numbers --------
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"
(define (sort_numbers numbers)
  (string-join (sort (string-split numbers) #:key (lambda (x) (string->number (string-append "0" x)))) " "))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "three") "three")
    (check-equal? (candidate "three five nine") "three five nine")
    (check-equal? (candidate "five zero four seven nine eight") "zero four five seven eight nine")
    (check-equal? (candidate "six five four three two one zero") "zero one two three four five six")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsxewahxj.rkt:16:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '()
   #:key #<procedure:...tmp/tmpsxewahxj.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsxewahxj.rkt:17:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("three")
   #:key #<procedure:...tmp/tmpsxewahxj.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsxewahxj.rkt:18:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("three" "five" "nine")
   #:key #<procedure:...tmp/tmpsxewahxj.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsxewahxj.rkt:19:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("five" "zero" "four" "seven" "nine" "eight")
   #:key #<procedure:...tmp/tmpsxewahxj.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsxewahxj.rkt:20:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("six" "five" "four" "three" "two" "one" "zero")
   #:key #<procedure:...tmp/tmpsxewahxj.rkt:9:50>
--------------------

==========================
------- Program HumanEval_99_closest_integer --------
#lang racket

;; Create a function that takes a value (string) representing a number
;; and returns the closest integer to it. If the number is equidistant
;; from two integers, round it away from zero.
;; Examples
;; >>> (closest_integer "10")
;; 10
;; >>> (closest_integer "15.3")
;; 15
;; Note:
;; Rounding away from zero means that if the given number is equidistant
;; from two integers, the one you should return is the one that is the
;; farthest from zero. For example closest_integer("14.5") should
;; return 15 and closest_integer("-14.5") should return -15.
(define (closest_integer value)
  (cond
    [(< (string->number value) 0)
     (round (string->number value) #:direction 'away-from-zero)]
    [else
     (round (string->number value) #:direction 'toward-zero)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate closest_integer))
    (check-equal? (candidate "10") 10)
    (check-equal? (candidate "14.5") 15)
    (check-equal? (candidate "-15.5") -16)
    (check-equal? (candidate "15.3") 15)
    (check-equal? (candidate "0") 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt55t7b4q.rkt:28:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   10
   #:direction 'toward-zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt55t7b4q.rkt:29:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   14.5
   #:direction 'toward-zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt55t7b4q.rkt:30:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   -15.5
   #:direction 'away-from-zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt55t7b4q.rkt:31:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   15.3
   #:direction 'toward-zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt55t7b4q.rkt:32:4

application: procedure does not accept keyword arguments
  procedure: round
  arguments...:
   0
   #:direction 'toward-zero
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([closest-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) closest-diff)) numbers))
          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) closest-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8gid3kj.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpt8gid3kj.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8gid3kj.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpt8gid3kj.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8gid3kj.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpt8gid3kj.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8gid3kj.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpt8gid3kj.rkt:10:38>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8gid3kj.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpt8gid3kj.rkt:10:38>
--------------------

==========================
------- Program HumanEval_51_remove_vowels --------
#lang racket

;; remove_vowels is a function that takes string and returns string without vowels.
;; >>> (remove_vowels "")
;; ""
;; >>> (remove_vowels "abcdef")
;; "bcdf"
;; >>> (remove_vowels "aaaaa")
;; ""
;; >>> (remove_vowels "aaBAA")
;; "B"
;; >>> (remove_vowels "zbcd")
;; "zbcd"
(define (remove_vowels text)
  (if (empty? text)
      ""
      (if (member (string-ref text 0) "aeiouAEIOU")
          (remove_vowels (substring text 1))
          (string-append (string (string-ref text 0)) (remove_vowels (substring text 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate remove_vowels))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "abcdef
ghijklm") "bcdf
ghjklm")
    (check-equal? (candidate "fedcba") "fdcb")
    (check-equal? (candidate "eeeee") "")
    (check-equal? (candidate "acBAA") "cB")
    (check-equal? (candidate "EcBOO") "cB")
    (check-equal? (candidate "ybcd") "ybcd")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:26:4

string-ref: index is out of range for empty string
  index: 0
  string: ""
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:27:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:30:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:31:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:32:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:33:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptn3qv21m.rkt:34:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------

==========================
------- Program HumanEval_89_encrypt --------
#lang racket

;; Create a function encrypt that takes a string as an argument and
;; returns a string encrypted with the alphabet being rotated. 
;; The alphabet should be rotated in a manner such that the letters 
;; shift down by two multiplied to two places.
;; For example:
;; >>> (encrypt "hi")
;; "lm"
;; >>> (encrypt "asdfghjkl")
;; "ewhjklnop"
;; >>> (encrypt "gf")
;; "kj"
;; >>> (encrypt "et")
;; "ix"
(define (encrypt s)
  (define (rotate n s)
    (if (empty? s)
        '()
        (cons (list-ref s n) (rotate n (rest s)))))
  (string-append (rotate 2 s) (rotate 4 s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate encrypt))
    (check-equal? (candidate "hi") "lm")
    (check-equal? (candidate "asdfghjkl") "ewhjklnop")
    (check-equal? (candidate "gf") "kj")
    (check-equal? (candidate "et") "ix")
    (check-equal? (candidate "faewfawefaewg") "jeiajeaijeiak")
    (check-equal? (candidate "hellomyfriend") "lippsqcjvmirh")
    (check-equal? (candidate "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh") "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl")
    (check-equal? (candidate "a") "e")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:28:4

list-ref: index reaches a non-pair
  index: 2
  in: "hi"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:29:4

list-ref: index reaches a non-pair
  index: 2
  in: "asdfghjkl"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:30:4

list-ref: index reaches a non-pair
  index: 2
  in: "gf"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:31:4

list-ref: index reaches a non-pair
  index: 2
  in: "et"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:32:4

list-ref: index reaches a non-pair
  index: 2
  in: "faewfawefaewg"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:33:4

list-ref: index reaches a non-pair
  index: 2
  in: "hellomyfriend"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:34:4

list-ref: index reaches a non-pair
  index: 2
  in: "dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpugqefwre.rkt:35:4

list-ref: index reaches a non-pair
  index: 2
  in: "a"
--------------------

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ([sum (+ n m)]
             [avg (/ sum 2.0)]
             [rounded (round avg)])
        (number->string rounded 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:35:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:36:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:37:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:40:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ([sum (+ n m)]
             [avg (/ sum 2.0)]
             [rounded (round avg)])
        (number->string rounded 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:35:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:36:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:37:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:40:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ([sum (+ n m)]
             [avg (/ sum 2.0)]
             [rounded (round avg)])
        (number->string rounded 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:35:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:36:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:37:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:40:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let* ([sum (+ n m)]
             [avg (/ sum 2.0)]
             [rounded (round avg)])
        (number->string rounded 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:29:4

number->string: inexact numbers can only be printed in base 10
  number: 3.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:30:4

number->string: inexact numbers can only be printed in base 10
  number: 10.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:31:4

number->string: inexact numbers can only be printed in base 10
  number: 970.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:32:4

number->string: inexact numbers can only be printed in base 10
  number: 996.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:33:4

number->string: inexact numbers can only be printed in base 10
  number: 706.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:34:4

number->string: inexact numbers can only be printed in base 10
  number: 366.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:35:4

number->string: inexact numbers can only be printed in base 10
  number: 429.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:36:4

number->string: inexact numbers can only be printed in base 10
  number: 626.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:37:4

number->string: inexact numbers can only be printed in base 10
  number: 215.0
  requested base: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrw0hyrg.rkt:40:4

number->string: inexact numbers can only be printed in base 1
==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let ([min-diff (apply min (map ( (x y) (abs (- x y))) numbers (rest numbers)))])
    (list (apply min (filter ( (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))
          (apply max (filter ( (x) (= (abs (- x (apply min numbers))) min-diff)) numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxe3og_ib.rkt:19:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpxe3og_ib.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxe3og_ib.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpxe3og_ib.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxe3og_ib.rkt:21:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpxe3og_ib.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxe3og_ib.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpxe3og_ib.rkt:10:34>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxe3og_ib.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpxe3og_ib.rkt:10:34>
--------------------

==========================
------- Program HumanEval_118_get_closest_vowel --------
#lang racket

;; You are given a word. Your task is to find the closest vowel that stands between 
;; two consonants from the right side of the word (case sensitive).
;; Vowels in the beginning and ending doesn't count. Return empty string if you didn't
;; find any vowel met the above condition. 
;; You may assume that the given string contains English letter only.
;; Example:
;; >>> (get_closest_vowel "yogurt")
;; "u"
;; >>> (get_closest_vowel "FULL")
;; "U"
;; >>> (get_closest_vowel "quick")
;; ""
;; >>> (get_closest_vowel "ab")
;; ""
(define (get_closest_vowel word)
  (define (get-vowel-index word)
    (let loop ([i (sub1 (string-length word))])
      (cond [(negative? i) #f]
            [(member (string-ref word i) "aeiouAEIOU") i]
            [else (loop (sub1 i))])))
  (define (get-consonant-index word)
    (let loop ([i (sub1 (string-length word))])
      (cond [(negative? i) #f]
            [(member (string-ref word i) "aeiouAEIOU") (sub1 i)]
            [else (loop (sub1 i))])))
  (define (get-closest-vowel-index word)
    (let loop ([i (get-vowel-index word)])
      (cond [(not i) #f]
            [(not (get-consonant-index word)) #f]
            [(> (get-consonant-index word) i) i]
            [else (loop (get-vowel-index (substring word 0 i)))])))
  (let ([i (get-closest-vowel-index word)])
    (if i (string (string-ref word i)) "")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_closest_vowel))
    (check-equal? (candidate "yogurt") "u")
    (check-equal? (candidate "full") "u")
    (check-equal? (candidate "easy") "")
    (check-equal? (candidate "eAsy") "")
    (check-equal? (candidate "ali") "")
    (check-equal? (candidate "bad") "a")
    (check-equal? (candidate "most") "o")
    (check-equal? (candidate "ab") "")
    (check-equal? (candidate "ba") "")
    (check-equal? (candidate "quick") "")
    (check-equal? (candidate "anime") "i")
    (check-equal? (candidate "Asia") "")
    (check-equal? (candidate "Above") "o")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:42:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:43:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:44:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:45:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:46:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:47:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:48:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:49:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:50:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:51:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:52:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:53:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxia20vuk.rkt:54:4

member: not a proper list
  in: "aeiouAEIOU"
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([sorted-numbers (sort numbers <)]
         [min-diff (apply min (map (lambda (x y) (- y x)) (cdr sorted-numbers) sorted-numbers))]
         [closest-elements (filter (lambda (x y) (= (- y x) min-diff)) (cdr sorted-numbers) sorted-numbers)])
    closest-elements))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy3g0kazm.rkt:20:4

map: all lists must have same size
  first list length: 5
  other list length: 6
  procedure: #<procedure:...tmp/tmpy3g0kazm.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy3g0kazm.rkt:21:4

map: all lists must have same size
  first list length: 4
  other list length: 5
  procedure: #<procedure:...tmp/tmpy3g0kazm.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy3g0kazm.rkt:22:4

map: all lists must have same size
  first list length: 5
  other list length: 6
  procedure: #<procedure:...tmp/tmpy3g0kazm.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy3g0kazm.rkt:23:4

map: all lists must have same size
  first list length: 5
  other list length: 6
  procedure: #<procedure:...tmp/tmpy3g0kazm.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy3g0kazm.rkt:24:4

map: all lists must have same size
  first list length: 4
  other list length: 5
  procedure: #<procedure:...tmp/tmpy3g0kazm.rkt:11:35>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([numbers (sort numbers <)]
         [min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))]
         [closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers (rest numbers))])
    closest-pair))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz7d0gcx3.rkt:20:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpz7d0gcx3.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz7d0gcx3.rkt:21:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpz7d0gcx3.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz7d0gcx3.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpz7d0gcx3.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz7d0gcx3.rkt:23:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpz7d0gcx3.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz7d0gcx3.rkt:24:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpz7d0gcx3.rkt:11:35>
--------------------

==========================
------- Program HumanEval_19_sort_numbers --------
#lang racket

;; Input is a space-delimited string of numberals from 'zero' to 'nine'.
;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
;; Return the string with numbers sorted from smallest to largest
;; >>> (sort_numbers "three one five")
;; "one three five"
(define (sort_numbers numbers)
  (string-join (sort (string-split numbers) #:key (lambda (x) (string->number (string-replace x #rx"zero" "0")))) " "))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_numbers))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "three") "three")
    (check-equal? (candidate "three five nine") "three five nine")
    (check-equal? (candidate "five zero four seven nine eight") "zero four five seven eight nine")
    (check-equal? (candidate "six five four three two one zero") "zero one two three four five six")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzc7925ql.rkt:16:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '()
   #:key #<procedure:...tmp/tmpzc7925ql.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzc7925ql.rkt:17:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("three")
   #:key #<procedure:...tmp/tmpzc7925ql.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzc7925ql.rkt:18:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("three" "five" "nine")
   #:key #<procedure:...tmp/tmpzc7925ql.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzc7925ql.rkt:19:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("five" "zero" "four" "seven" "nine" "eight")
   #:key #<procedure:...tmp/tmpzc7925ql.rkt:9:50>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzc7925ql.rkt:20:4

application: no case matching 1 non-keyword argument
  procedure: sort
  arguments...:
   '("six" "five" "four" "three" "two" "one" "zero")
   #:key #<procedure:...tmp/tmpzc7925ql.rkt:9:50>
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (let* ([sorted (sort numbers <)]
         [min-diff (apply min (map (lambda (x y) (abs (- x y))) sorted (cdr sorted)))]
         [closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) sorted (cdr sorted))])
    closest-pair))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzkg_7reh.rkt:20:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpzkg_7reh.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzkg_7reh.rkt:21:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpzkg_7reh.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzkg_7reh.rkt:22:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpzkg_7reh.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzkg_7reh.rkt:23:4

map: all lists must have same size
  first list length: 6
  other list length: 5
  procedure: #<procedure:...tmp/tmpzkg_7reh.rkt:11:35>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzkg_7reh.rkt:24:4

map: all lists must have same size
  first list length: 5
  other list length: 4
  procedure: #<procedure:...tmp/tmpzkg_7reh.rkt:11:35>
--------------------

