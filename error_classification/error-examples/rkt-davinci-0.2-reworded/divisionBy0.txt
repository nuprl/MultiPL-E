HumanEval_127_intersection: 77
HumanEval_94_skjkasdkd: 68
HumanEval_82_prime_length: 43
HumanEval_31_is_prime: 91
HumanEval_49_modp: 7
HumanEval_143_words_in_sentence: 6
HumanEval_4_mean_absolute_deviation: 16
HumanEval_76_is_simple_power: 3
HumanEval_96_count_up_to: 9
HumanEval_39_prime_fib: 41
HumanEval_153_Strongest_Extension: 3
HumanEval_59_largest_prime_factor: 1
HumanEval_78_hex_key: 1
HumanEval_71_triangle_area: 1
HumanEval_65_circular_shift: 2
HumanEval_97_multiply: 5
HumanEval_103_rounded_avg: 2
==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0461h6xb.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0461h6xb.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0461h6xb.rkt:56:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp0461h6xb.rkt:59:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0461h6xb.rkt:60:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (helper i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (helper (- i 1)))))
    (helper (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (define (helper lst)
    (cond ((null? lst) 0)
          ((prime? (car lst)) (max (car lst) (helper (cdr lst))))
          (else (helper (cdr lst)))))
  (sum-digits (helper lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0fba66vx.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0fba66vx.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0fba66vx.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0fba66vx.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0fba66vx.rkt:44:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0jqy6j5l.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0jqy6j5l.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (prime?-iter n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime?-iter n (- i 1)))))
    (prime?-iter n (floor (/ n 2))))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0o7md0lg.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0o7md0lg.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0o7md0lg.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (> (car interval1) (car interval2))
          (car interval1)
          (car interval2)))
    (define (intersection-end interval1 interval2)
      (if (< (cadr interval1) (cadr interval2))
          (cadr interval1)
          (cadr interval2)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (- n 1)))
  (if (<= (intersection-length interval1 interval2) 0)
      "NO"
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0rgaw18j.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0rgaw18j.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1dd3kwn8.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(null? interval1) '()]
      [(null? interval2) '()]
      [(< (car interval1) (car interval2)) (intersection-helper (cdr interval1) interval2)]
      [(> (car interval1) (car interval2)) (intersection-helper interval1 (cdr interval2))]
      [else (cons (car interval1) (intersection-helper (cdr interval1) (cdr interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (length-intersection interval)
    (cond
      [(null? interval) 0]
      [else (+ 1 (length-intersection (cdr interval)))]))
  (cond
    [(is-prime? (length-intersection (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1e88wlfb.rkt:50:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1e88wlfb.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1e88wlfb.rkt:53:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp1e88wlfb.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1e88wlfb.rkt:57:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (/ n 2)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (max-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst))
           (max (car lst) (max-prime (cdr lst))))
          (else (max-prime (cdr lst)))))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:41:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 8191/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1i9s3gtv.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 127/2
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (= n 0)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (* (modp (- n 1) p) 2) p))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (= n 0)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (* (modp (- n 1) p) 2) p))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (= n 0)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (* (modp (- n 1) p) 2) p))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (= n 0)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (* (modp (- n 1) p) 2) p))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp1ueft895.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else '())))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (cond ((null? (interval-intersection interval1 interval2)) "NO")
        ((is-prime? (interval-length (interval-intersection interval1 interval2))) "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp25k_3kgl.rkt:50:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp25k_3kgl.rkt:51:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp25k_3kgl.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp25k_3kgl.rkt:54:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp25k_3kgl.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp25k_3kgl.rkt:57:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-iter? n (- i 1)))))
    (is-prime-iter? n (quotient n 2)))
  (define (words-in-sentence-iter sentence result)
    (cond ((null? sentence) result)
          ((is-prime? (string-length (car sentence)))
           (words-in-sentence-iter (cdr sentence) (string-append result " " (car sentence))))
          (else (words-in-sentence-iter (cdr sentence) result))))
  (string-trim (words-in-sentence-iter (string-split sentence) "")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27eblla1.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp27eblla1.rkt:39:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond [(empty? interval1) '()]
            [(empty? interval2) '()]
            [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
            [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
            [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (prime? n)
    (define (prime?-helper n divisor)
      (cond [(= divisor 1) #t]
            [(= (modulo n divisor) 0) #f]
            [else (prime?-helper n (- divisor 1))]))
    (prime?-helper n (- n 1)))
  (define (length lst)
    (cond [(empty? lst) 0]
          [else (+ 1 (length (rest lst)))]))
  (cond [(empty? (interval-intersection interval1 interval2)) "NO"]
        [(prime? (length (interval-intersection interval1 interval2))) "YES"]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2dezmlx3.rkt:49:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2dezmlx3.rkt:51:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2dezmlx3.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2dezmlx3.rkt:55:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2dezmlx3.rkt:56:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else
         (list 0 0)]))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (is-prime-helper n (- i 1))]))
  (is-prime-helper n (- n 1)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(= (length-of-intersection (intersection-helper interval1 interval2)) 0)
     "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2)))
     "YES"]
    [else
     "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2hcq48az.rkt:59:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2hcq48az.rkt:60:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2hcq48az.rkt:62:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2hcq48az.rkt:64:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_helper numbers sum count)
    (cond
      [(empty? numbers) (/ sum count)]
      [else (mean_absolute_deviation_helper (rest numbers) (+ sum (abs (- (first numbers) (/ sum count)))) (+ count 1))]))
  (mean_absolute_deviation_helper numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2jn4vgwj.rkt:22:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2jn4vgwj.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2jn4vgwj.rkt:24:4

/: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else '())))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-to-string interval)
    (cond ((null? interval) "NO")
          ((= (interval-length interval) 0) "NO")
          ((is-prime? (interval-length interval)) "YES")
          (else "NO")))
  (interval-to-string (interval-intersection interval1 interval2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2k_6dwur.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2k_6dwur.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2k_6dwur.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2k_6dwur.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (get-largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (get-largest-prime (cdr lst)))]
      [else (get-largest-prime (cdr lst))]))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (quotient n 10)))]))
  (sum-digits (get-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2lwndxvp.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2lwndxvp.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2lwndxvp.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2lwndxvp.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2lwndxvp.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2lwndxvp.rkt:47:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (loop i)
      (cond ((= i 1) #t)
            ((is-divisible? n i) #f)
            (else (loop (- i 1)))))
    (loop (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2p_drmd1.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2p_drmd1.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (interval-length interval)
    (if (empty? interval)
        0
        (+ 1 (interval-length (rest interval)))))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-intersection-length interval1 interval2)
    (interval-length (interval-intersection interval1 interval2)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-intersection-length interval1 interval2)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2r2qncss.rkt:55:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2r2qncss.rkt:57:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2r2qncss.rkt:58:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp2r2qncss.rkt:61:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2r2qncss.rkt:62:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n div)
    (cond ((= div 1) #t)
          ((= (modulo n div) 0) #f)
          (else (is_prime-helper n (- div 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp2xr7tgb1.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp30fah2i2.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (/ n 2)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (iter lst largest)
    (cond
      [(null? lst) (sum-digits largest)]
      [(and (is-prime? (car lst)) (> (car lst) largest)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) largest)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:44:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp32ho8utu.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/2
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-length-helper interval1 interval2)
      (cond
        [(empty? interval1) 0]
        [(empty? interval2) 0]
        [(and (first interval1) (first interval2))
         (if (> (first interval1) (first interval2))
             (intersection-length-helper (rest interval1) interval2)
             (intersection-length-helper interval1 (rest interval2)))]
        [(and (first interval1) (second interval2))
         (if (> (first interval1) (second interval2))
             (intersection-length-helper (rest interval1) interval2)
             (intersection-length-helper interval1 (rest interval2)))]
        [(and (second interval1) (first interval2))
         (if (> (second interval1) (first interval2))
             (intersection-length-helper interval1 (rest interval2))
             (intersection-length-helper (rest interval1) interval2))]
        [(and (second interval1) (second interval2))
         (if (> (second interval1) (second interval2))
             (intersection-length-helper interval1 (rest interval2))
             (intersection-length-helper (rest interval1) interval2))]))
    (intersection-length-helper interval1 interval2))
  (define (prime? n)
    (define (prime?-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (prime?-helper n (- i 1))]))
    (prime?-helper n (floor (/ n 2))))
  (cond
    [(empty? interval1) "NO"]
    [(empty? interval2) "NO"]
    [(prime? (intersection-length interval1 interval2)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:63:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:64:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:65:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:66:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:67:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:68:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:69:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp357trxiy.rkt:70:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (is-prime-iter n div)
      (cond
        [(= div 1) #t]
        [(= (modulo n div) 0) #f]
        [else (is-prime-iter n (- div 1))]))
    (is-prime-iter n (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (find-largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime (car lst)) (car lst)]
      [else (find-largest-prime (cdr lst))]))
  (sum-digits (find-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3_u89i7s.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3ffjz71e.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-iter? n (- i 1))]))
    (is-prime-iter? n (- n 1)))
  (define (largest-prime lst)
    (define (largest-prime-iter lst largest)
      (cond
        [(null? lst) largest]
        [(is-prime? (car lst)) (largest-prime-iter (cdr lst) (car lst))]
        [else (largest-prime-iter (cdr lst) largest)]))
    (largest-prime-iter lst 0))
  (define (sum-digits n)
    (define (sum-digits-iter n sum)
      (cond
        [(= n 0) sum]
        [else (sum-digits-iter (/ n 10) (+ sum (modulo n 10)))]))
    (sum-digits-iter n 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:50:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:51:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:52:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:53:4

modulo: contract violation
  expected: integer?
  given: 7/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3gzmdql6.rkt:54:4

modulo: contract violation
  expected: integer?
  given: 97/10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (< (car interval1) (car interval2))
          (car interval2)
          (car interval1)))
    (define (intersection-end interval1 interval2)
      (if (> (cadr interval1) (cadr interval2))
          (cadr interval2)
          (cadr interval1)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (- n 1)))
  (if (> (intersection-length interval1 interval2) 0)
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3vl69p92.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3vl69p92.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (iter lst largest)
    (cond ((null? lst) (sum-digits largest))
          ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) largest))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:44:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:46:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3zx2ieww.rkt:47:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(null? interval1) '()]
        [(> (car interval1) (car interval2)) (interval-intersection-helper interval2 interval1)]
        [(< (car interval1) (car interval2)) (interval-intersection-helper (cdr interval1) interval2)]
        [(< (cadr interval1) (cadr interval2)) (cons (car interval1) (cons (cadr interval1) '()))]
        [else (cons (car interval1) (cons (cadr interval2) '()))]))
    (interval-intersection-helper interval1 interval2))
  (define (prime? n)
    (define (prime?-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (prime?-helper n (- i 1))]))
    (prime?-helper n (- n 1)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-prime? interval)
    (prime? (interval-length interval)))
  (cond
    [(null? (interval-intersection interval1 interval2)) "NO"]
    [(interval-prime? (interval-intersection interval1 interval2)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp46hfy5p8.rkt:53:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp46hfy5p8.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp46hfy5p8.rkt:56:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp46hfy5p8.rkt:59:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp46hfy5p8.rkt:60:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(-2)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond ((and (<= (car interval1) (car interval2))
                (<= (car interval2) (cadr interval1)))
           (list (car interval2) (cadr interval1)))
          ((and (<= (car interval2) (car interval1))
                (<= (car interval1) (cadr interval2)))
           (list (car interval1) (cadr interval2)))
          (else '())))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (- i 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (length-of-interval interval)
    (- (cadr interval) (car interval)))
  (let ((intersection (intersection-helper interval1 interval2)))
    (cond ((null? intersection) "NO")
          ((is-prime? (length-of-interval intersection)) "YES")
          (else "NO"))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4amhvgvj.rkt:49:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4amhvgvj.rkt:50:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp4amhvgvj.rkt:51:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp4amhvgvj.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4amhvgvj.rkt:55:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4amhvgvj.rkt:56:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(< (first interval1) (first interval2)) (intersection-helper-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (intersection-helper-helper interval1 (rest interval2))]
        [else (cons (first interval1) (intersection-helper-helper (rest interval1) (rest interval2)))]))
    (intersection-helper-helper (sort interval1 <) (sort interval2 <)))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ydbnqv2.rkt:49:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp4ydbnqv2.rkt:51:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp4ydbnqv2.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp4ydbnqv2.rkt:55:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ydbnqv2.rkt:56:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp52ia5dny.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp52ia5dny.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-iter n (- i 1))]))
  (is_prime-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5_51ywqj.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else '())))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (- i 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-is-prime? interval)
    (is-prime? (interval-length interval)))
  (define (interval-intersect? interval1 interval2)
    (not (null? (interval-intersection interval1 interval2))))
  (cond ((interval-intersect? interval1 interval2)
         (if (interval-is-prime? (interval-intersection interval1 interval2))
             "YES"
             "NO"))
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5_y3506_.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5_y3506_.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5_y3506_.rkt:58:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5_y3506_.rkt:60:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5_y3506_.rkt:62:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5_y3506_.rkt:63:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) empty]
      [(empty? interval2) empty]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (- n 1)))
  (define (length lst)
    (cond
      [(empty? lst) 0]
      [else (+ 1 (length (rest lst)))]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5amdgzcb.rkt:51:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5amdgzcb.rkt:53:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5amdgzcb.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5amdgzcb.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5amdgzcb.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(empty? lst) acc]
      [(is-prime? (first lst)) (iter (rest lst) (sum-digits (first lst)))]
      [else (iter (rest lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:46:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:47:4
actual:     5
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:49:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:51:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5bv42tog.rkt:52:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (and (integer? (expt n (round (log x n))))
       (= (expt n (round (log x n))) x)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5hxrkrx2.rkt:36:4

/: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5v16iz68.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-interval-intersection interval1 interval2)
      (define (interval-interval-intersection-helper interval1 interval2)
        (if (or (< (car interval1) (car interval2))
                (> (cadr interval1) (cadr interval2)))
            (list (max (car interval1) (car interval2))
                  (min (cadr interval1) (cadr interval2)))
            interval2))
      (interval-interval-intersection-helper interval1 interval2))
    (interval-interval-intersection interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (intersection-length interval1 interval2)
    (interval-length (interval-intersection interval1 interval2)))
  (define (intersection-is-prime? interval1 interval2)
    (is-prime? (intersection-length interval1 interval2)))
  (if (intersection-is-prime? interval1 interval2)
      "YES"
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5wrynyyz.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5wrynyyz.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5wrynyyz.rkt:58:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5wrynyyz.rkt:60:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5wrynyyz.rkt:62:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5wrynyyz.rkt:63:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (if (= i 1)
        #t
        (if (= (modulo n i) 0)
            #f
            (is_prime-iter n (- i 1)))))
  (is_prime-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6688ig5e.rkt:38:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (helper d)
      (cond ((= d 1) #t)
            ((= (remainder n d) 0) #f)
            (else (helper (- d 1)))))
    (helper (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (define (helper lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (car lst) (helper (cdr lst))))
          (else (helper (cdr lst)))))
  (sum-digits (helper lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6_3w88ky.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6_3w88ky.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6_3w88ky.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6_3w88ky.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6_3w88ky.rkt:44:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (prime-helper n (- i 1))]))
    (prime-helper n (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ddozfdq.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6h9zx3dm.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6hft_pa0.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper n d)
      (cond
        [(= d 1) #t]
        [(= (modulo n d) 0) #f]
        [else (is-prime-helper n (- d 1))]))
    (is-prime-helper n (- n 1)))
  (define (prime-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (prime-digits (quotient n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (prime-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6qukrj16.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6qukrj16.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6qukrj16.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6qukrj16.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6qukrj16.rkt:47:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (iter i)
    (cond
      ((= i 1) #t)
      ((= (modulo n i) 0) #f)
      (else (iter (- i 1)))))
  (iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6re565c4.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((and (is-prime (car lst))
                (> (sum-digits (car lst)) (sum-digits acc)))
           (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ztfco10.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ztfco10.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ztfco10.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ztfco10.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ztfco10.rkt:48:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6ztfco10.rkt:51:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n d)
      (cond
        [(= d 1) #t]
        [(= (modulo n d) 0) #f]
        [else (is-prime-helper? n (- d 1))]))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp72tey__q.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (zero? n)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (modp (- n 1) p) (modulo (* 2 p) p)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_6ob9t4.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_6ob9t4.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_6ob9t4.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_6ob9t4.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_6ob9t4.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_6ob9t4.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (= n 0)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (* (modp (- n 1) p) 3) p))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7cz5ittu.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7cz5ittu.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7cz5ittu.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7cz5ittu.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7cz5ittu.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7cz5ittu.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper n d)
      (cond ((= d 1) #t)
            ((= (modulo n d) 0) #f)
            (else (is-prime-helper n (- d 1)))))
    (is-prime-helper n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7odmgxap.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else (list 0 0))))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (- i 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (cond ((= (interval-length (interval-intersection interval1 interval2)) 0)
         "NO")
        ((is-prime? (interval-length (interval-intersection interval1 interval2)))
         "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7xxc43xo.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp7xxc43xo.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp7xxc43xo.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7xxc43xo.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to n lst)
    (cond ((= n 0) lst)
          ((is_prime? n) (count_up_to (- n 1) (cons n lst)))
          (else (count_up_to (- n 1) lst))))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:37:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp80vb1vor.rkt:45:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(or (empty? interval1) (empty? interval2)) empty]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8biurp8g.rkt:52:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8biurp8g.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8biurp8g.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8biurp8g.rkt:58:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8biurp8g.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (< (car interval1) (car interval2))
          (car interval2)
          (car interval1)))
    (define (intersection-end interval1 interval2)
      (if (< (cadr interval1) (cadr interval2))
          (cadr interval1)
          (cadr interval2)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (floor (/ n 2))))
  (define (intersection-length-is-prime? interval1 interval2)
    (is-prime? (intersection-length interval1 interval2)))
  (define (intervals-intersect? interval1 interval2)
    (and (<= (car interval1) (cadr interval2))
         (<= (car interval2) (cadr interval1))))
  (if (intervals-intersect? interval1 interval2)
      (if (intersection-length-is-prime? interval1 interval2)
          "YES"
          "NO")
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fgpx3pg.rkt:58:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fgpx3pg.rkt:59:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fgpx3pg.rkt:62:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fgpx3pg.rkt:64:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8fgpx3pg.rkt:65:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter n (- i 1)))))
  (is_prime-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8ivr9s1m.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-iter? n (- i 1)))))
    (is-prime-iter? n (- n 1)))
  (define (words-in-sentence-iter sentence acc)
    (cond ((null? sentence) acc)
          ((is-prime? (string-length (car sentence)))
           (words-in-sentence-iter (cdr sentence) (string-append acc " " (car sentence))))
          (else (words-in-sentence-iter (cdr sentence) acc))))
  (words-in-sentence-iter (string-split sentence) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8m_3zwsk.rkt:36:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8m_3zwsk.rkt:37:4
actual:     " go for"
expected:   "go for"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8m_3zwsk.rkt:38:4
actual:     " there is no place"
expected:   "there is no place"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8m_3zwsk.rkt:39:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8m_3zwsk.rkt:40:4
actual:     " go for it"
expected:   "go for it"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp8m_3zwsk.rkt:42:4
actual:     " is"
expected:   "is"
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(or (empty? interval1) (empty? interval2)) empty]
        [(and (not (empty? interval1)) (not (empty? interval2)))
         (cond
           [(and (<= (first interval1) (first interval2)) (<= (first interval2) (second interval1)))
            (cons (first interval2) (interval-intersection-helper interval1 (rest interval2)))]
           [(and (<= (first interval2) (first interval1)) (<= (first interval1) (second interval2)))
            (cons (first interval1) (interval-intersection-helper (rest interval1) interval2))])]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) true]
        [(= (modulo n i) 0) false]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (second interval) (first interval)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:53:4

second: contract violation
  expected: list?
  given: '(2 . #<void>)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:54:4

second: contract violation
  expected: list?
  given: '(0 . #<void>)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:56:4

second: contract violation
  expected: list?
  given: '(-2 . #<void>)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:57:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:58:4

second: contract violation
  expected: list?
  given: #<void>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:59:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8x198p18.rkt:60:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp93r5wawe.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst))))
          (else (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:46:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:48:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9c90j00x.rkt:49:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(or (null? interval1) (null? interval2)) '()]
        [(< (car interval1) (car interval2)) (intersection-helper-helper (cdr interval1) interval2)]
        [(> (car interval1) (car interval2)) (intersection-helper-helper interval1 (cdr interval2))]
        [else (cons (car interval1) (intersection-helper-helper (cdr interval1) (cdr interval2)))]))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (length-of-intersection interval)
    (cond
      [(null? interval) 0]
      [else (+ 1 (length-of-intersection (cdr interval)))]))
  (cond
    [(null? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9d3u14j7.rkt:52:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9d3u14j7.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9d3u14j7.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9d3u14j7.rkt:58:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9d3u14j7.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-iter n (- i 1))]))
  (is_prime-iter n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9qkn_q2_.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-iter n (- i 1))]))
  (is_prime-iter n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9qkn_q2_.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-iter n (- i 1))]))
  (is_prime-iter n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9qkn_q2_.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-prime-helper n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (is-prime-helper n (- div 1)))))
    (is-prime-helper n (- n 1)))
  (define (count-up-to-helper n acc)
    (cond ((= n 0) acc)
          ((is-prime? n) (count-up-to-helper (- n 1) (cons n acc)))
          (else (count-up-to-helper (- n 1) acc))))
  (count-up-to-helper n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:37:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9v0gy2li.rkt:45:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation-iter numbers sum count)
    (cond ((null? numbers) (/ sum count))
          (else (mean_absolute_deviation-iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) (/ sum count))))
                                              (+ count 1)))))
  (mean_absolute_deviation-iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9w283i40.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9w283i40.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9w283i40.rkt:25:4

/: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (find-largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (find-largest-prime (cdr lst))))
          (else (find-largest-prime (cdr lst)))))
  (sum-digits (find-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_14wk34o.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_14wk34o.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_14wk34o.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_14wk34o.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_14wk34o.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_14wk34o.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:45:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:46:4
actual:     5
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:48:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:50:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_1nvju8n.rkt:51:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (helper i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (helper (- i 1)))))
  (helper (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_9crqz1w.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond [(empty? interval1) '()]
          [(empty? interval2) '()]
          [(and (>= (first interval1) (first interval2))
                (<= (first interval1) (second interval2)))
           (cons (first interval1) (intersection-helper (rest interval1) interval2))]
          [(and (>= (first interval2) (first interval1))
                (<= (first interval2) (second interval1)))
           (cons (first interval2) (intersection-helper interval1 (rest interval2)))]
          [else (intersection-helper (rest interval1) (rest interval2))]))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond [(= divisor 1) #t]
            [(= (modulo n divisor) 0) #f]
            [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (length-intersection interval)
    (cond [(empty? interval) 0]
          [else (+ 1 (length-intersection (rest interval)))]))
  (cond [(empty? (intersection-helper interval1 interval2)) "NO"]
        [(is-prime? (length-intersection (intersection-helper interval1 interval2))) "YES"]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:51:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:55:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:56:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_cd0_ak3.rkt:58:4
actual:     "YES"
expected:   "NO"
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (- n 1)))
  (define (prime-words-helper sentence result)
    (cond ((null? sentence) result)
          ((is-prime? (string-length (car sentence)))
           (prime-words-helper (cdr sentence) (string-append result " " (car sentence))))
          (else (prime-words-helper (cdr sentence) result))))
  (string-trim (prime-words-helper (string-split sentence) "")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0s2r2v5.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa0s2r2v5.rkt:39:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n s)
      (cond ((= n 0) s)
            (else (iter (quotient n 10) (+ s (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst max)
      (cond ((null? lst) max)
            ((and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) max))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaljg7g_2.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaljg7g_2.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaljg7g_2.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaljg7g_2.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaljg7g_2.rkt:48:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(or (< (car interval1) (car interval2))
             (> (cadr interval1) (cadr interval2)))
         interval2]
        [(or (< (car interval2) (car interval1))
             (> (cadr interval2) (cadr interval1)))
         interval1]
        [else
         (list (max (car interval1) (car interval2))
               (min (cadr interval1) (cadr interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (cond
    [(< (interval-length (interval-intersection interval1 interval2)) 1)
     "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2)))
     "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb6butvzq.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpb6butvzq.rkt:60:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpb6butvzq.rkt:62:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb6butvzq.rkt:63:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (iter lst largest)
    (cond ((null? lst) (sum-digits largest))
          ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) largest))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:42:4
actual:     5
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:44:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:46:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbfhkg3im.rkt:47:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbi7vvshj.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbi7vvshj.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbi7vvshj.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbi7vvshj.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbi7vvshj.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbi7vvshj.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-iter (- i 1))]))
  (is_prime-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbyif84xp.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-iter (- i 1))]))
  (is_prime-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbyif84xp.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime? n (- i 1))]))
    (is_prime? n (- n 1)))
  (define (count_up_to n lst)
    (cond
      [(= n 0) lst]
      [(is_prime? n) (count_up_to (- n 1) (cons n lst))]
      [else (count_up_to (- n 1) lst)]))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbypeisqo.rkt:47:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime_helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime_helper n (- i 1)))))
  (is_prime_helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbzf5xpn3.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (if (or (null? interval1) (null? interval2))
          '()
          (if (and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
              (cons (car interval2) (interval-intersection-helper interval1 (cdr interval2)))
              (interval-intersection-helper interval1 (cdr interval2)))))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (- i 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection-length interval1 interval2)
    (interval-length (interval-intersection interval1 interval2)))
  (if (null? (interval-intersection interval1 interval2))
      "NO"
      (if (is-prime? (interval-intersection-length interval1 interval2))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:54:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:55:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(0)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:56:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:57:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:58:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:60:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc2t2j96i.rkt:61:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(-2)
--------------------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (if (= (expt n (round (log x n))) x)
      #t
      #f))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc3d3ijc5.rkt:37:4

/: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (< (car interval1) (car interval2))
          (car interval2)
          (car interval1)))
    (define (intersection-end interval1 interval2)
      (if (> (cadr interval1) (cadr interval2))
          (cadr interval2)
          (cadr interval1)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (floor (/ n 2))))
  (if (< (intersection-length interval1 interval2) 0)
      "NO"
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc50gt382.rkt:51:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc50gt382.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc50gt382.rkt:55:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc50gt382.rkt:57:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc50gt382.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcav7072v.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (helper i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (helper (- i 1)))))
    (helper (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (helper lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (car lst) (helper (cdr lst))))
          (else (helper (cdr lst)))))
  (sum-digits (helper lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcr8oybk6.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcr8oybk6.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcr8oybk6.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcr8oybk6.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcr8oybk6.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2))
              (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1))
              (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else '()]))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (- n 1)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2))
              (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1))
              (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else '()]))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (- n 1)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcs1uah6e.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvoz08su.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvoz08su.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvoz08su.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvoz08su.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcvoz08su.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcw0hep6z.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (prime-list lst)
    (cond
      [(null? lst) '()]
      [(is-prime? (car lst)) (cons (car lst) (prime-list (cdr lst)))]
      [else (prime-list (cdr lst))]))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (max-prime-sum lst)
    (cond
      [(null? lst) 0]
      [(> (car lst) (max-prime-sum (cdr lst))) (car lst)]
      [else (max-prime-sum (cdr lst))]))
  (sum-digits (max-prime-sum (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:49:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:51:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:53:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:54:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcypryvcl.rkt:55:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter n (- i 1)))))
  (is_prime-iter n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdk2fayc1.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter n (- i 1)))))
  (is_prime-iter n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdk2fayc1.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter n (- i 1)))))
  (is_prime-iter n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdk2fayc1.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (if (or (null? interval1) (null? interval2))
          '()
          (if (< (car interval1) (car interval2))
              (interval-intersection-helper (cdr interval1) interval2)
              (if (> (car interval1) (car interval2))
                  (interval-intersection-helper interval1 (cdr interval2))
                  (cons (car interval1) (interval-intersection-helper (cdr interval1) (cdr interval2)))))))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-intersection-length interval)
    (if (null? interval)
        0
        (+ 1 (interval-intersection-length (cdr interval)))))
  (if (null? (interval-intersection interval1 interval2))
      "NO"
      (if (is-prime? (interval-intersection-length (interval-intersection interval1 interval2)))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdy5jyq3v.rkt:58:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdy5jyq3v.rkt:60:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdy5jyq3v.rkt:61:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdy5jyq3v.rkt:64:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdy5jyq3v.rkt:65:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (if (or (null? interval1) (null? interval2))
          '()
          (if (and (<= (car interval1) (car interval2))
                   (<= (car interval2) (cadr interval1)))
              (cons (car interval2)
                    (interval-intersection-helper interval1 (cdr interval2)))
              (interval-intersection-helper interval1 (cdr interval2)))))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (- i 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (if (null? interval)
        0
        (+ 1 (interval-length (cdr interval)))))
  (if (null? (interval-intersection interval1 interval2))
      "NO"
      (if (is-prime? (interval-length (interval-intersection interval1 interval2)))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:58:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:59:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:60:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:62:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpe0f7xhbs.rkt:63:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else #f)))
    (interval-intersection-helper interval1 interval2)
    (interval-intersection-helper interval2 interval1))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (- i 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (cond ((not (interval-intersection interval1 interval2)) "NO")
        ((is-prime? (interval-intersection-length interval1)) "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefii7gcs.rkt:53:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefii7gcs.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpefii7gcs.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpefii7gcs.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefii7gcs.rkt:59:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpefii7gcs.rkt:60:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (define (interval-intersection-helper interval1 interval2)
        (if (and (<= (car interval1) (car interval2))
                 (<= (car interval2) (cadr interval1)))
            (list (car interval2) (cadr interval1))
            (if (and (<= (car interval2) (car interval1))
                     (<= (car interval1) (cadr interval2)))
                (list (car interval1) (cadr interval2))
                '())))
      (interval-intersection-helper interval1 interval2))
    (define (is-prime? n)
      (define (is-prime-helper n divisor)
        (if (= divisor 1)
            #t
            (if (= (modulo n divisor) 0)
                #f
                (is-prime-helper n (- divisor 1)))))
      (is-prime-helper n (- n 1)))
    (if (empty? (interval-intersection interval1 interval2))
        "NO"
        (if (is-prime? (interval-length (interval-intersection interval1 interval2)))
            "YES"
            "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevhyarxq.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpevhyarxq.rkt:58:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpevhyarxq.rkt:60:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpevhyarxq.rkt:62:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (iter lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (sum-digits (car lst)) (iter (cdr lst))))
          (else (iter (cdr lst)))))
  (iter lst))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeytztsvj.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeytztsvj.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeytztsvj.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeytztsvj.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeytztsvj.rkt:44:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpeytztsvj.rkt:47:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum mean)
    (if (null? numbers)
        (/ sum (length numbers))
        (mean_absolute_deviation_iter (cdr numbers)
                                      (+ sum (abs (- (car numbers) mean)))
                                      mean)))
  (define (mean numbers)
    (define (mean_iter numbers sum)
      (if (null? numbers)
          (/ sum (length numbers))
          (mean_iter (cdr numbers) (+ sum (car numbers)))))
    (mean_iter numbers 0))
  (mean_absolute_deviation_iter numbers 0 (mean numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfvoa1bit.rkt:30:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfvoa1bit.rkt:31:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfvoa1bit.rkt:32:4

/: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else
         #f]))
    (intersection-helper-helper interval1 interval2)
    (intersection-helper-helper interval2 interval1))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (is-prime-helper n (- i 1))]))
  (is-prime-helper n (- n 1)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(not (intersection-helper interval1 interval2))
     "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2)))
     "YES"]
    [else
     "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:60:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:61:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:63:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:65:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else
         #f]))
    (intersection-helper-helper interval1 interval2)
    (intersection-helper-helper interval2 interval1))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (is-prime-helper n (- i 1))]))
  (is-prime-helper n (- n 1)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(not (intersection-helper interval1 interval2))
     "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2)))
     "YES"]
    [else
     "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:60:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:61:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:63:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:65:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else
         #f]))
    (intersection-helper-helper interval1 interval2)
    (intersection-helper-helper interval2 interval1))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (is-prime-helper n (- i 1))]))
  (is-prime-helper n (- n 1)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (cond
    [(not (intersection-helper interval1 interval2))
     "NO"]
    [(is-prime? (length-of-intersection (intersection-helper interval1 interval2)))
     "YES"]
    [else
     "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:60:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:61:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:63:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgenhp7qh.rkt:65:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (cond ((= n 1) 2)
          ((= n 2) 3)
          ((prime? i) (if (= n 3) i (prime_fib (- n 1) (+ i 1))))
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgpyu4drr.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (iter lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (sum-digits (car lst)) (iter (cdr lst))))
          (else (iter (cdr lst)))))
  (iter lst))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgu5pj6bf.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgu5pj6bf.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgu5pj6bf.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgu5pj6bf.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgu5pj6bf.rkt:44:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpgu5pj6bf.rkt:47:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (list (max (car interval1) (car interval2))
            (min (cadr interval1) (cadr interval2))))
    (define (is-prime? n)
      (define (is-prime-helper n divisor)
        (cond ((= divisor 1) #t)
              ((= (modulo n divisor) 0) #f)
              (else (is-prime-helper n (- divisor 1)))))
      (is-prime-helper n (floor (/ n 2))))
    (define (interval-intersection-length interval)
      (interval-length (interval-intersection interval1 interval2)))
    (cond ((< (interval-intersection-length interval1) 0) "NO")
          ((is-prime? (interval-intersection-length interval1)) "YES")
          (else "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgv3biw7u.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgv3biw7u.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgv3biw7u.rkt:51:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgv3biw7u.rkt:53:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpgv3biw7u.rkt:54:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (prime-helper n (- divisor 1)))))
    (prime-helper n (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph2rcdp4q.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph2rcdp4q.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (if (null? numbers)
        (/ sum count)
        (mean_absolute_deviation_iter (cdr numbers)
                                      (+ sum (abs (- (car numbers) (/ sum count))))
                                      (+ count 1))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpheuo2v_u.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpheuo2v_u.rkt:25:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpheuo2v_u.rkt:26:4

/: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (if (null? numbers)
        (/ sum count)
        (mean_absolute_deviation_iter (cdr numbers)
                                      (+ sum (abs (- (car numbers) (/ sum count))))
                                      (+ count 1))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpheuo2v_u.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpheuo2v_u.rkt:25:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpheuo2v_u.rkt:26:4

/: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime? n i)
    (if (= i 1)
        #t
        (if (= (modulo n i) 0)
            #f
            (is_prime? n (- i 1)))))
  (is_prime? n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho85621f.rkt:38:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (define (interval-intersection-helper interval1 interval2)
        (cond ((and (<= (car interval1) (car interval2))
                    (<= (car interval2) (cadr interval1)))
               (list (car interval2) (cadr interval1)))
              ((and (<= (car interval2) (car interval1))
                    (<= (car interval1) (cadr interval2)))
               (list (car interval1) (cadr interval2)))
              (else '())))
      (interval-intersection-helper interval1 interval2))
    (define (is-prime? n)
      (define (is-prime-helper n i)
        (cond ((= i 1) #t)
              ((= (modulo n i) 0) #f)
              (else (is-prime-helper n (- i 1)))))
      (is-prime-helper n (floor (/ n 2))))
    (cond ((= (interval-length (interval-intersection interval1 interval2)) 0) "NO")
          ((is-prime? (interval-length (interval-intersection interval1 interval2))) "YES")
          (else "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvcd4t8j.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvcd4t8j.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmphvcd4t8j.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvcd4t8j.rkt:57:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphvcd4t8j.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(and (<= (first interval1) (first interval2))
              (<= (first interval2) (second interval1)))
         (cons (first interval2) (interval-intersection-helper interval1 (rest interval2)))]
        [else (interval-intersection-helper (rest interval1) interval2)]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (length-interval interval)
    (- (second interval) (first interval)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (length-interval (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:52:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:53:4

second: list contains too few elements
  list: '(1)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:57:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi48xjqh0.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to n l)
    (if (= n 0)
        l
        (if (is_prime? n)
            (count_up_to (- n 1) (cons n l))
            (count_up_to (- n 1) l))))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to n l)
    (if (= n 0)
        l
        (if (is_prime? n)
            (count_up_to (- n 1) (cons n l))
            (count_up_to (- n 1) l))))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi722en8f.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (define (interval-contains interval1 interval2)
        (and (<= (car interval2) (car interval1))
             (<= (cadr interval1) (cadr interval2))))
      (cond [(interval-contains interval1 interval2) interval1]
            [(interval-contains interval2 interval1) interval2]
            [(and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1))]
            [(and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2))]
            [else #f]))
    (define (interval-intersection-length interval1 interval2)
      (interval-length (interval-intersection interval1 interval2)))
    (interval-intersection-length interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond [(= i 1) #t]
            [(= (modulo n i) 0) #f]
            [else (is-prime-iter? n (- i 1))]))
    (is-prime-iter? n (floor (/ n 2))))
  (cond [(intersection-length interval1 interval2)
         (if (is-prime? (intersection-length interval1 interval2))
             "YES"
             "NO")]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitkdvn8s.rkt:59:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitkdvn8s.rkt:60:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitkdvn8s.rkt:63:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitkdvn8s.rkt:64:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: #f
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitkdvn8s.rkt:65:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitkdvn8s.rkt:66:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(or (empty? interval1) (empty? interval2)) empty]
        [(and (<= (first interval1) (first interval2)) (<= (first interval2) (second interval1)))
         (cons (first interval2) (intersection-helper-helper interval1 (rest interval2)))]
        [else (intersection-helper-helper interval1 (rest interval2))]))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (- (second (intersection-helper interval1 interval2)) (first (intersection-helper interval1 interval2)))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:48:4

second: list contains too few elements
  list: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:49:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:51:4

second: list contains too few elements
  list: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpitomiu36.rkt:55:4

second: list contains too few elements
  list: '(-2)
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (is-prime-iter n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-iter n (- i 1)))))
    (is-prime-iter n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (max-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max-prime (cdr lst)))
          (else (max (car lst) (max-prime (cdr lst))))))
  (sum-digits (max-prime lst)))
(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:41:4

modulo: contract violation
  expected: integer?
  given: 362/5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:43:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:44:4
actual:     0
expected:   19
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 61728/5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpixyrjrhv.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 4096/5
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (prime? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (prime? n (- i 1))]))
    (prime? n (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (car lst)]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiz9v7msa.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (is-prime-iter n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-iter n (- i 1)))))
    (is-prime-iter n (- n 1)))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpj3ia3dmg.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (interval-length interval)
    (if (empty? interval)
        0
        (+ 1 (interval-length (rest interval)))))
  (define (prime? n)
    (define (prime?-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (prime?-helper n (- i 1))]))
    (prime?-helper n (floor (/ n 2))))
  (if (empty? (interval-intersection interval1 interval2))
      "NO"
      (if (prime? (interval-length (interval-intersection interval1 interval2)))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjo4mefv5.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjo4mefv5.rkt:56:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjo4mefv5.rkt:57:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjo4mefv5.rkt:60:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjo4mefv5.rkt:61:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(< (car interval1) (car interval2))
         (interval-intersection-helper (cdr interval1) interval2)]
        [(< (car interval2) (car interval1))
         (interval-intersection-helper interval1 (cdr interval2))]
        [else
         (cons (car interval1)
               (interval-intersection-helper (cdr interval1) (cdr interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (define (intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (intersection-length interval1)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0cihty2.rkt:57:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk0cihty2.rkt:59:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk0cihty2.rkt:60:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0cihty2.rkt:63:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk0cihty2.rkt:64:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(-2)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5q7txjr.rkt:47:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk5q7txjr.rkt:49:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk5q7txjr.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk5q7txjr.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5q7txjr.rkt:54:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is_prime_helper? n (- divisor 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n acc)
    (cond ((= n 0) acc)
          ((is_prime? n) (count_up_to_helper (- n 1) (cons n acc)))
          (else (count_up_to_helper (- n 1) acc))))
  (count_up_to_helper n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:37:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk5x9k7cs.rkt:45:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (find-largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (find-largest-prime (cdr lst)))))
  (sum-digits (find-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk7zjdmxc.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n d)
      (if (= d 1)
          #t
          (if (= (modulo n d) 0)
              #f
              (prime? n (- d 1)))))
    (prime? n (floor (/ n 2))))
  (define (prime_fib n i)
    (if (= n 0)
        (prime_fib n (- i 1))
        (if (prime? (fib i))
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkajx42m8.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-iter? n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-iter? n (- divisor 1)))))
    (is-prime-iter? n (- n 1)))
  (define (words-in-sentence-iter sentence result)
    (cond ((null? sentence) result)
          ((is-prime? (string-length (car sentence)))
           (words-in-sentence-iter (cdr sentence) (string-append result " " (car sentence))))
          (else (words-in-sentence-iter (cdr sentence) result))))
  (words-in-sentence-iter (string-split sentence) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkf4rp2gd.rkt:36:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkf4rp2gd.rkt:37:4
actual:     " go for"
expected:   "go for"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkf4rp2gd.rkt:38:4
actual:     " there is no place"
expected:   "there is no place"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkf4rp2gd.rkt:39:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkf4rp2gd.rkt:40:4
actual:     " go for it"
expected:   "go for it"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkf4rp2gd.rkt:42:4
actual:     " is"
expected:   "is"
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum mean)
    (if (null? numbers)
        (/ sum (length numbers))
        (mean_absolute_deviation_iter (cdr numbers)
                                      (+ sum (abs (- (car numbers) mean)))
                                      mean)))
  (mean_absolute_deviation_iter numbers 0 (/ (apply + numbers) (length numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpktuc813v.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpktuc813v.rkt:25:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpktuc813v.rkt:26:4

/: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (sum-digits n)
    (if (zero? n)
        0
        (+ (modulo n 10) (sum-digits (quotient n 10)))))
  (define (is-prime? n)
    (define (helper d)
      (if (= d 1)
          #t
          (if (= (modulo n d) 0)
              #f
              (helper (- d 1)))))
    (helper (- n 1)))
  (define (largest-prime-value lst)
    (define (helper lst max)
      (if (null? lst)
          max
          (if (and (is-prime? (car lst)) (> (car lst) max))
              (helper (cdr lst) (car lst))
              (helper (cdr lst) max))))
    (helper lst 0))
  (sum-digits (largest-prime-value lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl3sb5cdr.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl3sb5cdr.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl3sb5cdr.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl3sb5cdr.rkt:50:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl3sb5cdr.rkt:51:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (prime-list lst)
    (cond ((null? lst) '())
          ((is-prime? (car lst)) (cons (car lst) (prime-list (cdr lst))))
          (else (prime-list (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (sum-digits (apply max (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl4kdw6ku.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplpt9um_b.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplpt9um_b.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplpt9um_b.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplpt9um_b.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplpt9um_b.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmplpt9um_b.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n divisor)
    (cond ((= divisor 1) #t)
          ((= (modulo n divisor) 0) #f)
          (else (is_prime-helper n (- divisor 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpltjr8g7g.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n divisor)
    (cond ((= divisor 1) #t)
          ((= (modulo n divisor) 0) #f)
          (else (is_prime-helper n (- divisor 1)))))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpltjr8g7g.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (helper i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (helper (- i 1)))))
    (helper (quotient n 2)))
  (define (sum-digits n)
    (define (helper n acc)
      (cond ((= n 0) acc)
            (else (helper (quotient n 10) (+ acc (remainder n 10))))))
    (helper n 0))
  (define (helper lst acc)
    (cond ((null? lst) acc)
          ((is-prime? (car lst)) (helper (cdr lst) (car lst)))
          (else (helper (cdr lst) acc))))
  (sum-digits (helper lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:46:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:48:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpluao87yh.rkt:49:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (prime-helper n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (prime-helper n (- div 1)))))
    (prime-helper n (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm4kssskz.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm4kssskz.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(< (first interval1) (first interval2))
         (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2))
         (interval-intersection-helper interval1 (rest interval2))]
        [else
         (cons (first interval1)
               (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n d)
      (cond
        [(= d 1) #t]
        [(= (modulo n d) 0) #f]
        [else (is-prime-helper n (- d 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm5z_xye3.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm5z_xye3.rkt:59:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm5z_xye3.rkt:60:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpm5z_xye3.rkt:63:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm5z_xye3.rkt:64:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter i)
    (if (= i 1)
        #t
        (if (= (remainder n i) 0)
            #f
            (is_prime-iter (- i 1)))))
  (is_prime-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm7vzypry.rkt:38:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (quotient n 2)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (quotient n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm_2_tt7v.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm_2_tt7v.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm_2_tt7v.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm_2_tt7v.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm_2_tt7v.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpm_2_tt7v.rkt:47:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime (car lst)) (iter (cdr lst) (max acc (car lst)))]
      [else (iter (cdr lst) acc)]))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlqe3hut.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlqe3hut.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlqe3hut.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlqe3hut.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlqe3hut.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(> (first interval1) (first interval2))
         (interval-intersection-helper interval1 (rest interval2))]
        [(> (first interval2) (first interval1))
         (interval-intersection-helper (rest interval1) interval2)]
        [else
         (cons (first interval1)
               (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (define (interval-to-list interval)
    (cond
      [(empty? interval) empty]
      [else (cons (first interval) (interval-to-list (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn5a_bekd.rkt:61:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn5a_bekd.rkt:63:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn5a_bekd.rkt:64:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn5a_bekd.rkt:67:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn5a_bekd.rkt:68:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (if (= n 0)
        i
        (if (prime? i)
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n (fib n)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:42:4
actual:     6
expected:   5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:43:4
actual:     12
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:44:4
actual:     18
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:45:4
actual:     30
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:46:4
actual:     38
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:47:4
actual:     54
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:48:4
actual:     72
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn8971uwe.rkt:49:4
actual:     102
expected:   433494437
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2))
              (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1))
              (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else
         #f]))
    (interval-intersection-helper interval1 interval2)
    (interval-intersection-helper interval2 interval1))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (cond
    [(not (interval-intersection interval1 interval2))
     "NO"]
    [(is-prime? (interval-intersection-length interval1))
     "YES"]
    [else
     "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn93_6yem.rkt:63:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn93_6yem.rkt:64:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn93_6yem.rkt:65:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpn93_6yem.rkt:67:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn93_6yem.rkt:69:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn93_6yem.rkt:70:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond
      [(= n 1) 1]
      [(= n 2) 1]
      [else (+ (fib (- n 1)) (fib (- n 2)))]))
  (define (prime? n)
    (define (prime? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (prime? n (- i 1))]))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (cond
      [(= n 1) 2]
      [(prime? (fib i)) (prime_fib (- n 1) (+ i 1))]
      [else (prime_fib n (+ i 1))]))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpngx2wzc_.rkt:48:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) empty]
        [(empty? interval2) empty]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
  (is-prime-helper n (- n 1)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnsadqupd.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnsadqupd.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnsadqupd.rkt:56:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnsadqupd.rkt:59:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnsadqupd.rkt:60:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-iter? n (- i 1))]))
    (is-prime-iter? n (floor (/ n 2))))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (car lst)]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnznsnt39.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to n lst)
    (if (= n 0)
        lst
        (if (is_prime? n)
            (count_up_to (- n 1) (cons n lst))
            (count_up_to (- n 1) lst))))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to n lst)
    (if (= n 0)
        lst
        (if (is_prime? n)
            (count_up_to (- n 1) (cons n lst))
            (count_up_to (- n 1) lst))))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo79zt4gh.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (iter lst max)
    (cond
      [(null? lst) (sum-digits max)]
      [(and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) max)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo9oh77_6.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else '())))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (cond ((null? (interval-intersection interval1 interval2)) "NO")
        ((is-prime? (interval-intersection-length interval1)) "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo_2_b7p4.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo_2_b7p4.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpo_2_b7p4.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpo_2_b7p4.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo_2_b7p4.rkt:58:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpo_2_b7p4.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (> (car interval1) (car interval2))
          (car interval1)
          (car interval2)))
    (define (intersection-end interval1 interval2)
      (if (< (cadr interval1) (cadr interval2))
          (cadr interval1)
          (cadr interval2)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (floor (/ n 2))))
  (define (intersects? interval1 interval2)
    (and (<= (car interval1) (cadr interval2))
         (<= (car interval2) (cadr interval1))))
  (if (intersects? interval1 interval2)
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoad37egm.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoad37egm.rkt:57:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoad37egm.rkt:60:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoad37egm.rkt:62:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoad37egm.rkt:63:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime_helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime_helper n (- i 1))]))
  (is_prime_helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpoqjbpj84.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (divisor? n d)
      (if (= d 1)
          #t
          (if (= (remainder n d) 0)
              #f
              (divisor? n (- d 1)))))
    (divisor? n (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpouhso5z5.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpouhso5z5.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (helper i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (helper (- i 1)))))
    (helper (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (helper lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (helper (cdr lst))))
          (else (helper (cdr lst)))))
  (sum-digits (helper lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpovevtiec.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpovevtiec.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpovevtiec.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpovevtiec.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpovevtiec.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp4k5m85g.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (- n 1)))
  (define (get-largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (get-largest-prime (cdr lst))))
          (else (get-largest-prime (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (sum-digits (get-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppaxx6bea.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime-helper n div)
      (if (= div 1)
          #t
          (if (= (modulo n div) 0)
              #f
              (prime-helper n (- div 1)))))
    (prime-helper n (floor (/ n 2))))
  (define (prime-fib-helper n count)
    (if (= count n)
        (fib count)
        (if (prime? (fib count))
            (prime-fib-helper n (+ count 1))
            (prime-fib-helper n (+ count 1)))))
  (prime-fib-helper n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppf9x2ckl.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else
         (list 0 0)]))
    (define (is-prime? n)
      (define (is-prime-helper n i)
        (cond
          [(= i 1)
           #t]
          [(= (modulo n i) 0)
           #f]
          [else
           (is-prime-helper n (- i 1))]))
      (is-prime-helper n (- n 1)))
    (define (length-of-interval interval)
      (- (cadr interval) (car interval)))
    (cond
      [(= (length-of-interval (intersection-helper-helper interval1 interval2)) 0)
       "NO"]
      [(is-prime? (length-of-interval (intersection-helper-helper interval1 interval2)))
       "YES"]
      [else
       "NO"]))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq0zo_374.rkt:59:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpq0zo_374.rkt:60:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpq0zo_374.rkt:62:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq0zo_374.rkt:64:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(or (empty? interval1) (empty? interval2)) empty]
        [(< (car interval1) (car interval2)) (interval-intersection-helper (cdr interval1) interval2)]
        [(> (car interval1) (car interval2)) (interval-intersection-helper interval1 (cdr interval2))]
        [else (cons (car interval1) (interval-intersection-helper (cdr interval1) (cdr interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq363fxvy.rkt:50:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpq363fxvy.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpq363fxvy.rkt:53:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq363fxvy.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq363fxvy.rkt:57:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(-2)
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (list (max (car interval1) (car interval2))
          (min (cadr interval1) (cadr interval2))))
  (define (prime? n)
    (define (prime-helper n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (prime-helper n (- div 1)))))
    (prime-helper n (- n 1)))
  (define (intersection-length interval1 interval2)
    (interval-length (interval-intersection interval1 interval2)))
  (if (and (not (equal? (interval-intersection interval1 interval2)
                        (list (car interval1) (car interval1))))
           (prime? (intersection-length interval1 interval2)))
      "YES"
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpq_5tujs_.rkt:48:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (floor (/ n 2))))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqtmfx0du.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqtmfx0du.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqtmfx0du.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (- n 1)))
  (define (find-largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (find-largest-prime (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (sum-digits (find-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqygtvwxx.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (if (null? numbers)
        (/ sum count)
        (mean_absolute_deviation_iter (cdr numbers)
                                      (+ sum (abs (- (car numbers) (/ sum count))))
                                      (+ count 1))))
  (define (mean numbers)
    (mean_absolute_deviation_iter numbers 0 0))
  (define (absolute_deviation numbers)
    (map (lambda (x) (abs (- x (mean numbers)))) numbers))
  (mean (absolute_deviation numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr053at3q.rkt:28:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr053at3q.rkt:29:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr053at3q.rkt:30:4

/: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (iter lst max)
    (cond ((null? lst) (sum-digits max))
          ((and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) max))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprk3wbt9j.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprk3wbt9j.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprk3wbt9j.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprk3wbt9j.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprk3wbt9j.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2))
              (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1))
              (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else '()]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-intersection-length interval1)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprl2uo13h.rkt:55:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprl2uo13h.rkt:56:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprl2uo13h.rkt:57:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprl2uo13h.rkt:59:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprl2uo13h.rkt:61:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprl2uo13h.rkt:62:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (cond [(< (car interval1) (car interval2))
           (cond [(< (cadr interval1) (car interval2)) 0]
                 [else (- (cadr interval1) (car interval2))])]
          [else
           (cond [(< (cadr interval2) (car interval1)) 0]
                 [else (- (cadr interval2) (car interval1))])]))
  (define (is-prime? n)
    (define (is-prime-iter? n divisor)
      (cond [(= divisor 1) #t]
            [(= (modulo n divisor) 0) #f]
            [else (is-prime-iter? n (- divisor 1))]))
    (is-prime-iter? n (- n 1)))
  (cond [(< (intersection-length interval1 interval2) 1) "NO"]
        [(is-prime? (intersection-length interval1 interval2)) "YES"]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprlgd_gvi.rkt:46:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprlgd_gvi.rkt:47:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprlgd_gvi.rkt:49:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprlgd_gvi.rkt:51:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprrxi2im_.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst))))
          (else (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:43:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:44:4
actual:     5
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:46:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:48:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:49:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst))))
          (else (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:43:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:44:4
actual:     5
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:46:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:48:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprssjbvzp.rkt:49:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-length-helper interval1 interval2)
      (cond
        [(empty? interval1) 0]
        [(empty? interval2) 0]
        [(< (first interval1) (first interval2)) (intersection-length-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (intersection-length-helper interval1 (rest interval2))]
        [else (add1 (intersection-length-helper (rest interval1) (rest interval2)))]))
    (intersection-length-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (sub1 i))]))
    (is-prime-helper n (sub1 n)))
  (cond
    [(< (intersection-length interval1 interval2) 1) "NO"]
    [(is-prime? (intersection-length interval1 interval2)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprzwps8vq.rkt:49:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprzwps8vq.rkt:51:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprzwps8vq.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprzwps8vq.rkt:55:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprzwps8vq.rkt:56:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper? n (- i 1))]))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 83/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpss_as4cl.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond
      [(= i 1) #t]
      [(= (modulo n i) 0) #f]
      [else (is_prime-helper n (- i 1))]))
  (is_prime-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsto4_rcn.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond ((and (<= (car interval1) (car interval2))
                  (<= (car interval2) (cadr interval1)))
             (list (car interval2) (cadr interval1)))
            ((and (<= (car interval2) (car interval1))
                  (<= (car interval1) (cadr interval2)))
             (list (car interval1) (cadr interval2)))
            (else (list 0 0))))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (intersection-length interval1 interval2)
    (interval-length (interval-intersection interval1 interval2)))
  (cond ((= (intersection-length interval1 interval2) 0) "NO")
        ((is-prime? (intersection-length interval1 interval2)) "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt6f65r4h.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpt6f65r4h.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpt6f65r4h.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt6f65r4h.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(< (car interval1) (car interval2)) (interval-intersection-helper (cdr interval1) interval2)]
        [(> (car interval1) (car interval2)) (interval-intersection-helper interval1 (cdr interval2))]
        [else (cons (car interval1) (interval-intersection-helper (cdr interval1) (cdr interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8z86iov.rkt:51:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpt8z86iov.rkt:53:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpt8z86iov.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8z86iov.rkt:57:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt8z86iov.rkt:58:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(-2)
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-iter? n (- i 1))]))
    (is-prime-iter? n (- n 1)))
  (define (words-in-sentence-iter sentence result)
    (cond
      [(empty? sentence) result]
      [(is-prime? (string-length (first sentence)))
       (words-in-sentence-iter (rest sentence) (string-append result (first sentence) " "))]
      [else (words-in-sentence-iter (rest sentence) result)]))
  (words-in-sentence-iter (string-split sentence) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptsxhks8c.rkt:38:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptsxhks8c.rkt:39:4
actual:     "go for "
expected:   "go for"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptsxhks8c.rkt:40:4
actual:     "there is no place "
expected:   "there is no place"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptsxhks8c.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptsxhks8c.rkt:42:4
actual:     "go for it "
expected:   "go for it"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptsxhks8c.rkt:44:4
actual:     "is "
expected:   "is"
--------------------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (iter i lst)
    (cond ((= i n) lst)
          ((is-prime? i) (iter (+ i 1) (cons i lst)))
          (else (iter (+ i 1) lst))))
  (reverse (iter 1 '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:37:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu8536ziz.rkt:45:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpu9xpobuw.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(or (null? interval1) (null? interval2)) '()]
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (cons (car interval2) (interval-intersection-helper interval1 (cdr interval2)))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (cons (car interval1) (interval-intersection-helper (cdr interval1) interval2))]
        [else (interval-intersection-helper (cdr interval1) (cdr interval2))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (cond
    [(null? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:52:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:53:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(0)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:55:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(-2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:57:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '(2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:58:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpubrfd2ky.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (intersection-start interval1 interval2)
      (max (car interval1) (car interval2)))
    (define (intersection-end interval1 interval2)
      (min (cadr interval1) (cadr interval2)))
    (define (intersection-interval interval1 interval2)
      (list (intersection-start interval1 interval2)
            (intersection-end interval1 interval2)))
    (define (intersection-interval-length interval1 interval2)
      (interval-length (intersection-interval interval1 interval2)))
    (intersection-interval-length interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper? n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper? n (- divisor 1)))))
    (is-prime-helper? n (- n 1)))
  (cond ((< (intersection-length interval1 interval2) 1) "NO")
        ((is-prime? (intersection-length interval1 interval2)) "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpudyjeozo.rkt:52:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpudyjeozo.rkt:57:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n divisor)
    (cond
      [(= divisor 1) #t]
      [(= (modulo n divisor) 0) #f]
      [else (is_prime-helper n (- divisor 1))]))
  (is_prime-helper n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpujk7f1t8.rkt:37:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpup4xt55r.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpupvyl54t.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (strength ext)
    (let ((cap 0) (sm 0))
      (for ([c (in-string ext)])
        (cond
          [(char-upper-case? c) (set! cap (+ cap 1))]
          [(char-lower-case? c) (set! sm (+ sm 1))]))
      (/ cap sm)))
  (define (strongest_extension extensions)
    (let ((strongest (car extensions))
          (strength (strength (car extensions))))
      (for ([ext (in-list (cdr extensions))])
        (let ((s (strength ext)))
          (cond
            [(> s strength) (set! strength s) (set! strongest ext)]
            [(= s strength) (set! strongest (if (< (string-length ext) (string-length strongest)) ext strongest))])))))
  (string-append class_name "." (strongest_extension extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:45:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:46:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:47:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2/3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:48:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:49:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:50:4

/: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(and (<= (car interval1) (car interval2))
            (<= (car interval2) (cadr interval1)))
       (list (car interval2) (cadr interval1))]
      [(and (<= (car interval2) (car interval1))
            (<= (car interval1) (cadr interval2)))
       (list (car interval1) (cadr interval2))]
      [else '()]))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (length-of-interval interval)
    (- (cadr interval) (car interval)))
  (define (intersection-length interval)
    (length-of-interval (intersection-helper interval1 interval2)))
  (cond
    [(= (intersection-length interval1) 0) "NO"]
    [(is-prime? (intersection-length interval1)) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuutjn3u2.rkt:54:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpuutjn3u2.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpuutjn3u2.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuutjn3u2.rkt:58:4

cadr: contract violation
  expected: (cons/c any/c pair?)
  given: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuutjn3u2.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_59_largest_prime_factor --------
#lang racket

;; Return the largest prime factor of n. Assume n > 1 and is not a prime.
;; >>> (largest_prime_factor 13195)
;; 29
;; >>> (largest_prime_factor 2048)
;; 2
(define (largest_prime_factor n)
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i 1)
          #t
          (if (zero? (modulo n i))
              #f
              (is-prime-helper n (- i 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (largest-prime-factor-helper n i)
    (if (is-prime? i)
        (if (zero? (modulo n i))
            (largest-prime-factor-helper (/ n i) i)
            (largest-prime-factor-helper n (- i 1)))
        (largest-prime-factor-helper n (- i 1))))
  (largest-prime-factor-helper n (floor (/ n 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_prime_factor))
    (check-equal? (candidate 15) 5)
    (check-equal? (candidate 27) 3)
    (check-equal? (candidate 63) 7)
    (check-equal? (candidate 330) 11)
    (check-equal? (candidate 13195) 29)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuv1rcpa9.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuv1rcpa9.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuv1rcpa9.rkt:32:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuv1rcpa9.rkt:33:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuv1rcpa9.rkt:34:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) '()]
        [(empty? interval2) '()]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuxmgrn_o.rkt:53:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpuxmgrn_o.rkt:55:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpuxmgrn_o.rkt:56:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpuxmgrn_o.rkt:59:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpuxmgrn_o.rkt:60:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (list (max (car interval1) (car interval2))
          (min (cadr interval1) (cadr interval2))))
  (define (is-prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (interval-intersection-length interval1 interval2)
    (interval-length (interval-intersection interval1 interval2)))
  (cond ((< (interval-intersection-length interval1 interval2) 1) "NO")
        ((is-prime? (interval-intersection-length interval1 interval2)) "YES")
        (else "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv76frecs.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv76frecs.rkt:51:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (if (and (<= (car interval1) (car interval2))
               (<= (car interval2) (cadr interval1)))
          (list (car interval2) (cadr interval1))
        (if (and (<= (car interval2) (car interval1))
                 (<= (car interval1) (cadr interval2)))
            (list (car interval1) (cadr interval2))
            '())))
    (if (and (<= (car interval1) (car interval2))
             (<= (car interval2) (cadr interval1)))
        (intersection-helper-helper interval1 interval2)
        (if (and (<= (car interval2) (car interval1))
                 (<= (car interval1) (cadr interval2)))
            (intersection-helper-helper interval2 interval1)
            '())))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (- i 1)))))
    (is-prime-helper n (quotient n 2)))
  (define (length-of-intersection interval)
    (- (cadr interval) (car interval)))
  (if (equal? (intersection-helper interval1 interval2) '())
      "NO"
      (if (is-prime? (length-of-intersection (intersection-helper interval1 interval2)))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvb4by_4b.rkt:60:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvb4by_4b.rkt:61:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvb4by_4b.rkt:62:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvb4by_4b.rkt:64:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvb4by_4b.rkt:66:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvb4by_4b.rkt:67:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (if (and (<= (car interval1) (car interval2))
               (<= (car interval2) (cadr interval1)))
          (list (car interval2) (cadr interval1))
          (if (and (<= (car interval2) (car interval1))
                   (<= (car interval1) (cadr interval2)))
              (list (car interval1) (cadr interval2))
              '())))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (- i 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection-length interval)
    (if (null? interval)
        '()
        (interval-length interval)))
  (define (intersection-length interval1 interval2)
    (interval-intersection-length (interval-intersection interval1 interval2)))
  (define (intersection-is-prime? interval1 interval2)
    (is-prime? (intersection-length interval1 interval2)))
  (if (null? (interval-intersection interval1 interval2))
      "NO"
      (if (intersection-is-prime? interval1 interval2)
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvj0wzgiy.rkt:62:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvj0wzgiy.rkt:63:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvj0wzgiy.rkt:64:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvj0wzgiy.rkt:66:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvj0wzgiy.rkt:68:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvj0wzgiy.rkt:69:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-helper n i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-helper n (- i 1)))))
  (is_prime-helper n (quotient n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvmkfok_d.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-length-helper interval1 interval2)
      (if (or (< (car interval1) (car interval2))
              (> (cadr interval1) (cadr interval2)))
          (list (car interval2) (cadr interval2))
          (list (car interval1) (cadr interval1))))
    (define (length interval)
      (- (cadr interval) (car interval)))
    (length (intersection-length-helper interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (- i 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (if (= (intersection-length interval1 interval2) 0)
      "NO"
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvo4zutzb.rkt:51:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvo4zutzb.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvo4zutzb.rkt:56:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvo4zutzb.rkt:57:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime-fib-helper n i)
    (cond ((= n 1) 2)
          ((= n 2) 3)
          ((= n 3) 5)
          ((= n 4) 13)
          ((= n 5) 89)
          ((and (prime? i) (= (fib i) i)) i)
          (else (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvww74wyh.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvww74wyh.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvww74wyh.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvww74wyh.rkt:48:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvww74wyh.rkt:49:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (absolute x)
    (if (< x 0)
        (- x)
        x))
  (define (mean_absolute_deviation_iter numbers mean sum)
    (if (null? numbers)
        (/ sum (length numbers))
        (mean_absolute_deviation_iter (cdr numbers) mean (+ sum (absolute (- (car numbers) mean))))))
  (define (mean numbers)
    (define (mean_iter numbers sum)
      (if (null? numbers)
          (/ sum (length numbers))
          (mean_iter (cdr numbers) (+ sum (car numbers)))))
    (mean_iter numbers 0))
  (mean_absolute_deviation_iter numbers (mean numbers) 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd06j7dl.rkt:32:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd06j7dl.rkt:33:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwd06j7dl.rkt:34:4

/: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwfs3qrrb.rkt:43:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_49_modp --------
#lang racket

;; Return 2^n modulo p (be aware of numerics).
;; >>> (modp 3 5)
;; 3
;; >>> (modp 1101 101)
;; 2
;; >>> (modp 0 101)
;; 1
;; >>> (modp 3 11)
;; 8
;; >>> (modp 100 101)
;; 1
(define (modp n p)
  (if (zero? n)
      1
      (if (even? n)
          (modulo (modp (/ n 2) p) (modulo (* 2 p) p))
          (modulo (* (modp (- n 1) p) 2) p))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate modp))
    (check-equal? (candidate 3 5) 3)
    (check-equal? (candidate 1101 101) 2)
    (check-equal? (candidate 0 101) 1)
    (check-equal? (candidate 3 11) 8)
    (check-equal? (candidate 100 101) 1)
    (check-equal? (candidate 30 5) 4)
    (check-equal? (candidate 31 5) 3)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwl_xlxqa.rkt:26:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwl_xlxqa.rkt:27:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwl_xlxqa.rkt:29:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwl_xlxqa.rkt:30:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwl_xlxqa.rkt:31:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwl_xlxqa.rkt:32:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter (- i 1)))))
  (is_prime-iter (quotient n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrafv8uz.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter (- i 1)))))
  (is_prime-iter (quotient n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwrafv8uz.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum mean)
    (cond ((null? numbers) (/ sum (length numbers)))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) mean)))
                                              mean))))
  (define (mean numbers)
    (define (mean_iter numbers sum)
      (cond ((null? numbers) (/ sum (length numbers)))
            (else (mean_iter (cdr numbers) (+ sum (car numbers))))))
    (mean_iter numbers 0))
  (mean_absolute_deviation_iter numbers 0 (mean numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwss4bg3y.rkt:28:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwss4bg3y.rkt:29:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwss4bg3y.rkt:30:4

/: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum mean)
    (cond ((null? numbers) (/ sum (length numbers)))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) mean)))
                                              mean))))
  (define (mean numbers)
    (define (mean_iter numbers sum)
      (cond ((null? numbers) (/ sum (length numbers)))
            (else (mean_iter (cdr numbers) (+ sum (car numbers))))))
    (mean_iter numbers 0))
  (mean_absolute_deviation_iter numbers 0 (mean numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwss4bg3y.rkt:28:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwss4bg3y.rkt:29:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwss4bg3y.rkt:30:4

/: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (define (interval-intersection-helper interval1 interval2)
        (if (and (<= (car interval1) (car interval2))
                 (<= (car interval2) (cadr interval1)))
            (list (car interval2) (cadr interval1))
            (if (and (<= (car interval2) (car interval1))
                     (<= (car interval1) (cadr interval2)))
                (list (car interval1) (cadr interval2))
                (list 0 0))))
      (if (and (<= (car interval1) (car interval2))
               (<= (car interval2) (cadr interval1)))
          (list (car interval2) (cadr interval1))
          (if (and (<= (car interval2) (car interval1))
                   (<= (car interval1) (cadr interval2)))
              (list (car interval1) (cadr interval2))
              (list 0 0))))
    (define (is-prime? n)
      (define (is-prime-helper n d)
        (if (= d 1)
            #t
            (if (= (modulo n d) 0)
                #f
                (is-prime-helper n (- d 1)))))
      (is-prime-helper n (floor (/ n 2))))
    (if (= (interval-length (interval-intersection interval1 interval2)) 0)
        "NO"
        (if (is-prime? (interval-length (interval-intersection interval1 interval2)))
            "YES"
            "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwt6zzpiv.rkt:63:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpwt6zzpiv.rkt:64:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpwt6zzpiv.rkt:66:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwt6zzpiv.rkt:68:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (< (car interval1) (car interval2))
          (car interval2)
          (car interval1)))
    (define (intersection-end interval1 interval2)
      (if (> (cadr interval1) (cadr interval2))
          (cadr interval2)
          (cadr interval1)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (- n 1)))
  (if (< (intersection-length interval1 interval2) 1)
      "NO"
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx4gdh1gx.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx4gdh1gx.rkt:59:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (list (max (car interval1) (car interval2))
            (min (cadr interval1) (cadr interval2))))
    (define (is-prime? n)
      (define (is-prime-helper n i)
        (cond
          [(= i 1) #t]
          [(= (modulo n i) 0) #f]
          [else (is-prime-helper n (- i 1))]))
      (is-prime-helper n (- n 1)))
    (define (interval-intersection-length interval)
      (interval-length (interval-intersection interval1 interval2)))
    (cond
      [(< (interval-intersection-length interval1) 0) "NO"]
      [(is-prime? (interval-intersection-length interval1)) "YES"]
      [else "NO"]))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx5vvdoz1.rkt:50:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx5vvdoz1.rkt:55:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter i)
    (cond ((= i 1) #t)
          ((= (modulo n i) 0) #f)
          (else (is_prime-iter (- i 1)))))
  (is_prime-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_bhlov7.rkt:36:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (if (or (< (car interval1) (car interval2))
              (> (cadr interval1) (cadr interval2)))
          (list (max (car interval1) (car interval2))
                (min (cadr interval1) (cadr interval2)))
          (list (car interval2) (cadr interval2))))
    (if (or (< (car interval1) (car interval2))
            (> (cadr interval1) (cadr interval2)))
        (interval-intersection-helper interval1 interval2)
        (interval-intersection-helper interval2 interval1)))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper n (- divisor 1)))))
    (is-prime-helper n (- n 1)))
  (define (interval-intersection-length interval)
    (interval-length (interval-intersection interval1 interval2)))
  (if (is-prime? (interval-intersection-length interval1))
      "YES"
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxng4tym7.rkt:56:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (cond ((null? numbers) (/ sum count))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) (/ sum count))))
                                              (+ count 1)))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:25:4

/: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (cond ((null? numbers) (/ sum count))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) (/ sum count))))
                                              (+ count 1)))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:25:4

/: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (cond ((null? numbers) (/ sum count))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) (/ sum count))))
                                              (+ count 1)))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:25:4

/: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (cond ((null? numbers) (/ sum count))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) (/ sum count))))
                                              (+ count 1)))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:25:4

/: division by zero
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (cond ((null? numbers) (/ sum count))
          (else (mean_absolute_deviation_iter (cdr numbers)
                                              (+ sum (abs (- (car numbers) (/ sum count))))
                                              (+ count 1)))))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:24:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxy5d_k_f.rkt:25:4

/: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (- n 1)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:47:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:49:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:54:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (- n 1)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:47:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:49:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy42ic1rb.rkt:54:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (find-largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (find-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:45:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:46:4
actual:     5
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:48:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:50:4
actual:     7
expected:   19
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpy9iwk7kq.rkt:51:4
actual:     16
expected:   10
--------------------

==========================
------- Program HumanEval_4_mean_absolute_deviation --------
#lang racket

;; For a given list of input numbers, calculate Mean Absolute Deviation
;; around the mean of this dataset.
;; Mean Absolute Deviation is the average absolute difference between each
;; element and a centerpoint (mean in this case):
;; MAD = average | x - x_mean |
;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))
;; 1.0
(define (mean_absolute_deviation numbers)
  (define (mean_absolute_deviation_iter numbers sum count)
    (cond
      [(empty? numbers) (/ sum count)]
      [else (mean_absolute_deviation_iter (rest numbers) (+ sum (abs (- (first numbers) (/ sum count)))) (+ count 1))]))
  (mean_absolute_deviation_iter numbers 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate mean_absolute_deviation))
    (check-equal? (candidate (list 1.0 2.0)) 0.5)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0)) 1.0)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) 1.2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyhwzv_1w.rkt:22:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyhwzv_1w.rkt:23:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpyhwzv_1w.rkt:24:4

/: division by zero
--------------------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (define (hex-to-dec num)
    (cond ((string=? num "A") 10)
          ((string=? num "B") 11)
          ((string=? num "C") 12)
          ((string=? num "D") 13)
          ((string=? num "E") 14)
          ((string=? num "F") 15)
          (else (string->number num))))
  (define (is-prime? num)
    (define (iter n)
      (cond ((= n 1) #t)
            ((= (modulo num n) 0) #f)
            (else (iter (- n 1)))))
    (iter (/ num 2)))
  (define (iter num count)
    (cond ((string=? num "") count)
        ((is-prime? (hex-to-dec (substring num 0 1)))
         (iter (substring num 1) (+ count 1)))
        (else (iter (substring num 1) count))))
  (iter num 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymfv1wd8.rkt:51:4

modulo: contract violation
  expected: integer?
  given: 11/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymfv1wd8.rkt:52:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymfv1wd8.rkt:53:4

modulo: contract violation
  expected: integer?
  given: 11/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymfv1wd8.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymfv1wd8.rkt:55:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpymfv1wd8.rkt:56:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:47:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:49:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:54:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:47:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:49:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:50:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpys267u_5.rkt:54:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-iter? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-iter? n (- i 1)))))
    (is-prime-iter? n (quotient n 2)))
  (define (words-in-sentence-iter sentence result)
    (cond ((null? sentence) result)
          ((is-prime? (string-length (car sentence)))
           (words-in-sentence-iter (cdr sentence) (string-append result " " (car sentence))))
          (else (words-in-sentence-iter (cdr sentence) result))))
  (string-trim (words-in-sentence-iter (string-split sentence " ") "")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz00ar17k.rkt:36:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz00ar17k.rkt:39:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (< (car interval1) (car interval2))
          (car interval2)
          (car interval1)))
    (define (intersection-end interval1 interval2)
      (if (> (cadr interval1) (cadr interval2))
          (cadr interval2)
          (cadr interval1)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper? n divisor)
      (if (= divisor 1)
          #t
          (if (= (modulo n divisor) 0)
              #f
              (is-prime-helper? n (- divisor 1)))))
    (is-prime-helper? n (- n 1)))
  (define (intersect? interval1 interval2)
    (and (<= (car interval1) (cadr interval2))
         (<= (car interval2) (cadr interval1))))
  (if (intersect? interval1 interval2)
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz6mr2sld.rkt:57:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz6mr2sld.rkt:62:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (/ n 2)))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sum-digits (/ n 10)))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:44:4

modulo: contract violation
  expected: integer?
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:48:4

modulo: contract violation
  expected: integer?
  given: 8191/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:49:4

modulo: contract violation
  expected: integer?
  given: 8191/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz_5zepso.rkt:50:4

modulo: contract violation
  expected: integer?
  given: 127/2
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond [(empty? interval1) empty]
            [(empty? interval2) empty]
            [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
            [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
            [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond [(= i 1) #t]
            [(= (modulo n i) 0) #f]
            [else (is-prime-helper n (- i 1))]))
    (is-prime-helper n (quotient n 2)))
  (define (interval-length interval)
    (cond [(empty? interval) 0]
          [else (+ 1 (interval-length (rest interval)))]))
  (cond [(empty? (interval-intersection interval1 interval2)) "NO"]
        [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
        [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzatyvji7.rkt:49:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzatyvji7.rkt:51:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzatyvji7.rkt:52:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzatyvji7.rkt:55:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzatyvji7.rkt:56:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n d)
      (cond ((= d 1) #t)
            ((= (modulo n d) 0) #f)
            (else (is-prime-helper? n (- d 1)))))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n d)
      (cond ((= d 1) #t)
            ((= (modulo n d) 0) #f)
            (else (is-prime-helper? n (- d 1)))))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper? n d)
      (cond ((= d 1) #t)
            ((= (modulo n d) 0) #f)
            (else (is-prime-helper? n (- d 1)))))
    (is-prime-helper? n (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (/ n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:39:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:42:4

modulo: contract violation
  expected: integer?
  given: 71/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:43:4

modulo: contract violation
  expected: integer?
  given: 3/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:45:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:46:4

modulo: contract violation
  expected: integer?
  given: 8191/10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzfatzuao.rkt:47:4

modulo: contract violation
  expected: integer?
  given: 127/10
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(empty? interval1) '()]
      [(empty? interval2) '()]
      [(< (first interval1) (first interval2)) (intersection-helper (rest interval1) interval2)]
      [(> (first interval1) (first interval2)) (intersection-helper interval1 (rest interval2))]
      [else (cons (first interval1) (intersection-helper (rest interval1) (rest interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (length lst)
    (cond
      [(empty? lst) 0]
      [else (+ 1 (length (rest lst)))]))
  (cond
    [(empty? (intersection-helper interval1 interval2)) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzg8hivyz.rkt:51:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzg8hivyz.rkt:53:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzg8hivyz.rkt:54:4
actual:     "NO"
expected:   "YES"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzg8hivyz.rkt:57:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzg8hivyz.rkt:58:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (power x n)
    (if (= n 0)
        1
        (* x (power x (- n 1)))))
  (define (is_integer? x)
    (if (= x (round x))
        #t
        #f))
  (if (= x (power n (round (log x n))))
      #t
      #f))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzhwftjep.rkt:45:4

/: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (- i 1)))))
    (is-prime-helper n (floor (/ n 2))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzljakkww.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzljakkww.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzljakkww.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzljakkww.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzljakkww.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzljakkww.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (= i 1)
          #t
          (if (= (remainder n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (if (= n 0)
        i
        (if (prime? i)
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n (fib n)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:41:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:42:4
actual:     6
expected:   5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:43:4
actual:     12
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:44:4
actual:     18
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:45:4
actual:     30
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:46:4
actual:     38
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:47:4
actual:     54
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:48:4
actual:     72
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpzn1cghei.rkt:49:4
actual:     102
expected:   433494437
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (helper i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (helper (- i 1)))))
    (helper (quotient n 2)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzsqqgx4m.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzsqqgx4m.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzsqqgx4m.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzsqqgx4m.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzsqqgx4m.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzsqqgx4m.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (max (car interval1) (car interval2)))
    (define (intersection-end interval1 interval2)
      (min (cadr interval1) (cadr interval2)))
    (define (intersection-length interval)
      (- (cadr interval) (car interval)))
    (define (intersection-interval interval1 interval2)
      (list (intersection-start interval1 interval2)
            (intersection-end interval1 interval2)))
    (define (intersection-interval-length interval)
      (intersection-length (intersection-interval interval1 interval2)))
    (define (is-prime? n)
      (define (is-prime-helper? n divisor)
        (cond ((= divisor 1) #t)
              ((= (modulo n divisor) 0) #f)
              (else (is-prime-helper? n (- divisor 1)))))
      (is-prime-helper? n (- n 1)))
    (define (intersection-is-prime? interval)
      (is-prime? (intersection-interval-length interval)))
    (cond ((> (intersection-interval-length interval1) 0)
           (if (intersection-is-prime? interval1)
               "YES"
               "NO"))
          (else "NO")))
  (intersection-length interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzvn26gjl.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzvn26gjl.rkt:61:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_71_triangle_area --------
#lang racket

;; Given the lengths of the three sides of a triangle. Return the area of
;; the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
;; Otherwise return -1
;; Three sides make a valid triangle when the sum of any two sides is greater 
;; than the third side.
;; Example:
;; >>> (triangle_area 3 4 5)
;; 6.0
;; >>> (triangle_area 1 2 10)
;; -1
(define (triangle_area a b c)
  (cond
    [(and (> a 0) (> b 0) (> c 0))
     (let ([s (/ (+ a b c) 2)])
       (* (/ s (- s a)) (/ s (- s b)) (/ s (- s c))))]
    [else -1]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate triangle_area))
    (check-equal? (candidate 3 4 5) 6.0)
    (check-equal? (candidate 1 2 10) -1)
    (check-equal? (candidate 4 8 5) 8.18)
    (check-equal? (candidate 2 2 2) 1.73)
    (check-equal? (candidate 1 2 3) -1)
    (check-equal? (candidate 10 5 7) 16.25)
    (check-equal? (candidate 2 6 3) -1)
    (check-equal? (candidate 1 1 1) 0.43)
    (check-equal? (candidate 2 2 10) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:25:4
actual:     36
expected:   6.0
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:26:4
actual:     -2197/693
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:27:4
actual:     4913/63
expected:   8.18
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:28:4
actual:     27
expected:   1.73
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:29:4

/: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:30:4
actual:     1331/24
expected:   16.25
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:31:4
actual:     -1331/35
expected:   -1
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:32:4
actual:     27
expected:   0.43
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp17y8glql.rkt:33:4
actual:     -343/75
expected:   -1
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (fib-helper n i)
    (cond ((= i n) (fib (- i 1)))
          (else (fib-helper n (+ i 1)))))
  (define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime-fib-helper n i)
    (cond ((= i n) (fib (- i 1)))
          ((and (prime? (fib i)) (prime? (fib (- i 1)))) (fib (- i 1)))
          (else (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:39:4
actual:     0
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3at_aquq.rkt:48:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (cond ((= n 1) i)
          ((and (prime? i) (= (fib n) i)) i)
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:37:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp5n7wath6.rkt:45:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (fib-helper n i)
    (cond ((= i n) (fib (- i 1)))
          (else (fib-helper n (+ i 1)))))
  (define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime-fib-helper n i)
    (cond ((= i n) (fib (- i 1)))
          ((and (prime? (fib i)) (not (prime? (fib (- i 1)))))
           (prime-fib-helper n (+ i 1)))
          (else (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:40:4
actual:     0
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:48:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7h399wl9.rkt:49:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime-fib-helper n i)
    (cond ((= n 1) (fib i))
          ((and (prime? (fib i)) (= (remainder n 2) 0)) (prime-fib-helper (/ n 2) (+ i 1)))
          (else (prime-fib-helper (- n 1) (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:37:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:38:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9op2dw1v.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime-iter n div)
      (if (= div 1)
          #t
          (if (= (modulo n div) 0)
              #f
              (prime-iter n (- div 1)))))
    (prime-iter n (floor (/ n 2))))
  (define (prime-fib-iter n count)
    (if (= n count)
        (fib count)
        (if (prime? (fib count))
            (prime-fib-iter n (+ count 1))
            (prime-fib-iter n (+ count 1)))))
  (prime-fib-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9zmfy3lz.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (floor (/ n 2))))
  (define (prime_fib n i)
    (if (= n 1)
        (fib i)
        (if (prime? (fib i))
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_a2l1l6f.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (shift-right x shift)
    (if (zero? shift)
        x
        (shift-right (quotient x 10) (- shift 1))))
  (define (shift-left x shift)
    (if (zero? shift)
        x
        (shift-left (* x 10) (- shift 1))))
  (define (num-digits x)
    (if (zero? x)
        0
        (+ 1 (num-digits (quotient x 10)))))
  (define (reverse-digits x)
    (define (reverse-digits-iter x acc)
      (if (zero? x)
          acc
          (reverse-digits-iter (quotient x 10) (+ (* acc 10) (remainder x 10)))))
    (reverse-digits-iter x 0))
  (define (digits-to-string x)
    (define (digits-to-string-iter x acc)
      (if (zero? x)
          acc
          (digits-to-string-iter (quotient x 10) (string-append (number->string (remainder x 10)) acc))))
    (digits-to-string-iter x ""))
  (digits-to-string (if (> shift (num-digits x))
                        (reverse-digits x)
                        (+ (shift-left (remainder x (shift-right x shift)) shift)
                           (shift-right x shift)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbim1insf.rkt:45:4
actual:     "1"
expected:   "001"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbim1insf.rkt:46:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbim1insf.rkt:48:4
actual:     "1"
expected:   "21"
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (is_prime n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((and (is_prime (fib i)) (is_prime (fib (+ i 1)))) (fib (+ i 1)))
          (else (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:37:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcny6j01o.rkt:45:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (define (interval-intersection-helper interval1 interval2)
      (cond
        [(empty? interval1) interval2]
        [(empty? interval2) interval1]
        [(< (first interval1) (first interval2)) (interval-intersection-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (interval-intersection-helper interval1 (rest interval2))]
        [else (cons (first interval1) (interval-intersection-helper (rest interval1) (rest interval2)))]))
    (interval-intersection-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (- n 1)))
  (define (interval-length interval)
    (cond
      [(empty? interval) 0]
      [else (+ 1 (interval-length (rest interval)))]))
  (cond
    [(empty? (interval-intersection interval1 interval2)) "NO"]
    [(is-prime? (interval-length (interval-intersection interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:53:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:54:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:55:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:56:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:57:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:58:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:59:4
actual:     "YES"
expected:   "NO"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmped173v7x.rkt:60:4
actual:     "YES"
expected:   "NO"
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (= i 1)
          #t
          (if (= (remainder n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (if (= n 1)
        i
        (if (prime? i)
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n (fib n)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:41:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:42:4
actual:     4
expected:   5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:43:4
actual:     8
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:44:4
actual:     14
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:45:4
actual:     24
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:46:4
actual:     32
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:47:4
actual:     48
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:48:4
actual:     68
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpf6aeos2n.rkt:49:4
actual:     98
expected:   433494437
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (prime? n (- div 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n count)
    (cond ((= n count) (fib count))
          ((and (prime? (fib count)) (prime? (fib (+ count 1))))
           (prime_fib n (+ count 1)))
          (else (prime_fib n (+ count 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfq6bh_m_.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond
      [(= n 1) 1]
      [(= n 2) 1]
      [else (+ (fib (- n 1)) (fib (- n 2)))]))
  (define (prime? n)
    (define (iter x)
      (cond
        [(= x 1) #t]
        [(= (modulo n x) 0) #f]
        [else (iter (- x 1))]))
    (iter (- n 1)))
  (define (iter n)
    (cond
      [(= n 1) (fib n)]
      [(and (prime? (fib n)) (prime? (fib (- n 1)))) (fib n)]
      [else (iter (- n 1))]))
  (iter n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:39:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:42:4
actual:     3
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:43:4
actual:     5
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:44:4
actual:     5
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:45:4
actual:     5
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:46:4
actual:     5
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:47:4
actual:     5
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfvksbr9e.rkt:48:4
actual:     5
expected:   433494437
--------------------

==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (strength ext)
    (let ((cap (length (regexp-match* #rx"[A-Z]" ext)))
          (sm (length (regexp-match* #rx"[a-z]" ext))))
      (/ cap sm)))
  (define (strongest-extension-name extensions)
    (define (strongest-extension-name-iter extensions strongest-extension-name)
      (if (null? extensions)
          strongest-extension-name
          (let ((ext (car extensions))
                (rest (cdr extensions)))
            (if (> (strength ext) (strength strongest-extension-name))
                (strongest-extension-name-iter rest ext)
                (strongest-extension-name-iter rest strongest-extension-name)))))
    (strongest-extension-name-iter extensions (car extensions)))
  (string-append class_name "." (strongest-extension-name extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpha8x3s1o.rkt:41:4
actual:     "Watashi.tEN"
expected:   "Watashi.eIGHt8OKe"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpha8x3s1o.rkt:44:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpha8x3s1o.rkt:45:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpha8x3s1o.rkt:46:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpha8x3s1o.rkt:48:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpha8x3s1o.rkt:49:4

/: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (floor (/ n 2))))
  (define (fib n)
    (define (iter i a b)
      (cond ((= i n) b)
            (else (iter (+ i 1) b (+ a b)))))
    (iter 1 0 1))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((and (prime? (fib i)) (prime? (fib (+ i 1)))) (fib (+ i 1)))
          (else (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:38:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpho7htget.rkt:46:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (modulo (modulo a 10) (modulo b 10)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:23:4
actual:     0
expected:   16
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:24:4
actual:     1
expected:   72
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:26:4
actual:     4
expected:   20
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:27:4
actual:     6
expected:   42
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:28:4
actual:     0
expected:   49
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:30:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (modulo (modulo a 10) (modulo b 10)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:23:4
actual:     0
expected:   16
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:24:4
actual:     1
expected:   72
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:26:4
actual:     4
expected:   20
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:27:4
actual:     6
expected:   42
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:28:4
actual:     0
expected:   49
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:30:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (modulo (modulo a 10) (modulo b 10)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:23:4
actual:     0
expected:   16
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:24:4
actual:     1
expected:   72
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:26:4
actual:     4
expected:   20
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:27:4
actual:     6
expected:   42
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:28:4
actual:     0
expected:   49
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:30:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (modulo (modulo a 10) (modulo b 10)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:23:4
actual:     0
expected:   16
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:24:4
actual:     1
expected:   72
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:26:4
actual:     4
expected:   20
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:27:4
actual:     6
expected:   42
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:28:4
actual:     0
expected:   49
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:30:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_97_multiply --------
#lang racket

;; Complete the function that takes two integers and returns 
;; the product of their unit digits.
;; Assume the input is always valid.
;; Examples:
;; >>> (multiply 148 412)
;; 16
;; >>> (multiply 19 28)
;; 72
;; >>> (multiply 2020 1851)
;; 0
;; >>> (multiply 14 -15)
;; 20
(define (multiply a b)
  (modulo (modulo a 10) (modulo b 10)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate multiply))
    (check-equal? (candidate 148 412) 16)
    (check-equal? (candidate 19 28) 72)
    (check-equal? (candidate 2020 1851) 0)
    (check-equal? (candidate 14 -15) 20)
    (check-equal? (candidate 76 67) 42)
    (check-equal? (candidate 17 27) 49)
    (check-equal? (candidate 0 1) 0)
    (check-equal? (candidate 0 0) 0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:23:4
actual:     0
expected:   16
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:24:4
actual:     1
expected:   72
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:26:4
actual:     4
expected:   20
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:27:4
actual:     6
expected:   42
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:28:4
actual:     0
expected:   49
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpip2tqyyj.rkt:30:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime-helper n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (prime-helper n (- div 1)))))
    (prime-helper n (- n 1)))
  (define (prime-fib-helper n count)
    (cond ((= n count) (fib count))
          ((and (prime? (fib count)) (prime? (fib (+ count 1))))
           (prime-fib-helper n (+ count 1)))
          (else (prime-fib-helper n (+ count 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime-helper n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (prime-helper n (- div 1)))))
    (prime-helper n (- n 1)))
  (define (prime-fib-helper n count)
    (cond ((= n count) (fib count))
          ((and (prime? (fib count)) (prime? (fib (+ count 1))))
           (prime-fib-helper n (+ count 1)))
          (else (prime-fib-helper n (+ count 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjpdtgums.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (is_prime n)
    (define (is_prime_iter n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_iter n (- i 1)))))
    (is_prime_iter n (floor (/ n 2))))
  (define (prime_fib_iter n i)
    (if (= i n)
        (fib i)
        (if (and (is_prime (fib i)) (is_prime (fib (+ i 1))))
            (prime_fib_iter n (+ i 1))
            (prime_fib_iter n (+ i 1)))))
  (prime_fib_iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk4eh0_os.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((and (prime? (fib i)) (not (prime? (fib (- i 1))))) (fib i))
          (else (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:37:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:38:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((and (prime? (fib i)) (not (prime? (fib (- i 1))))) (fib i))
          (else (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:37:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:38:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((and (prime? (fib i)) (not (prime? (fib (- i 1))))) (fib i))
          (else (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:37:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:38:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkerndg29.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (shift-right x shift)
    (if (zero? shift)
        x
        (shift-right (quotient x 10) (- shift 1))))
  (define (shift-left x shift)
    (if (zero? shift)
        x
        (shift-left (* x 10) (- shift 1))))
  (define (reverse-digits x)
    (define (reverse-digits-iter x acc)
      (if (zero? x)
          acc
          (reverse-digits-iter (quotient x 10) (+ (* acc 10) (remainder x 10)))))
    (reverse-digits-iter x 0))
  (define (number-of-digits x)
    (define (number-of-digits-iter x acc)
      (if (zero? x)
          acc
          (number-of-digits-iter (quotient x 10) (+ acc 1))))
    (number-of-digits-iter x 0))
  (define (digits-to-string x)
    (define (digits-to-string-iter x acc)
      (if (zero? x)
          acc
          (digits-to-string-iter (quotient x 10) (string-append (number->string (remainder x 10)) acc))))
    (digits-to-string-iter x ""))
  (digits-to-string (if (> shift (number-of-digits x))
                        (reverse-digits x)
                        (+ (shift-left (remainder x (shift-right x shift)) shift)
                           (shift-right x shift)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkqbl030p.rkt:47:4
actual:     "1"
expected:   "001"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpkqbl030p.rkt:48:4

remainder: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpkqbl030p.rkt:50:4
actual:     "1"
expected:   "21"
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond
      [(= n 1) 1]
      [(= n 2) 1]
      [else (+ (fib (- n 1)) (fib (- n 2)))]))
  (define (is_prime n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (iter i)
    (cond
      [(= i n) (fib i)]
      [(and (is_prime (fib i)) (is_prime (fib (+ i 1)))) (fib (+ i 1))]
      [else (iter (+ i 1))]))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:39:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmjljnm1h.rkt:48:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (prime-helper n (- divisor 1)))))
    (prime-helper n (- n 1)))
  (define (fib-helper n a b)
    (cond ((= n 1) a)
          ((= n 2) b)
          (else (fib-helper (- n 1) b (+ a b)))))
  (define (fib-prime-helper n a b counter)
    (cond ((= counter n) (fib-helper n a b))
          ((and (prime? (fib-helper n a b)) (prime? (fib-helper (- n 1) a b)))
           (fib-prime-helper n a b (+ counter 1)))
          (else (fib-prime-helper (- n 1) a b counter))))
  (fib-prime-helper n 1 1 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:39:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:40:4
actual:     3
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:41:4
actual:     5
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:42:4
actual:     5
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:43:4
actual:     5
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:44:4
actual:     5
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:45:4
actual:     5
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpmwgmv0fz.rkt:46:4
actual:     5
expected:   433494437
--------------------

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let ([sum (for/sum ([i (in-range n (+ m 1))]) i)])
        (number->string (round (/ sum (- m n))) 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:27:4
actual:     "100"
expected:   "0b11"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:28:4
actual:     "1100"
expected:   "0b1010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:29:4
actual:     "10000010101"
expected:   "0b1111001010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:30:4
actual:     "11111001001"
expected:   "0b1111100100"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:31:4
actual:     "1011000100"
expected:   "0b1011000010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:32:4
actual:     "101101111"
expected:   "0b101101110"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:33:4
actual:     "110110000"
expected:   "0b110101101"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:34:4
actual:     "1001110011"
expected:   "0b1001110010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:35:4
actual:     "11011101"
expected:   "0b11010111"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnohlm7d7.rkt:38:4

/: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (helper i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (helper (- i 1)))))
    (helper (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppjh051vw.rkt:39:4
actual:     3
expected:   10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppjh051vw.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppjh051vw.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppjh051vw.rkt:42:4
actual:     8
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppjh051vw.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((prime? (fib i)) (iter (+ i 1)))
          (else (iter (+ i 1)))))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:37:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:38:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:39:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:40:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppr022zmj.rkt:45:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (is_prime n)
    (define (is_prime-iter n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime-iter n (- i 1)))))
    (is_prime-iter n (- n 1)))
  (define (prime_fib-iter n i)
    (if (= n 1)
        (fib i)
        (if (and (is_prime (fib i)) (= (modulo n 2) 0))
            (prime_fib-iter (- n 1) (+ i 1))
            (prime_fib-iter n (+ i 1)))))
  (prime_fib-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpptiffnza.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:39:4
actual:     3
expected:   10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:42:4
actual:     8
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:39:4
actual:     3
expected:   10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:42:4
actual:     8
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:39:4
actual:     3
expected:   10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:42:4
actual:     8
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (car lst))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:39:4
actual:     3
expected:   10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:42:4
actual:     8
expected:   11
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppu10fldq.rkt:44:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n d)
      (if (= d 1)
          #t
          (if (= (remainder n d) 0)
              #f
              (prime? n (- d 1)))))
    (prime? n (floor (/ n 2))))
  (define (prime_fib n i)
    (if (= n i)
        (fib i)
        (if (prime? (fib i))
            (prime_fib n (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:48:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:49:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n d)
      (if (= d 1)
          #t
          (if (= (remainder n d) 0)
              #f
              (prime? n (- d 1)))))
    (prime? n (floor (/ n 2))))
  (define (prime_fib n i)
    (if (= n i)
        (fib i)
        (if (prime? (fib i))
            (prime_fib n (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:48:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr0f0tj5x.rkt:49:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime-helper n (- i 1)))))
    (prime-helper n (floor (/ n 2))))
  (define (prime-fib-helper n i)
    (cond ((= n 1) (fib i))
          ((and (prime? (fib i)) (= n 2)) (fib i))
          ((and (prime? (fib i)) (> n 2)) (prime-fib-helper (- n 1) (+ i 1)))
          (else (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprepm04t3.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (cond ((= n 1) i)
          ((prime? i) (prime_fib (- n 1) (+ i 1)))
          (else (prime_fib n (+ i 1)))))
  (prime_fib n (fib n)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:36:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:37:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:38:4
actual:     4
expected:   5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:39:4
actual:     8
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:40:4
actual:     14
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:41:4
actual:     24
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:42:4
actual:     32
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:43:4
actual:     48
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:44:4
actual:     68
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmprg6_841w.rkt:45:4
actual:     98
expected:   433494437
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (prime-fib-helper n i)
    (if (= n i)
        (fib n)
        (if (prime? (fib n))
            (prime-fib-helper n (+ i 1))
            (prime-fib-helper n n))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:41:4

modulo: division by zero
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:42:4
actual:     2
expected:   5
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:43:4
actual:     3
expected:   13
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:44:4
actual:     5
expected:   89
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:45:4
actual:     8
expected:   233
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:46:4
actual:     13
expected:   1597
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:47:4
actual:     21
expected:   28657
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:48:4
actual:     34
expected:   514229
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpruxthdxr.rkt:49:4
actual:     55
expected:   433494437
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (prime-fib-helper n i)
    (if (= i n)
        (fib i)
        (if (prime? (fib i))
            (prime-fib-helper n (+ i 1))
            (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime-helper n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (prime-fib-helper n i)
    (if (= i n)
        (fib i)
        (if (prime? (fib i))
            (prime-fib-helper n (+ i 1))
            (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsipvjdm9.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (strength extension)
    (let ((cap 0) (sm 0))
      (for ((c (in-string extension)))
        (cond
          [(char-upper-case? c) (set! cap (+ cap 1))]
          [(char-lower-case? c) (set! sm (+ sm 1))]))
      (/ cap sm)))
  (define (strongest_extension extensions)
    (let ((strongest_extension (car extensions))
          (strongest_extension_strength (strength (car extensions))))
      (for ((extension (in-list (cdr extensions))))
        (let ((extension_strength (strength extension)))
          (when (> extension_strength strongest_extension_strength)
            (set! strongest_extension extension)
            (set! strongest_extension_strength extension_strength))))
      strongest_extension))
  (string-append class_name "." (strongest_extension extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpsub6s5_0.rkt:43:4
actual:     "Watashi.tEN"
expected:   "Watashi.eIGHt8OKe"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsub6s5_0.rkt:46:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsub6s5_0.rkt:47:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsub6s5_0.rkt:48:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsub6s5_0.rkt:50:4

/: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpsub6s5_0.rkt:51:4

/: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond
      [(= n 1) 1]
      [(= n 2) 1]
      [else (+ (fib (- n 1)) (fib (- n 2)))]))
  (define (is_prime n)
    (define (is_prime_iter n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime_iter n (- i 1))]))
    (is_prime_iter n (floor (/ n 2))))
  (define (prime_fib_iter n i)
    (cond
      [(= n i) (fib i)]
      [(and (is_prime (fib i)) (not (is_prime (fib (+ i 1))))) (prime_fib_iter n (+ i 1))]
      [else (prime_fib_iter n (+ i 1))]))
  (prime_fib_iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:39:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt4lpexed.rkt:48:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n i)
      (if (= i 1)
          #t
          (if (= (remainder n i) 0)
              #f
              (prime-helper n (- i 1)))))
    (prime-helper n (- n 1)))
  (define (fib n)
    (if (= n 1)
        1
        (if (= n 2)
            2
            (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime-fib-helper n i)
    (if (= i n)
        (fib i)
        (if (and (prime? (fib i)) (not (= (fib i) 1)))
            (prime-fib-helper n (+ i 1))
            (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:42:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:48:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:49:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:50:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptb_bdfuo.rkt:51:4

remainder: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (floor (/ n 2))))
  (define (prime_fib n i)
    (if (= i n)
        (fib i)
        (if (prime? (fib i))
            (prime_fib n (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:46:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:47:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:48:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvoa_wdbu.rkt:49:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_103_rounded_avg --------
#lang racket

;; You are given two positive integers n and m, and your task is to compute the
;; average of the integers from n through m (including n and m). 
;; Round the answer to the nearest integer and convert that to binary.
;; If n is greater than m, return -1.
;; Example:
;; >>> (rounded_avg 1 5)
;; "0b11"
;; >>> (rounded_avg 7 5)
;; -1
;; >>> (rounded_avg 10 20)
;; "0b1111"
;; >>> (rounded_avg 20 33)
;; "0b11010"
(define (rounded_avg n m)
  (if (> n m)
      -1
      (let ((sum 0)
            (count 0))
        (for ([i (in-range n m)])
          (set! sum (+ sum i))
          (set! count (+ count 1)))
        (string->number (number->string (round (/ sum count))) 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rounded_avg))
    (check-equal? (candidate 1 5) "0b11")
    (check-equal? (candidate 7 13) "0b1010")
    (check-equal? (candidate 964 977) "0b1111001010")
    (check-equal? (candidate 996 997) "0b1111100100")
    (check-equal? (candidate 560 851) "0b1011000010")
    (check-equal? (candidate 185 546) "0b101101110")
    (check-equal? (candidate 362 496) "0b110101101")
    (check-equal? (candidate 350 902) "0b1001110010")
    (check-equal? (candidate 197 233) "0b11010111")
    (check-equal? (candidate 7 5) -1)
    (check-equal? (candidate 5 1) -1)
    (check-equal? (candidate 5 5) "0b101")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:31:4
actual:     #f
expected:   "0b11"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:32:4
actual:     2
expected:   "0b1010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:33:4
actual:     #f
expected:   "0b1111001010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:34:4
actual:     #f
expected:   "0b1111100100"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:35:4
actual:     #f
expected:   "0b1011000010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:36:4
actual:     #f
expected:   "0b101101110"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:37:4
actual:     #f
expected:   "0b110101101"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:38:4
actual:     #f
expected:   "0b1001110010"
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:39:4
actual:     #f
expected:   "0b11010111"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw3fd3azy.rkt:42:4

/: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (divisor? n d)
      (cond ((= d 1) #t)
            ((= (modulo n d) 0) #f)
            (else (divisor? n (- d 1)))))
    (divisor? n (- n 1)))
  (define (prime_fib_iter n count)
    (cond ((= n count) (fib count))
          ((and (prime? (fib count)) (prime? (fib (+ count 1))))
           (prime_fib_iter n (+ count 1)))
          (else (prime_fib_iter n (+ count 1)))))
  (prime_fib_iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (divisor? n d)
      (cond ((= d 1) #t)
            ((= (modulo n d) 0) #f)
            (else (divisor? n (- d 1)))))
    (divisor? n (- n 1)))
  (define (prime_fib_iter n count)
    (cond ((= n count) (fib count))
          ((and (prime? (fib count)) (prime? (fib (+ count 1))))
           (prime_fib_iter n (+ count 1)))
          (else (prime_fib_iter n (+ count 1)))))
  (prime_fib_iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:37:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:38:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:39:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:40:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:41:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:42:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:43:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:44:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:45:4

modulo: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwyfmatsm.rkt:46:4

modulo: division by zero
--------------------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))
  (define (prime? n)
    (define (prime? n i)
      (if (= i 1)
          #t
          (if (= (remainder n i) 0)
              #f
              (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (if (= n 1)
        (fib i)
        (if (prime? (fib i))
            (prime_fib (- n 1) (+ i 1))
            (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:40:4
actual:     1
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:41:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:42:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:43:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:44:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:45:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:46:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:47:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:48:4

remainder: division by zero
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpx_qiharh.rkt:49:4

remainder: division by zero
--------------------

