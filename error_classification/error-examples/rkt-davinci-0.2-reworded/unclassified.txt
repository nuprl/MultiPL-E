==========================
------- Program HumanEval_54_same_chars --------
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(define (same_chars s0 s1)
  (define (count-chars s)
    (for/fold ([counts (make-hash)])
               ([c (in-string s)])
      (hash-update counts c add1 0)))
  (define (count-chars-equal? c0 c1)
    (and (hash-equal? (equal? (hash-ref c0 _) (hash-ref c1 _))
                      (hash-keys c0)
                      (hash-keys c1))
         (hash-equal? (equal? (hash-ref c0 _) (hash-ref c1 _))
                      (hash-keys c1)
                      (hash-keys c0))))
  (count-chars-equal? (count-chars s0) (count-chars s1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-equal? (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t)
    (check-equal? (candidate "abcd" "dddddddabc") #t)
    (check-equal? (candidate "dddddddabc" "abcd") #t)
    (check-equal? (candidate "eabcd" "dddddddabc") #f)
    (check-equal? (candidate "abcd" "dddddddabcf") #f)
    (check-equal? (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f)
    (check-equal? (candidate "aabb" "aaccc") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp7uy7zi8y.rkt:22:43: _: wildcard not allowed as an expression
  in: _
  location...:
   /tmp/tmp7uy7zi8y.rkt:22:43

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (cond ((= n 0) '())
        ((= n 1) '())
        ((= n 2) '(2))
        (else
         (let ((primes (list 2)))
           (for ((i 3) (< i n))
             (for ((j (in-list primes)) (not (divides? j i)))
               (void))
             (if (not (divides? j i))
                 (set! primes (cons i primes))))
           primes))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp8pyy0hbq.rkt:24:23: for: bad sequence binding clause
  at: (< i n)
  in: (for ((i 3) (< i n)) (for ((j (in-list primes)) (not (divides? j i))) (void)) (if (not (divides? j i)) (set! primes (cons i primes))))
  location...:
   /tmp/tmp8pyy0hbq.rkt:24:23
  context...:
   /work/arjunguha-research-group/software/racket/collects/racket/private/for.rkt:1555:4: try-next

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotations s)
    (for/list ([i (in-range (string-length s))])
      (rotate-n s i)))
  (define (substring? s1 s2)
    (regexp-match? (regexp (string-append ".*" s2 ".*")) s1))
  (or (substring? a b)
      (any (lambda (s) (substring? a s)) (rotations b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmg1j48z1.rkt:29:6: any: use of 'any' outside the range of an arrow contract
  in: (any (lambda (s) (substring? a s)) (rotations b))
  location...:
   /tmp/tmpmg1j48z1.rkt:29:6

==========================
------- Program HumanEval_144_simplify --------
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f
(define (simplify x n)
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
  (define (lcm a b)
    (if (= b 0)
        0
        (/ (* a b) (gcd a b))))
  (define (multiply x n)
    (define (multiply-helper x n)
      (define (multiply-helper-helper x n)
        (let ([x-numerator (string->number (car (string-split x "/")))])
          (let ([x-denominator (string->number (cadr (string-split x "/")))])
            (let ([n-numerator (string->number (car (string-split n "/")))])
              (let ([n-denominator (string->number (cadr (string-split n "/")))])
                (let ([lcm (lcm x-denominator n-denominator)])
                  (let ([x-numerator-new (/ (* x-numerator lcm) x-denominator)])
                    (let ([n-numerator-new (/ (* n-numerator lcm) n-denominator)])
                      (list x-numerator-new n-numerator-new))))))))))
    (let ([x-numerator (car (multiply-helper x n))])
      (let ([n-numerator (cadr (multiply-helper x n))])
        (if (= (remainder x-numerator n-numerator) 0)
            #t
            #f)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-equal? (candidate "1/5" "5/1") #t)
    (check-equal? (candidate "1/6" "2/1") #f)
    (check-equal? (candidate "5/1" "3/1") #t)
    (check-equal? (candidate "7/10" "10/2") #f)
    (check-equal? (candidate "2/10" "50/10") #t)
    (check-equal? (candidate "7/2" "4/2") #t)
    (check-equal? (candidate "11/6" "6/1") #t)
    (check-equal? (candidate "2/3" "5/2") #f)
    (check-equal? (candidate "5/2" "3/5") #f)
    (check-equal? (candidate "2/4" "8/4") #t)
    (check-equal? (candidate "2/4" "4/2") #t)
    (check-equal? (candidate "1/5" "5/1") #t)
    (check-equal? (candidate "1/5" "1/5") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpp7cljcao.rkt:14:0: begin (possibly implicit): no expression after a sequence of internal definitions
  in: (begin (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (define (lcm a b) (if (= b 0) 0 (/ (* a b) (gcd a b)))) (define (multiply x n) (define (multiply-helper x n) (define (multiply-helper-helper x n) (let ((x-numerator (string->number (car (s...
  location...:
   /tmp/tmpp7cljcao.rkt:14:0
   /tmp/tmpp7cljcao.rkt:15:2
   /tmp/tmpp7cljcao.rkt:19:2
   /tmp/tmpp7cljcao.rkt:23:2

==========================
------- Program HumanEval_140_fix_spaces --------
#lang racket

;; Given a string text, replace all spaces in it with underscores, 
;; and if a string has more than 2 consecutive spaces, 
;; then replace all consecutive spaces with - 
;; >>> (fix_spaces " Example")
;; "Example"
;; >>> (fix_spaces " Example 1")
;; "Example_1"
;; >>> (fix_spaces " Example 2")
;; "_Example_2"
;; >>> (fix_spaces " Example 3")
;; "_Example-3"
(define (fix_spaces text)
  (define (replace-all text from to)
    (regexp-replace* #rx from text to))
  (define (replace-spaces text)
    (replace-all text #rx " " "_"))
  (define (replace-consecutive-spaces text)
    (replace-all text #rx " +" "-"))
  (replace-consecutive-spaces (replace-spaces text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fix_spaces))
    (check-equal? (candidate "Example") "Example")
    (check-equal? (candidate "Mudasir Hanif ") "Mudasir_Hanif_")
    (check-equal? (candidate "Yellow Yellow  Dirty  Fellow") "Yellow_Yellow__Dirty__Fellow")
    (check-equal? (candidate "Exa   mple") "Exa-mple")
    (check-equal? (candidate "   Exa 1 2 2 mple") "-Exa_1_2_2_mple")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp10598i8e.rkt:16:21: read-syntax: expected `"` or `#` after `#rx`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (shift-helper x shift)
    (if (= shift 0)
        (number->string x)
        (let* ([x-str (number->string x)]
               [x-len (string-length x-str)]
               [x-last (substring x-str (- x-len 1) x-len)]
               [x-rest (substring x-str 0 (- x-len 1))])
          (shift-helper (string->number (string-append x-last x-rest)) (- shift 1)))))
  (shift-helper x (modulo shift (number->string x |> string-length))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpvi2xtxj4.rkt:19:50: read-syntax: end-of-file following `|` in symbol
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

