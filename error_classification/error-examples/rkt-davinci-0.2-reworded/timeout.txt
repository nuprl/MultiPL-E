HumanEval_115_max_fill: 7
HumanEval_96_count_up_to: 57
HumanEval_69_search: 1
HumanEval_163_generate_integers: 33
HumanEval_104_unique_digits: 1
HumanEval_127_intersection: 13
HumanEval_78_hex_key: 5
HumanEval_155_even_odd_count: 8
HumanEval_160_do_algebra: 1
HumanEval_47_median: 3
HumanEval_116_sort_array: 79
HumanEval_10_make_palindrome: 3
HumanEval_41_car_race_collision: 2
HumanEval_84_solve: 2
HumanEval_102_choose_num: 115
HumanEval_109_move_one_ball: 2
HumanEval_33_sort_third: 4
HumanEval_147_get_max_triples: 1
HumanEval_31_is_prime: 3
HumanEval_154_cycpattern_check: 32
HumanEval_99_closest_integer: 1
HumanEval_156_int_to_mini_roman: 23
HumanEval_75_is_multiply_prime: 46
HumanEval_135_can_arrange: 8
HumanEval_46_fib4: 5
HumanEval_24_largest_divisor: 96
HumanEval_143_words_in_sentence: 4
HumanEval_138_is_equal_to_sum_even: 13
HumanEval_39_prime_fib: 9
HumanEval_148_bf: 2
HumanEval_129_minPath: 1
HumanEval_130_tri: 66
HumanEval_59_largest_prime_factor: 3
HumanEval_107_even_odd_palindrome: 4
HumanEval_94_skjkasdkd: 78
HumanEval_110_exchange: 1
HumanEval_82_prime_length: 42
HumanEval_2_truncate_number: 22
HumanEval_77_iscube: 2
HumanEval_29_filter_by_prefix: 200
HumanEval_65_circular_shift: 1
HumanEval_119_match_parens: 2
HumanEval_76_is_simple_power: 13
HumanEval_100_make_a_pile: 30
==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (max-fill-helper grid capacity)
    (define (max-fill-helper-inner grid capacity)
      (define (max-fill-helper-inner-inner grid capacity)
        (if (null? grid)
            0
            (+ (max-fill-helper-inner-inner (cdr grid) capacity)
               (if (null? (car grid))
                   0
                   (if (>= capacity (car grid))
                       (car grid)
                       capacity)))))
      (if (null? grid)
          0
          (+ (max-fill-helper-inner-inner (car grid) capacity)
             (max-fill-helper-inner (cdr grid) capacity))))
    (if (null? grid)
        0
        (+ (max-fill-helper-inner grid capacity)
           (max-fill-helper (map (lambda (row) (map (lambda (x) (- x capacity)) row)) grid) capacity))))
  (max-fill-helper grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (let loop ([grid grid] [capacity capacity] [count 0])
    (cond [(empty? grid) count]
          [else (loop (map (λ (row) (map (λ (x) (if (> x capacity) (- x capacity) 0)) row)) grid) capacity (+ count capacity))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (max-fill-helper grid capacity)
    (cond
      [(empty? grid) 0]
      [(empty? (first grid)) (max-fill-helper (rest grid) capacity)]
      [else
       (let* ([row (first grid)]
              [rest-grid (rest grid)]
              [first-well (first row)]
              [rest-row (rest row)]
              [num-of-fills (if (zero? first-well) 0 capacity)])
         (+ num-of-fills
            (max-fill-helper (cons (cons 0 rest-row) rest-grid) capacity)))]))
  (max-fill-helper grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (max_fill-helper grid capacity)
    (cond
      [(empty? grid) 0]
      [(empty? (first grid)) (max_fill-helper (rest grid) capacity)]
      [else
       (let ([row (first grid)]
             [rest (rest grid)])
         (cond
           [(empty? row) (max_fill-helper rest capacity)]
           [(= (first row) 1)
            (let ([rest-row (rest row)])
              (cond
                [(empty? rest-row) (max_fill-helper rest capacity)]
                [(= (first rest-row) 1)
                 (max_fill-helper (cons (cons 0 (rest row)) rest) capacity)]
                [else (max_fill-helper (cons (cons 0 row) rest) capacity)]))]
           [else (max_fill-helper (cons (cons 0 row) rest) capacity)]))]))
  (max_fill-helper grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (fill-row row)
    (define (fill-cell cell)
      (cond
        [(= cell 1)
         (set! capacity (- capacity 1))
         (set! cell 0)]
        [else
         (set! cell cell)]))
    (map fill-cell row))
  (define (fill-grid grid)
    (define (fill-row row)
      (cond
        [(> capacity 0)
         (set! capacity (fill-row row))]
        [else
         (set! capacity capacity)]))
    (map fill-row grid))
  (define (count-water grid)
    (define (count-row row)
      (define (count-cell cell)
        (cond
          [(= cell 1)
           (set! cell 1)]
          [else
           (set! cell 0)]))
      (map count-cell row))
    (map count-row grid))
  (define (sum-grid grid)
    (apply + (apply + grid)))
  (define (fill-grid-count grid capacity)
    (set! grid (fill-grid grid))
    (set! grid (count-water grid))
    (set! capacity (sum-grid grid)))
  (fill-grid-count grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (let ([grid (map (lambda (row) (map (lambda (x) (if (zero? x) 0 capacity)) row)) grid)])
    (let loop ([grid grid] [count 0])
      (if (null? grid)
          count
          (let ([new-grid (map (lambda (row) (map (lambda (x) (if (zero? x) 0 (- x 1))) row)) grid)])
            (loop (map (lambda (row) (map (lambda (x) (if (zero? x) 0 (- x 1))) row)) grid) (+ count 1)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (max-fill-helper grid capacity)
    (cond
      [(empty? grid) 0]
      [(empty? (first grid)) (max-fill-helper (rest grid) capacity)]
      [else
       (let*
           ([row (first grid)]
            [col (first row)]
            [rest-row (rest row)]
            [rest-grid (rest grid)]
            [rest-fill (max-fill-helper rest-grid capacity)])
         (cond
           [(= col 1)
            (+ 1
               (max-fill-helper (cons (cons 0 rest-row) rest-grid) capacity)
               rest-fill)]
           [else
            (max-fill-helper (cons (cons 0 rest-row) rest-grid) capacity)]))]))
  (max-fill-helper grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime?-iter n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime?-iter n (- i 1))]))
    (is_prime?-iter n (- n 1)))
  (define (count_up_to-iter n i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (count_up_to-iter n (+ i 1)))]
      [else (count_up_to-iter n (+ i 1))]))
  (count_up_to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (+ i 1)))))
    (is_prime_helper? n 2))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (if (= i n)
        '()
        (if (is_prime? i)
            (cons i (count_up_to_helper n (+ i 1)))
            (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper n (+ i 1)))))
    (is-prime-helper n 2))
  (define (count-up-to-helper n i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (count-up-to-helper n (+ i 1))))
          (else (count-up-to-helper n (+ i 1)))))
  (count-up-to-helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (+ i 1)))))
    (is_prime_helper? n 2))
  (define (count_up_to_helper n i)
    (cond ((= i n) (list))
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_divisible? a b)
      (= (remainder a b) 0))
    (define (is_prime? n d)
      (cond ((= d n) #t)
            ((is_divisible? n d) #f)
            (else (is_prime? n (+ d 1)))))
    (is_prime? n 2))
  (define (count_up_to n l)
    (cond ((= n 0) l)
          ((is_prime? n) (count_up_to (- n 1) (cons n l)))
          (else (count_up_to (- n 1) l))))
  (count_up_to n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i lst)
    (cond ((= i n) lst)
          ((is_prime? i) (count_up_to_helper n (+ i 1) (cons i lst)))
          (else (count_up_to_helper n (+ i 1) lst))))
  (reverse (count_up_to_helper n 2 '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime-iter n i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (is_prime-iter n (+ i 1)))))
    (is_prime-iter n 2))
  (define (count-iter n i)
    (cond ((= i n) '())
          ((is_prime i) (cons i (count-iter n (+ i 1))))
          (else (count-iter n (+ i 1)))))
  (count-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime-iter n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime-iter n (- i 1)))))
    (is_prime-iter n (- n 1)))
  (define (count-up-to-iter n i)
    (cond ((= i n) (list))
          ((is_prime i) (cons i (count-up-to-iter n (+ i 1))))
          (else (count-up-to-iter n (+ i 1)))))
  (count-up-to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (iter i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (iter (+ i 1)))]
      [else (iter (+ i 1))]))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (if (= i n)
        (list)
        (if (is_prime? i)
            (cons i (count_up_to_helper n (+ i 1)))
            (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime?-iter n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime?-iter n (- i 1)))))
    (is_prime?-iter n (- n 1)))
  (define (count_up_to-iter n i)
    (cond ((= i n) (list))
          ((is_prime? i) (cons i (count_up_to-iter n (+ i 1))))
          (else (count_up_to-iter n (+ i 1)))))
  (count_up_to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_divisible? a b)
      (= (remainder a b) 0))
    (define (iter i)
      (cond ((= i n) #t)
            ((is_divisible? n i) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is_prime i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to? n i)
    (cond ((= i n) '())
          ((is_prime i) (cons i (count_up_to? n (+ i 1))))
          (else (count_up_to? n (+ i 1)))))
  (count_up_to? n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (divisor? n x)
      (cond ((= x 1) #t)
            ((= (modulo n x) 0) #f)
            (else (divisor? n (- x 1)))))
    (divisor? n (- n 1)))
  (define (count_up_to_iter n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_iter n (+ i 1))))
          (else (count_up_to_iter n (+ i 1)))))
  (count_up_to_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime-iter n i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (is_prime-iter n (+ i 1)))))
    (is_prime-iter n 2))
  (define (count-up-to-iter n i)
    (cond ((= i n) '())
          ((is_prime i) (cons i (count-up-to-iter n (+ i 1))))
          (else (count-up-to-iter n (+ i 1)))))
  (count-up-to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-prime-helper? n divisor)
      (cond ((= n divisor) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is-prime-helper? n (+ divisor 1)))))
    (is-prime-helper? n 2))
  (define (count-up-to-helper n current-number)
    (cond ((= n current-number) '())
          ((is-prime? current-number) (cons current-number (count-up-to-helper n (+ current-number 1))))
          (else (count-up-to-helper n (+ current-number 1)))))
  (count-up-to-helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (+ i 1)))))
    (cond ((= n 1) #f)
          ((= n 2) #t)
          (else (is_prime_helper? n 2))))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (is_prime? n (+ i 1)))))
    (is_prime? n 2))
  (define (count_up_to n i)
    (if (= i n)
        (list)
        (if (is_prime? i)
            (cons i (count_up_to n (+ i 1)))
            (count_up_to n (+ i 1)))))
  (count_up_to n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (if (= i n)
        '()
        (if (is_prime? i)
            (cons i (count_up_to_helper n (+ i 1)))
            (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper n (- i 1)))))
    (is_prime_helper n (- n 1)))
  (define (count_up_to_helper n i)
    (cond ((= i n) (list))
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (if (= i n)
        '()
        (if (is_prime? i)
            (cons i (count_up_to_helper n (+ i 1)))
            (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime_helper? n (+ i 1))]))
    (is_prime_helper? n 2))
  (define (count_up_to_helper n i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (count_up_to_helper n (+ i 1)))]
      [else (count_up_to_helper n (+ i 1))]))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime_helper? n (+ i 1))]))
    (is_prime_helper? n 2))
  (define (count_up_to_helper n i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (count_up_to_helper n (+ i 1)))]
      [else (count_up_to_helper n (+ i 1))]))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (- n 1)))
  (define (count-up-to-helper n i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (count-up-to-helper n (+ i 1))))
          (else (count-up-to-helper n (+ i 1)))))
  (count-up-to-helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_divisible? n d)
      (= (remainder n d) 0))
    (define (next d)
      (if (= d n)
          #t
          (if (is_divisible? n d)
              #f
              (next (+ d 1)))))
    (next 2))
  (define (count_up_to_helper n l)
    (if (= n 0)
        l
        (if (is_prime n)
            (count_up_to_helper (- n 1) (cons n l))
            (count_up_to_helper (- n 1) l))))
  (count_up_to_helper n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper? n (- i 1))]))
    (is-prime-helper? n (- n 1)))
  (define (count-up-to-helper n i)
    (cond
      [(= i n) '()]
      [(is-prime? i) (cons i (count-up-to-helper n (+ i 1)))]
      [else (count-up-to-helper n (+ i 1))]))
  (count-up-to-helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (- i 1)))))
    (iter (- n 1)))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime-iter n i)
      (if (= n i)
          #t
          (if (= (remainder n i) 0)
              #f
              (is_prime-iter n (+ i 1)))))
    (is_prime-iter n 2))
  (define (count-up-to-iter n i)
    (if (= n i)
        (list)
        (if (is_prime i)
            (cons i (count-up-to-iter n (+ i 1)))
            (count-up-to-iter n (+ i 1)))))
  (count-up-to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i lst)
    (cond ((= i n) lst)
          ((is_prime? i) (iter (+ i 1) (cons i lst)))
          (else (iter (+ i 1) lst))))
  (reverse (iter 2 '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (iter i)
      (cond ((= i n) #t)
            ((is-divisible? n i) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (iter i)
      (cond ((= i n) #t)
            ((is-divisible? n i) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_divisible? a b)
      (= (remainder a b) 0))
    (define (iter i)
      (cond ((= i n) #t)
            ((is_divisible? n i) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (if (= i n)
        (list)
        (if (is_prime? i)
            (cons i (count_up_to_helper n (+ i 1)))
            (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (iter i)
      (cond ((= i n) #t)
            ((is-divisible? n i) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime-helper n divisor)
      (cond ((= n divisor) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is_prime-helper n (+ divisor 1)))))
    (is_prime-helper n 2))
  (define (count_up-helper n list)
    (cond ((= n 0) list)
          ((is_prime n) (count_up-helper (- n 1) (cons n list)))
          (else (count_up-helper (- n 1) list))))
  (count_up-helper n '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (if (= i n)
        (list)
        (if (is_prime? i)
            (cons i (count_up_to_helper n (+ i 1)))
            (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (is-prime-helper n 3))))
  (define (is-prime-helper n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is-prime-helper n (+ i 2)))))
  (define (count_up_to-helper n i lst)
    (cond ((= i n) lst)
          ((is-prime? i) (count_up_to-helper n (+ i 1) (cons i lst)))
          (else (count_up_to-helper n (+ i 1) lst))))
  (reverse (count_up_to-helper n 2 '())))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (+ i 1)))))
    (is_prime_helper? n 2))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime? n (- i 1))]))
    (is_prime? n (- n 1)))
  (define (count_up_to n i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (count_up_to n (+ i 1)))]
      [else (count_up_to n (+ i 1))]))
  (count_up_to n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime_helper? n (+ i 1))]))
    (if (= n 1)
        #f
        (is_prime_helper? n 2)))
  (define (count_up_to_helper n i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (count_up_to_helper n (+ i 1)))]
      [else (count_up_to_helper n (+ i 1))]))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (- i 1)))))
    (is_prime_helper? n (- n 1)))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (iter x)
      (cond ((= x n) #t)
            ((is-divisible? n x) #f)
            (else (iter (+ x 1)))))
    (iter 2))
  (define (iter x)
    (cond ((= x n) '())
          ((is-prime? x) (cons x (iter (+ x 1))))
          (else (iter (+ x 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime_helper? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper? n (+ i 1)))))
    (is_prime_helper? n 2))
  (define (count_up_to_helper n i)
    (cond ((= i n) '())
          ((is_prime? i) (cons i (count_up_to_helper n (+ i 1))))
          (else (count_up_to_helper n (+ i 1)))))
  (count_up_to_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime n)
    (define (is_prime-iter n divisor)
      (cond ((= n 1) #f)
            ((= n 2) #t)
            ((= (remainder n divisor) 0) #f)
            (else (is_prime-iter n (+ divisor 1)))))
    (is_prime-iter n 2))
  (define (count-up-to-iter n current-number)
    (cond ((= n 0) '())
          ((= n 1) '())
          ((is_prime current-number) (cons current-number (count-up-to-iter (- n 1) (+ current-number 1))))
          (else (count-up-to-iter n (+ current-number 1)))))
  (count-up-to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime? n i)
      (if (= i 1)
          #t
          (if (= (modulo n i) 0)
              #f
              (is_prime? n (- i 1)))))
    (is_prime? n (- n 1)))
  (define (count_up_to n i)
    (if (= i n)
        (list)
        (if (is_prime? i)
            (cons i (count_up_to n (+ i 1)))
            (count_up_to n (+ i 1)))))
  (count_up_to n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is_prime? n)
    (define (is_prime?-iter n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime?-iter n (- i 1))]))
    (is_prime?-iter n (- n 1)))
  (define (count_up_to-iter n i)
    (cond
      [(= i n) '()]
      [(is_prime? i) (cons i (count_up_to-iter n (+ i 1)))]
      [else (count_up_to-iter n (+ i 1))]))
  (count_up_to-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-helper? n (- i 1)))))
    (is-prime-helper? n (- n 1)))
  (define (count-up-to-helper n i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (count-up-to-helper n (+ i 1))))
          (else (count-up-to-helper n (+ i 1)))))
  (count-up-to-helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (define (is-prime? n)
    (define (is-divisible? a b)
      (= (remainder a b) 0))
    (define (iter i)
      (cond ((= i n) #t)
            ((is-divisible? n i) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i n) '())
          ((is-prime? i) (cons i (iter (+ i 1))))
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_69_search --------
#lang racket

;; You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
;; zero, and has a frequency greater than or equal to the value of the integer itself. 
;; The frequency of an integer is the number of times it appears in the list.
;; If no such a value exist, return -1.
;; Examples:
;; >>> (search (list 4 1 2 2 3 1))
;; 2
;; >>> (search (list 1 2 2 3 3 3 4 4 4))
;; 3
;; >>> (search (list 5 5 4 4 4))
;; -1
(define (search lst)
  (define (count-occurences lst n)
    (cond
      [(empty? lst) 0]
      [(= (first lst) n) (+ 1 (count-occurences (rest lst) n))]
      [else (count-occurences (rest lst) n)]))
  (define (search-helper lst n)
    (cond
      [(empty? lst) -1]
      [(and (> n 0) (>= (count-occurences lst n) n)) n]
      [else (search-helper lst (- n 1))]))
  (search-helper lst (length lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate search))
    (check-equal? (candidate (list 5 5 5 5 1)) 1)
    (check-equal? (candidate (list 4 1 4 1 4 4)) 4)
    (check-equal? (candidate (list 3 3)) -1)
    (check-equal? (candidate (list 8 8 8 8 8 8 8 8)) 8)
    (check-equal? (candidate (list 2 3 3 2 2)) 2)
    (check-equal? (candidate (list 2 7 8 8 4 8 7 3 9 6 5 10 4 3 6 7 1 7 4 10 8 1)) 1)
    (check-equal? (candidate (list 3 2 8 2)) 2)
    (check-equal? (candidate (list 6 7 1 8 8 10 5 8 5 3 10)) 1)
    (check-equal? (candidate (list 8 8 3 6 5 6 4)) -1)
    (check-equal? (candidate (list 6 9 6 7 1 4 7 1 8 8 9 8 10 10 8 4 10 4 10 1 2 9 5 7 9)) 1)
    (check-equal? (candidate (list 1 9 10 1 3)) 1)
    (check-equal? (candidate (list 6 9 7 5 8 7 5 3 7 5 10 10 3 6 10 2 8 6 5 4 9 5 3 10)) 5)
    (check-equal? (candidate (list 1)) 1)
    (check-equal? (candidate (list 8 8 10 6 4 3 5 8 2 4 2 8 4 6 10 4 2 1 10 2 1 1 5)) 4)
    (check-equal? (candidate (list 2 10 4 8 2 10 5 1 2 9 5 5 6 3 8 6 4 10)) 2)
    (check-equal? (candidate (list 1 6 10 1 6 9 10 8 6 8 7 3)) 1)
    (check-equal? (candidate (list 9 2 4 1 5 1 5 2 5 7 7 7 3 10 1 5 4 2 8 4 1 9 10 7 10 2 8 10 9 4)) 4)
    (check-equal? (candidate (list 2 6 4 2 8 7 5 6 4 10 4 6 3 7 8 8 3 1 4 2 2 10 7)) 4)
    (check-equal? (candidate (list 9 8 6 10 2 6 10 2 7 8 10 3 8 2 6 2 3 1)) 2)
    (check-equal? (candidate (list 5 5 3 9 5 6 3 2 8 5 6 10 10 6 8 4 10 7 7 10 8)) -1)
    (check-equal? (candidate (list 10)) -1)
    (check-equal? (candidate (list 9 7 7 2 4 7 2 10 9 7 5 7 2)) 2)
    (check-equal? (candidate (list 5 4 10 2 1 1 10 3 6 1 8)) 1)
    (check-equal? (candidate (list 7 9 9 9 3 4 1 5 9 1 2 1 1 10 7 5 6 7 6 7 7 6)) 1)
    (check-equal? (candidate (list 3 10 10 9 2)) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (and (even? a) (even? b))
      (if (< a b)
          (cons a (generate_integers (+ a 2) b))
          (cons b (generate_integers (+ b 2) a)))
      (if (and (odd? a) (odd? b))
          (if (< a b)
              (generate_integers (+ a 1) b)
              (generate_integers (+ b 1) a))
          (if (even? a)
              (generate_integers (+ a 1) b)
              (generate_integers (+ b 1) a)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (cond
    [(> a b) (generate_integers b a)]
    [(= a b) (if (even? a) (list a) (list))]
    [else (append (generate_integers a (+ a 1)) (list a))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (< a b)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))
      (if (even? b)
          (cons b (generate_integers a (+ b 1)))
          (generate_integers a (+ b 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (cond
    [(= a b) (list a)]
    [(< a b) (append (generate_integers a (+ a 1)) (list b))]
    [(> a b) (append (generate_integers a (- a 1)) (list b))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (and (integer? a) (integer? b) (> a 0) (> b 0))
      (if (< a b)
          (if (even? a)
              (cons a (generate_integers (+ a 1) b))
              (generate_integers (+ a 1) b))
          (if (even? b)
              (cons b (generate_integers a (+ b 1)))
              (generate_integers a (+ b 1))))
      (list)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (define (generate-even-integers a b)
    (if (even? a)
        (cons a (generate-even-integers (+ a 1) b))
        (generate-even-integers (+ a 1) b)))
  (if (> a b)
      (reverse (generate-even-integers b a))
      (generate-even-integers a b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (cond
    [(> a b)
     (generate_integers b a)]
    [(= a b)
     (if (even? a)
         (list a)
         (list))]
    [else
     (append (generate_integers a (+ a 1))
             (generate_integers (+ a 1) b))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (and (even? a) (even? b))
      (if (< a b)
          (cons a (generate_integers (+ a 2) b))
          (cons b (generate_integers a (+ b 2))))
      (if (and (even? a) (odd? b))
          (cons a (generate_integers (+ a 2) b))
          (if (and (odd? a) (even? b))
              (cons b (generate_integers a (+ b 2)))
              (if (and (odd? a) (odd? b))
                  (generate_integers (+ a 1) (+ b 1))
                  (list)))))
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (and (even? a) (even? b))
      (if (< a b)
          (cons a (generate_integers (+ a 2) b))
          (cons b (generate_integers (+ b 2) a)))
      (if (and (even? a) (odd? b))
          (if (< a b)
              (cons a (generate_integers (+ a 2) b))
              (cons b (generate_integers (+ b 2) a)))
          (if (and (odd? a) (even? b))
              (if (< a b)
                  (cons a (generate_integers (+ a 2) b))
                  (cons b (generate_integers (+ b 2) a)))
              (if (< a b)
                  (cons a (generate_integers (+ a 2) b))
                  (cons b (generate_integers (+ b 2) a)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (and (even? a) (even? b))
      (if (< a b)
          (cons a (generate_integers (+ a 2) b))
          (cons b (generate_integers a (+ b 2))))
      (if (and (odd? a) (odd? b))
          (if (< a b)
              (generate_integers (+ a 1) b)
              (generate_integers a (+ b 1)))
          (if (even? a)
              (generate_integers (+ a 1) b)
              (generate_integers a (+ b 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (cond
    [(< a b) (generate_integers a (+ b 1))]
    [(> a b) (generate_integers (+ a 1) b)]
    [(= a b) (list a)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (cond
    [(> a b) (generate_integers b a)]
    [(= a b) (if (even? a) (list a) (list))]
    [else (append (generate_integers a (+ a 1)) (list a))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (if (> a b)
      (generate_integers b a)
      (if (even? a)
          (cons a (generate_integers (+ a 1) b))
          (generate_integers (+ a 1) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_163_generate_integers --------
#lang racket

;; Given two positive integers a and b, return the even digits between a
;; and b, in ascending order.
;; For example:
;; >>> (generate_integers 2 8)
;; (list 2 4 6 8)
;; >>> (generate_integers 8 2)
;; (list 2 4 6 8)
;; >>> (generate_integers 10 14)
;; (list )
(define (generate_integers a b)
  (cond
    [(even? a) (cons a (generate_integers (+ a 2) b))]
    [(even? b) (cons b (generate_integers a (- b 2)))]
    [else '()]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate generate_integers))
    (check-equal? (candidate 2 10) (list 2 4 6 8))
    (check-equal? (candidate 10 2) (list 2 4 6 8))
    (check-equal? (candidate 132 2) (list 2 4 6 8))
    (check-equal? (candidate 17 89) (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_104_unique_digits --------
#lang racket

;; Given a list of positive integers x. return a sorted list of all 
;; elements that hasn't any even digit.
;; Note: Returned list should be sorted in increasing order.
;; For example:
;; >>> (unique_digits (list 15 33 1422 1))
;; (list 1 15 33)
;; >>> (unique_digits (list 152 323 1422 10))
;; (list )
(define (unique_digits x)
  (define (even? n)
    (even? n))
  (define (unique-digits-helper x)
    (cond
      [(empty? x) empty]
      [(even? (first x)) (unique-digits-helper (rest x))]
      [else (cons (first x) (unique-digits-helper (rest x)))]))
  (sort < (unique-digits-helper x)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate unique_digits))
    (check-equal? (candidate (list 15 33 1422 1)) (list 1 15 33))
    (check-equal? (candidate (list 152 323 1422 10)) (list ))
    (check-equal? (candidate (list 12345 2033 111 151)) (list 111 151))
    (check-equal? (candidate (list 135 103 31)) (list 31 135))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (define (interval-intersection-helper interval1 interval2)
        (if (and (>= (car interval1) (car interval2))
                 (<= (car interval1) (cadr interval2)))
            (list (car interval1) (cadr interval2))
            (if (and (>= (car interval2) (car interval1))
                     (<= (car interval2) (cadr interval1)))
                (list (car interval2) (cadr interval1))
                (list 0 0))))
      (interval-intersection-helper interval1 interval2))
    (define (is-prime? n)
      (define (is-prime-helper n i)
        (if (= i n)
            #t
            (if (= (modulo n i) 0)
                #f
                (is-prime-helper n (+ i 1)))))
      (is-prime-helper n 2))
    (define (interval-intersection-length interval)
      (interval-length (interval-intersection interval1 interval2)))
    (if (= (interval-intersection-length interval1) 0)
        "NO"
        (if (is-prime? (interval-intersection-length interval1))
            "YES"
            "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-length-helper interval1 interval2)
      (cond
        [(empty? interval1) (list 0)]
        [(empty? interval2) (list 0)]
        [(< (first interval1) (first interval2)) (intersection-length-helper (rest interval1) interval2)]
        [(> (first interval1) (first interval2)) (intersection-length-helper interval1 (rest interval2))]
        [else
         (let* ([intersection-start (first interval1)]
                [intersection-end (min (second interval1) (second interval2))])
           (list (- intersection-end intersection-start)))]))
    (first (intersection-length-helper interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper n divisor)
      (cond
        [(= divisor 1) #t]
        [(= (modulo n divisor) 0) #f]
        [else (is-prime-helper n (- divisor 1))]))
    (is-prime-helper n (floor (/ n 2))))
  (cond
    [(< (first interval1) (first interval2)) (intersection interval1 interval2)]
    [(> (first interval1) (first interval2)) (intersection interval2 interval1)]
    [else
     (cond
       [(< (second interval1) (second interval2)) (intersection interval1 interval2)]
       [(> (second interval1) (second interval2)) (intersection interval2 interval1)]
       [else
        (cond
          [(is-prime? (intersection-length interval1 interval2)) "YES"]
          [else "NO"])])]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (interval-intersection interval1 interval2)
    (let* ([start1 (car interval1)]
           [end1 (cadr interval1)]
           [start2 (car interval2)]
           [end2 (cadr interval2)])
      (cond
        [(and (<= start1 start2) (<= start2 end1))
         (list start2 end1)]
        [(and (<= start2 start1) (<= start1 end2))
         (list start1 end2)]
        [else
         #f])))
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n)
         #t]
        [(= (modulo n i) 0)
         #f]
        [else
         (iter (+ i 1))]))
    (iter 2))
  (define (interval-length interval)
    (- (cadr interval) (car interval)))
  (let ([intersection (interval-intersection interval1 interval2)])
    (cond
      [(not intersection)
       "NO"]
      [(is-prime? (interval-length intersection))
       "YES"]
      [else
       "NO"])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (cond
      [(null? interval1) '()]
      [(null? interval2) '()]
      [(< (car interval1) (car interval2)) (intersection-helper (cdr interval1) interval2)]
      [(> (car interval1) (car interval2)) (intersection-helper interval1 (cdr interval2))]
      [else (cons (car interval1) (intersection-helper (cdr interval1) (cdr interval2)))]))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (+ i 1))]))
    (is-prime-helper n 2))
  (define (length lst)
    (cond
      [(null? lst) 0]
      [else (+ 1 (length (cdr lst)))]))
  (cond
    [(= (length (intersection-helper interval1 interval2)) 0) "NO"]
    [(is-prime? (length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-start interval1 interval2)
    (if (< (car interval1) (car interval2))
        (car interval2)
        (car interval1)))
  (define (intersection-end interval1 interval2)
    (if (> (cadr interval1) (cadr interval2))
        (cadr interval2)
        (cadr interval1)))
  (define (intersection-length interval1 interval2)
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i n)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (+ i 1)))))
    (is-prime-helper n 2))
  (define (intersection-length-is-prime? interval1 interval2)
    (is-prime? (intersection-length interval1 interval2)))
  (define (intersect? interval1 interval2)
    (and (<= (intersection-start interval1 interval2)
             (intersection-end interval1 interval2))
         (<= (intersection-start interval1 interval2)
             (intersection-end interval1 interval2))))
  (if (intersect? interval1 interval2)
      (if (intersection-length-is-prime? interval1 interval2)
          "YES"
          "NO")
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (if (and (>= (car interval1) (car interval2))
               (<= (car interval1) (cadr interval2)))
          (list (car interval1) (cadr interval2))
          (if (and (>= (car interval2) (car interval1))
                   (<= (car interval2) (cadr interval1)))
              (list (car interval2) (cadr interval1))
              (list 0 0))))
    (intersection-helper-helper interval1 interval2))
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (if (= i n)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper n (+ i 1)))))
    (is-prime-helper n 2))
  (define (intersection-length interval)
    (- (cadr interval) (car interval)))
  (define (intersection-result interval)
    (if (= (intersection-length interval) 0)
        "NO"
        (if (is-prime? (intersection-length interval))
            "YES"
            "NO")))
  (intersection-result (intersection-helper interval1 interval2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (list (max (car interval1) (car interval2))
            (min (cadr interval1) (cadr interval2))))
    (define (is-prime? n)
      (define (is-prime-helper n divisor)
        (cond ((= divisor 1) #t)
              ((= (modulo n divisor) 0) #f)
              (else (is-prime-helper n (- divisor 1)))))
      (is-prime-helper n (- n 1)))
    (define (interval-intersection-length interval)
      (interval-length (interval-intersection interval1 interval2)))
    (cond ((< (car interval1) (car interval2))
           (intersection-helper interval2 interval1))
          ((< (car interval2) (car interval1))
           (intersection-helper interval1 interval2))
          ((< (cadr interval1) (cadr interval2))
           (intersection-helper interval1 interval2))
          ((< (cadr interval2) (cadr interval1))
           (intersection-helper interval2 interval1))
          ((< (interval-intersection-length interval1) 0)
           "NO")
          ((is-prime? (interval-intersection-length interval1))
           "YES")
          (else "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (max (car interval1) (car interval2)))
    (define (intersection-end interval1 interval2)
      (min (cadr interval1) (cadr interval2)))
    (define (intersection-length interval)
      (- (cadr interval) (car interval)))
    (define (is-prime? n)
      (define (is-prime-helper n i)
        (cond
          [(= i n) #t]
          [(= (modulo n i) 0) #f]
          [else (is-prime-helper n (+ i 1))]))
      (is-prime-helper n 2))
    (define (intersection-interval interval1 interval2)
      (list (intersection-start interval1 interval2)
            (intersection-end interval1 interval2)))
    (define (intersection-interval-length interval)
      (intersection-length (intersection-interval interval1 interval2)))
    (cond
      [(< (intersection-start interval1 interval2)
          (intersection-end interval1 interval2))
       (is-prime? (intersection-interval-length interval1))]
      [else #f]))
  (cond
    [(intersection-length interval1 interval2) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (interval-length interval)
      (- (cadr interval) (car interval)))
    (define (interval-intersection interval1 interval2)
      (list (max (car interval1) (car interval2))
            (min (cadr interval1) (cadr interval2))))
    (define (is-prime? n)
      (define (helper n i)
        (cond ((= i n) #t)
              ((= (modulo n i) 0) #f)
              (else (helper n (+ i 1)))))
      (helper n 2))
    (define (intersection-length interval)
      (interval-length (interval-intersection interval1 interval2)))
    (cond ((< (intersection-length interval1) 0) "NO")
          ((is-prime? (intersection-length interval1)) "YES")
          (else "NO")))
  (intersection-helper interval1 interval2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersect interval1 interval2)
    (let* ([start1 (car interval1)]
           [end1 (cadr interval1)]
           [start2 (car interval2)]
           [end2 (cadr interval2)])
      (if (and (<= start1 end2) (<= start2 end1))
          (list (max start1 start2) (min end1 end2))
          #f)))
  (define (is-prime? n)
    (let loop ([i 2])
      (if (= i n)
          #t
          (if (zero? (modulo n i))
              #f
              (loop (+ i 1))))))
  (define (length-interval interval)
    (if interval
        (- (cadr interval) (car interval))
        0))
  (let ([interval (intersect interval1 interval2)])
    (if interval
        (if (is-prime? (length-interval interval))
            "YES"
            "NO")
        "NO")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-length interval1 interval2)
    (define (intersection-start interval1 interval2)
      (if (< (car interval1) (car interval2))
          (car interval2)
          (car interval1)))
    (define (intersection-end interval1 interval2)
      (if (> (cadr interval1) (cadr interval2))
          (cadr interval2)
          (cadr interval1)))
    (- (intersection-end interval1 interval2)
       (intersection-start interval1 interval2)))
  (define (is-prime? n)
    (define (is-prime-helper? n i)
      (if (= i n)
          #t
          (if (= (modulo n i) 0)
              #f
              (is-prime-helper? n (+ i 1)))))
    (is-prime-helper? n 2))
  (define (intersection-exists? interval1 interval2)
    (if (< (car interval1) (car interval2))
        (if (< (cadr interval1) (car interval2))
            #f
            #t)
        (if (< (cadr interval2) (car interval1))
            #f
            #t)))
  (if (intersection-exists? interval1 interval2)
      (if (is-prime? (intersection-length interval1 interval2))
          "YES"
          "NO")
      "NO"))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(> (car interval1) (car interval2)) (intersection-helper-helper interval2 interval1)]
        [(> (cadr interval1) (car interval2)) (list (car interval2) (cadr interval1))]
        [else (list (car interval2) (car interval2))]))
    (define (is-prime? n)
      (define (is-prime-helper n i)
        (cond
          [(= i n) #t]
          [(= (modulo n i) 0) #f]
          [else (is-prime-helper n (+ i 1))]))
      (is-prime-helper n 2))
    (define (length-of-interval interval)
      (- (cadr interval) (car interval)))
    (cond
      [(< (car interval1) (car interval2)) (intersection-helper interval2 interval1)]
      [(< (cadr interval1) (car interval2)) #f]
      [else (is-prime? (length-of-interval (intersection-helper-helper interval1 interval2)))]))
  (cond
    [(intersection-helper interval1 interval2) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_127_intersection --------
#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; >>> (intersection (list 1 2) (list 2 3))
;; "NO"
;; >>> (intersection (list -1 1) (list 0 4))
;; "NO"
;; >>> (intersection (list -3 -1) (list -5 5))
;; "YES"
(define (intersection interval1 interval2)
  (define (intersection-helper interval1 interval2)
    (define (intersection-helper-helper interval1 interval2)
      (cond
        [(and (<= (car interval1) (car interval2)) (<= (car interval2) (cadr interval1)))
         (list (car interval2) (cadr interval1))]
        [(and (<= (car interval2) (car interval1)) (<= (car interval1) (cadr interval2)))
         (list (car interval1) (cadr interval2))]
        [else #f]))
    (intersection-helper-helper interval1 interval2)
    (intersection-helper-helper interval2 interval1))
  (define (prime? n)
    (define (prime-helper n div)
      (cond
        [(= div n) #t]
        [(= (modulo n div) 0) #f]
        [else (prime-helper n (+ div 1))]))
    (prime-helper n 2))
  (define (intersection-length interval)
    (- (cadr interval) (car interval)))
  (cond
    [(not (intersection-helper interval1 interval2)) "NO"]
    [(prime? (intersection-length (intersection-helper interval1 interval2))) "YES"]
    [else "NO"]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate (list 1 2) (list 2 3)) "NO")
    (check-equal? (candidate (list -1 1) (list 0 4)) "NO")
    (check-equal? (candidate (list -3 -1) (list -5 5)) "YES")
    (check-equal? (candidate (list -2 2) (list -4 0)) "YES")
    (check-equal? (candidate (list -11 2) (list -1 -1)) "NO")
    (check-equal? (candidate (list 1 2) (list 3 5)) "NO")
    (check-equal? (candidate (list 1 2) (list 1 2)) "NO")
    (check-equal? (candidate (list -2 -2) (list -3 -2)) "NO")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (hex-to-dec n)
    (cond ((string=? n "A") 10)
          ((string=? n "B") 11)
          ((string=? n "C") 12)
          ((string=? n "D") 13)
          ((string=? n "E") 14)
          ((string=? n "F") 15)
          (else (string->number n))))
  (define (iter num count)
    (cond ((string=? num "") count)
          ((is-prime? (hex-to-dec (substring num 0 1))) (iter (substring num 1) (+ count 1)))
          (else (iter (substring num 1) count))))
  (iter num 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (hex-to-decimal c)
    (cond
      [(char=? c #\0) 0]
      [(char=? c #\1) 1]
      [(char=? c #\2) 2]
      [(char=? c #\3) 3]
      [(char=? c #\4) 4]
      [(char=? c #\5) 5]
      [(char=? c #\6) 6]
      [(char=? c #\7) 7]
      [(char=? c #\8) 8]
      [(char=? c #\9) 9]
      [(char=? c #\A) 10]
      [(char=? c #\B) 11]
      [(char=? c #\C) 12]
      [(char=? c #\D) 13]
      [(char=? c #\E) 14]
      [(char=? c #\F) 15]))
  (define (iter n i)
    (cond
      [(empty? n) i]
      [(is-prime? (hex-to-decimal (first n))) (iter (rest n) (+ i 1))]
      [else (iter (rest n) i)]))
  (iter (string->list num) 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (is-hex? c)
    (or (char-numeric? c)
        (char=? c #\A)
        (char=? c #\B)
        (char=? c #\C)
        (char=? c #\D)
        (char=? c #\E)
        (char=? c #\F)))
  (define (hex-to-dec c)
    (cond ((char-numeric? c) (- (char->integer c) (char->integer #\0)))
          ((char=? c #\A) 10)
          ((char=? c #\B) 11)
          ((char=? c #\C) 12)
          ((char=? c #\D) 13)
          ((char=? c #\E) 14)
          ((char=? c #\F) 15)))
  (define (iter str i)
    (cond ((= i (string-length str)) 0)
          ((and (is-hex? (string-ref str i))
                (is-prime? (hex-to-dec (string-ref str i))))
           (+ 1 (iter str (+ i 1))))
          (else (iter str (+ i 1)))))
  (iter num 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (hex-to-dec n)
    (cond ((string=? n "A") 10)
          ((string=? n "B") 11)
          ((string=? n "C") 12)
          ((string=? n "D") 13)
          ((string=? n "E") 14)
          ((string=? n "F") 15)
          (else (string->number n))))
  (define (iter n count)
    (cond ((string=? n "") count)
          ((is-prime? (hex-to-dec (substring n 0 1))) (iter (substring n 1) (+ count 1)))
          (else (iter (substring n 1) count))))
  (iter num 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_78_hex_key --------
#lang racket

;; You have been tasked to write a function that receives 
;; a hexadecimal number as a string and counts the number of hexadecimal 
;; digits that are primes (prime number, or a prime, is a natural number 
;; greater than 1 that is not a product of two smaller natural numbers).
;; Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
;; Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
;; So you have to determine a number of the following digits: 2, 3, 5, 7, 
;; B (=decimal 11), D (=decimal 13).
;; Note: you may assume the input is always correct or empty string, 
;; and symbols A,B,C,D,E,F are always uppercase.
;; Examples:
;; >>> (hex_key "AB")
;; 1
;; >>> (hex_key "1077E")
;; 2
;; >>> (hex_key "ABED1A33")
;; 4
;; >>> (hex_key "123456789ABCDEF0")
;; 6
;; >>> (hex_key "2020")
;; 2
(define (hex_key num)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (hex-to-dec n)
    (cond ((string=? n "A") 10)
          ((string=? n "B") 11)
          ((string=? n "C") 12)
          ((string=? n "D") 13)
          ((string=? n "E") 14)
          ((string=? n "F") 15)
          (else (string->number n))))
  (define (iter num count)
    (cond ((string=? num "") count)
          ((is-prime (hex-to-dec (substring num 0 1)))
           (iter (substring num 1) (+ count 1)))
          (else (iter (substring num 1) count))))
  (iter num 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate hex_key))
    (check-equal? (candidate "AB") 1)
    (check-equal? (candidate "1077E") 2)
    (check-equal? (candidate "ABED1A33") 4)
    (check-equal? (candidate "2020") 2)
    (check-equal? (candidate "123456789ABCDEF0") 6)
    (check-equal? (candidate "112233445566778899AABBCCDDEEFF00") 12)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (even? n))
  (define (odd? n)
    (odd? n))
  (define (count-even-odd num)
    (cond
      [(zero? num) (list 0 0)]
      [(even? num) (list (+ 1 (list-ref (count-even-odd (quotient num 10)) 0)) (list-ref (count-even-odd (quotient num 10)) 1))]
      [(odd? num) (list (list-ref (count-even-odd (quotient num 10)) 0) (+ 1 (list-ref (count-even-odd (quotient num 10)) 1)))]))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (even? n))
  (define (odd? n)
    (odd? n))
  (define (count-even-odd num)
    (cond
      [(zero? num) (list 0 0)]
      [(even? num) (list (+ 1 (cadr (count-even-odd (quotient num 10)))) (cadr (count-even-odd (quotient num 10))))]
      [(odd? num) (list (cadr (count-even-odd (quotient num 10))) (+ 1 (cadr (count-even-odd (quotient num 10)))))]))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (even? (quotient n 10)))
  (define (odd? n)
    (odd? (quotient n 10)))
  (define (count-even-odd n)
    (cond ((= n 0) (list 0 0))
          ((even? n) (cons (car (count-even-odd (quotient n 10))) (cons 1 (cdr (count-even-odd (quotient n 10))))))
          ((odd? n) (cons (car (count-even-odd (quotient n 10))) (cons 0 (cdr (count-even-odd (quotient n 10))))))
          (else (list 0 0))))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (even? (modulo n 2)))
  (define (odd? n)
    (odd? (modulo n 2)))
  (define (count-even-odd num)
    (cond ((zero? num) (list 0 0))
          ((even? num) (let ((counts (count-even-odd (quotient num 10))))
                         (list (+ 1 (car counts)) (cadr counts))))
          ((odd? num) (let ((counts (count-even-odd (quotient num 10))))
                        (list (car counts) (+ 1 (cadr counts)))))))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (cond
      [(= n 0) #t]
      [(= n 1) #f]
      [else (even? (- n 2))]))
  (define (even_odd_count_iter num even odd)
    (cond
      [(= num 0) (list even odd)]
      [(even? (remainder num 10)) (even_odd_count_iter (quotient num 10) (+ even 1) odd)]
      [else (even_odd_count_iter (quotient num 10) even (+ odd 1))]))
  (even_odd_count_iter num 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? num)
    (even? num))
  (define (odd? num)
    (odd? num))
  (define (count-even-odd num)
    (cond ((= num 0) (list 0 0))
          ((even? num) (cons (car (count-even-odd (quotient num 10))) (cdr (count-even-odd (quotient num 10)))))
          ((odd? num) (cons (cdr (count-even-odd (quotient num 10))) (car (count-even-odd (quotient num 10)))))))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (even? n))
  (define (odd? n)
    (odd? n))
  (define (count-even-odd num)
    (cond [(zero? num) (list 0 0)]
          [(even? num) (list (add1 (first (count-even-odd (quotient num 10)))) (second (count-even-odd (quotient num 10))))]
          [(odd? num) (list (first (count-even-odd (quotient num 10))) (add1 (second (count-even-odd (quotient num 10)))))]))
  (count-even-odd num))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_155_even_odd_count --------
#lang racket

;; Given an integer. return a list that has the number of even and odd digits respectively.
;; Example:
;; >>> (even_odd_count -12)
;; (list 1 1)
;; >>> (even_odd_count 123)
;; (list 1 2)
(define (even_odd_count num)
  (define (even? n)
    (even? n))
  (define (odd? n)
    (odd? n))
  (define (even-odd-count-helper n even-count odd-count)
    (cond
      [(zero? n) (list even-count odd-count)]
      [(even? (remainder n 10)) (even-odd-count-helper (quotient n 10) (+ even-count 1) odd-count)]
      [else (even-odd-count-helper (quotient n 10) even-count (+ odd-count 1))]))
  (even-odd-count-helper num 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_count))
    (check-equal? (candidate 7) (list 0 1))
    (check-equal? (candidate -78) (list 1 1))
    (check-equal? (candidate 3452) (list 2 2))
    (check-equal? (candidate 346211) (list 3 3))
    (check-equal? (candidate -345821) (list 3 3))
    (check-equal? (candidate -2) (list 1 0))
    (check-equal? (candidate -45347) (list 2 3))
    (check-equal? (candidate 0) (list 1 0))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (eval-op op1 op2 op)
    (cond ((eq? op '+) (+ op1 op2))
          ((eq? op '-) (- op1 op2))
          ((eq? op '*) (* op1 op2))
          ((eq? op '//) (quotient op1 op2))
          ((eq? op '**) (expt op1 op2))))
  (define (eval-ops ops ops-remaining)
    (if (null? ops-remaining)
        (car ops)
        (eval-ops (cons (eval-op (car ops) (car ops-remaining) (car operator)) (cdr ops-remaining)) (cdr operator))))
  (eval-ops (cdr operand) (cdr operator)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (median-helper l)
    (cond
      [(empty? l) (error "empty list")]
      [(empty? (rest l)) (first l)]
      [(empty? (rest (rest l))) (/ (+ (first l) (first (rest l))) 2)]
      [else
       (median-helper (append (rest l) (list (first l))))]))
  (median-helper (sort l <)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (median-helper l)
    (cond
      [(empty? l) (error "empty list")]
      [(empty? (rest l)) (first l)]
      [(= (length l) 2) (/ (+ (first l) (second l)) 2)]
      [else
       (let* ([mid (quotient (length l) 2)]
              [left (take l mid)]
              [right (drop l mid)])
         (if (< (first right) (first left))
             (median-helper (append right left))
             (median-helper (append left right))))]))
  (median-helper (sort l <)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_47_median --------
#lang racket

;; Return median of elements in the list l.
;; >>> (median (list 3 1 2 4 5))
;; 3
;; >>> (median (list -10 4 6 1000 10 20))
;; 15.0
(define (median l)
  (define (median-helper l)
    (cond
      [(empty? l) 0]
      [(= (length l) 1) (first l)]
      [(= (length l) 2) (/ (+ (first l) (second l)) 2)]
      [else
       (let ([sorted (sort l <)])
         (median-helper (list (first sorted) (second sorted) (last sorted))))]))
  (median-helper l))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate median))
    (check-equal? (candidate (list 3 1 2 4 5)) 3)
    (check-equal? (candidate (list -10 4 6 1000 10 20)) 8.0)
    (check-equal? (candidate (list 5)) 5)
    (check-equal? (candidate (list 6 5)) 5.5)
    (check-equal? (candidate (list 8 1 3 9 9 2 7)) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x)
               (cons (count-ones x) x))
             arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons x (count-ones x))) arr)
        (λ (a b) (cond [(< (cdr a) (cdr b)) #t]
                        [(> (cdr a) (cdr b)) #f]
                        [(< (car a) (car b)) #t]
                        [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (if (= (car x) (car y))
              (< (cdr x) (cdr y))
              (< (car x) (car y))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b) (cond
                       ((< (car a) (car b)) #t)
                       ((> (car a) (car b)) #f)
                       ((< (cdr a) (cdr b)) #t)
                       ((> (cdr a) (cdr b)) #f)
                       (else #f)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (list x (number->string x 2))) arr)
        (λ (x y)
          (cond
            [(> (length (cadr x)) (length (cadr y))) #t]
            [(< (length (cadr x)) (length (cadr y))) #f]
            [(> (car x) (car y)) #t]
            [(< (car x) (car y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(> (car x) (car y)) #t]
            [(< (car x) (car y)) #f]
            [(> (cdr x) (cdr y)) #f]
            [(< (cdr x) (cdr y)) #t]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(= (car a) (car b)) (< (cdr a) (cdr b))]
            [else (< (car a) (car b))]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort arr (lambda (a b)
              (let ([a-ones (count-ones a)]
                    [b-ones (count-ones b)])
                (if (= a-ones b-ones)
                    (< a b)
                    (< a-ones b-ones))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort arr (lambda (x y)
              (let ([x-ones (count-ones x)]
                    [y-ones (count-ones y)])
                (cond
                  [(> x-ones y-ones) #t]
                  [(< x-ones y-ones) #f]
                  [(> x y) #t]
                  [(< x y) #f]
                  [else #f])))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons (count-ones x) x)) arr)
        (λ (x y) (or (< (car x) (car y))
                    (and (= (car x) (car y))
                         (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x)
               (cons (count-ones x) x))
             arr)
        (lambda (a b)
          (if (= (car a) (car b))
              (< (cdr a) (cdr b))
              (< (car a) (car b))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (ones-in-binary x))) arr)
        (lambda (x y)
          (cond
            [(< (cadr x) (cadr y)) #t]
            [(> (cadr x) (cadr y)) #f]
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons (count-ones x) x)) arr)
        (λ (x y) (or (< (car x) (car y))
                    (and (= (car x) (car y)) (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond ((= (car a) (car b)) (< (cdr a) (cdr b)))
                ((< (car a) (car b)) #t)
                (else #f)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        <
        (lambda (x y)
          (if (= (car x) (car y))
              (< (cdr x) (cdr y))
              (< (car x) (car y))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (lambda (x y)
          (let ([x-ones (count-ones x)]
                [y-ones (count-ones y)])
            (cond [(< x-ones y-ones) #t]
                  [(> x-ones y-ones) #f]
                  [else (< x y)])))
        arr))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y) (or (< (car x) (car y))
                          (and (= (car x) (car y))
                               (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons (count-ones x) x)) arr)
        (λ (x y) (or (and (eq? (car x) (car y))
                        (< (cdr x) (cdr y)))
                    (< (car x) (car y))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x)
               (cons x (integer->binary x)))
             arr)
        (lambda (x y)
          (cond
            [(< (length (cdr x)) (length (cdr y))) #t]
            [(> (length (cdr x)) (length (cdr y))) #f]
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond ((= (car a) (car b)) (< (cdr a) (cdr b)))
                ((< (car a) (car b)) #t)
                (else #f)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x)
               (cons (count-ones x) x))
             arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y) (or (< (car x) (car y))
                          (and (= (car x) (car y))
                               (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (if (= (car x) (car y))
              (< (cdr x) (cdr y))
              (< (car x) (car y))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons (count-ones x) x)) arr)
        (λ (x y) (or (< (car x) (car y))
                    (and (= (car x) (car y)) (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons (count-ones x) x)) arr)
        (λ (x y) (or (< (car x) (car y))
                    (and (= (car x) (car y))
                         (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (λ (x) (cons (count-ones x) x)) arr)
        (λ (x y) (or (< (car x) (car y))
                    (and (= (car x) (car y)) (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort arr (lambda (a b)
              (let ([a-ones (count-ones a)]
                    [b-ones (count-ones b)])
                (if (= a-ones b-ones)
                    (< a b)
                    (< a-ones b-ones))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond ((= (car a) (car b)) (< (cdr a) (cdr b)))
                ((< (car a) (car b)) #t)
                (else #f)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (a b)
          (cond
            [(< (car a) (car b)) #t]
            [(> (car a) (car b)) #f]
            [(< (cdr a) (cdr b)) #t]
            [(> (cdr a) (cdr b)) #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (if (= (car x) (car y))
              (< (cdr x) (cdr y))
              (< (car x) (car y))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(> (car x) (car y)) #t]
            [(< (car x) (car y)) #f]
            [(> (cdr x) (cdr y)) #f]
            [(< (cdr x) (cdr y)) #t]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (if (= (car x) (car y))
              (< (cdr x) (cdr y))
              (< (car x) (car y))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y) (or (< (car x) (car y))
                          (and (= (car x) (car y))
                               (< (cdr x) (cdr y)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (cons (count-ones x) x)) arr)
        (lambda (x y)
          (cond
            [(< (car x) (car y)) #t]
            [(> (car x) (car y)) #f]
            [(< (cdr x) (cdr y)) #t]
            [(> (cdr x) (cdr y)) #f]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_116_sort_array --------
#lang racket

;; In this Kata, you have to sort a list of non-negative integers according to
;; number of ones in their binary representation in ascending order.
;; For similar number of ones, sort based on decimal value.
;; It must be implemented like this:
;; >>> (sort_array (list 1 5 2 3 4))
;; (list 1 2 3 4 5)
;; >>> (sort_array (list -2 -3 -4 -5 -6))
;; (list -6 -5 -4 -3 -2)
;; >>> (sort_array (list 1 0 2 3 4))
;; (list 0 1 2 3 4)
(define (sort_array arr)
  (sort (map (lambda (x) (list x (number->string x 2))) arr)
        (lambda (x y)
          (cond
            [(< (length (cadr x)) (length (cadr y))) #t]
            [(> (length (cadr x)) (length (cadr y))) #f]
            [(< (car x) (car y)) #t]
            [else #f]))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_array))
    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))
    (check-equal? (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))
    (check-equal? (candidate (list 1 0 2 3 4)) (list 0 1 2 4 3))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4 3 3 5 5 5 7 77))
    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32 3 5 6 12 44))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (find-longest-palindrome-suffix string)
    (define (is-palindrome? string)
      (define (is-palindrome-helper? string start end)
        (if (= start end)
            #t
            (if (char=? (string-ref string start) (string-ref string end))
                (is-palindrome-helper? string (+ start 1) (- end 1))
                #f)))
      (is-palindrome-helper? string 0 (- (string-length string) 1)))
    (define (find-longest-palindrome-suffix-helper string start)
      (if (= start (string-length string))
          ""
          (if (is-palindrome? (substring string start (string-length string)))
              (substring string start (string-length string))
              (find-longest-palindrome-suffix-helper string (+ start 1)))))
    (find-longest-palindrome-suffix-helper string 0))
  (define (reverse string)
    (define (reverse-helper string start end)
      (if (= start end)
          ""
          (string-append (reverse-helper string (+ start 1) end) (string (string-ref string start)))))
    (reverse-helper string 0 (- (string-length string) 1)))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (substring string 1) (string (string-ref string 0)))))
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-iter string suffix)
      (if (string=? string suffix)
          suffix
          (find-longest-palindrome-suffix-iter string (string-append (string-append (substring string 0 1) suffix) (string-append (substring string 1 1) suffix)))))
    (find-longest-palindrome-suffix-iter string ""))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse-string string)
    (define (reverse-string-iter string reversed-string)
      (if (string=? string "")
          reversed-string
          (reverse-string-iter (substring string 1) (string-append (substring string 0 1) reversed-string))))
    (reverse-string-iter string ""))
  (define (find-palindrome-suffix string)
    (define (find-palindrome-suffix-iter string suffix)
      (if (string=? (reverse-string suffix) suffix)
          suffix
          (find-palindrome-suffix-iter string (substring string 0 (- (string-length string) 1)))))
    (find-palindrome-suffix-iter string string))
  (define (find-palindrome-prefix string)
    (substring string 0 (- (string-length string) (string-length (find-palindrome-suffix string)))))
  (string-append string (reverse-string (find-palindrome-prefix string))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (helper n1 n2)
    (if (= n1 n2)
        0
        (+ (helper n1 (+ n2 1))
           (helper (+ n1 1) n2))))
  (helper 1 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_41_car_race_collision --------
#lang racket

;; Imagine a road that's a perfectly straight infinitely long line.
;; n cars are driving left to right;  simultaneously, a different set of n cars
;; are driving right to left.   The two sets of cars start out being very far from
;; each other.  All cars move in the same speed.  Two cars are said to collide
;; when a car that's moving left to right hits a car that's moving right to left.
;; However, the cars are infinitely sturdy and strong; as a result, they continue moving
;; in their trajectory as if they did not collide.
;; This function outputs the number of such collisions.
(define (car_race_collision n)
  (define (helper n1 n2)
    (if (= n1 n2)
        0
        (+ (helper n1 (+ n2 1))
           (helper (+ n1 1) n2))))
  (helper 0 n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate car_race_collision))
    (check-equal? (candidate 2) 4)
    (check-equal? (candidate 3) 9)
    (check-equal? (candidate 4) 16)
    (check-equal? (candidate 8) 64)
    (check-equal? (candidate 10) 100)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (solve-iter N acc)
    (cond
      [(= N 0) (number->string acc)]
      [else (solve-iter (quotient N 2) (+ (* (remainder N 2) (expt 10 acc)) acc))]))
  (solve-iter N 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_84_solve --------
#lang racket

;; Given a positive integer N, return the total sum of its digits in binary.
;; Example
;; >>> (solve 1000)
;; "1"
;; >>> (solve 150)
;; "110"
;; >>> (solve 147)
;; "1100"
;; Variables:
;; @N integer
;; Constraints: 0 ≤ N ≤ 10000.
;; Output:
;; a string of binary number
(define (solve N)
  (define (solve-iter N acc)
    (cond
      [(zero? N) (number->string acc)]
      [else (solve-iter (quotient N 2) (+ (* (remainder N 2) (expt 10 acc)) acc))]))
  (solve-iter N 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate 1000) "1")
    (check-equal? (candidate 150) "110")
    (check-equal? (candidate 147) "1100")
    (check-equal? (candidate 333) "1001")
    (check-equal? (candidate 963) "10010")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) x]
    [(even? x) (choose_num (+ x 2) y)]
    [(even? y) (choose_num x (- y 2))]
    [else -1]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (add1 x) y))]
    [else (choose_num (add1 x) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) x]
    [(even? x) (choose_num (+ x 2) y)]
    [(even? y) (choose_num x (- y 2))]
    [else -1]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (add1 x) y))]
    [else (choose_num (add1 x) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (add1 x) y))]
    [else (choose_num (add1 x) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (if (= x y)
      (if (even? x)
          x
          -1)
      (if (even? x)
          (max x (choose_num (+ x 1) y))
          (choose_num (+ x 1) y))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (if (and (even? x) (even? y))
      (if (> x y)
          -1
          (if (= x y)
              x
              (choose_num (+ x 2) y)))
      (if (even? x)
          (choose_num (+ x 1) y)
          (choose_num (+ x 2) y))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (if (and (even? x) (even? y))
      (if (> x y)
          -1
          (if (= x y)
              x
              (choose_num (+ x 2) y)))
      (if (even? x)
          (choose_num (+ x 1) y)
          (choose_num (+ x 2) y))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_102_choose_num --------
#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; >>> (choose_num 12 15)
;; 14
;; >>> (choose_num 13 12)
;; -1
(define (choose_num x y)
  (cond
    [(= x y) (if (even? x) x -1)]
    [(even? x) (max x (choose_num (+ x 1) y))]
    [else (choose_num (+ x 1) y)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let* ([first (first arr)]
            [rest (rest arr)]
            [min (apply min rest)]
            [max (apply max rest)])
       (cond
         [(= first min) (move_one_ball rest)]
         [(= first max) #f]
         [else (move_one_ball (append rest (list first)))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (if (empty? arr)
      #t
      (let* ([sorted-arr (sort arr <)]
             [first-element (first arr)]
             [last-element (last arr)])
        (if (equal? arr sorted-arr)
            #t
            (if (equal? first-element last-element)
                #f
                (let ([new-arr (append (rest arr) (list first-element))])
                  (move_one_ball new-arr)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_33_sort_third --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
;; to the values of the corresponding indicies of l, but sorted.
;; >>> (sort_third (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_third (list 5 6 3 4 8 9 2))
;; (list 2 6 3 4 8 9 5)
(define (sort_third l)
  (if (null? l)
      '()
      (if (zero? (modulo (length l) 3))
          (append (sort_third (take l 3)) (sort_third (drop l 3)))
          (append (list (first l)) (sort_third (rest l))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_third))
    (check-equal? (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5))
    (check-equal? (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5))
    (check-equal? (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5))
    (check-equal? (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_33_sort_third --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
;; to the values of the corresponding indicies of l, but sorted.
;; >>> (sort_third (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_third (list 5 6 3 4 8 9 2))
;; (list 2 6 3 4 8 9 5)
(define (sort_third l)
  (if (null? l)
      l
      (if (zero? (modulo (length l) 3))
          (append (sort_third (take l 3)) (sort_third (drop l 3)))
          (append (list (car l)) (sort_third (cdr l))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_third))
    (check-equal? (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5))
    (check-equal? (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5))
    (check-equal? (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5))
    (check-equal? (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_33_sort_third --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
;; to the values of the corresponding indicies of l, but sorted.
;; >>> (sort_third (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_third (list 5 6 3 4 8 9 2))
;; (list 2 6 3 4 8 9 5)
(define (sort_third l)
  (if (null? l)
      '()
      (if (zero? (modulo (length l) 3))
          (append (sort_third (take l 3)) (sort_third (drop l 3)))
          (append (list (car l)) (sort_third (cdr l))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_third))
    (check-equal? (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5))
    (check-equal? (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5))
    (check-equal? (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5))
    (check-equal? (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_33_sort_third --------
#lang racket

;; This function takes a list l and returns a list l' such that
;; l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
;; to the values of the corresponding indicies of l, but sorted.
;; >>> (sort_third (list 1 2 3))
;; (list 1 2 3)
;; >>> (sort_third (list 5 6 3 4 8 9 2))
;; (list 2 6 3 4 8 9 5)
(define (sort_third l)
  (if (null? l)
      '()
      (if (zero? (modulo (length l) 3))
          (append (sort_third (take l 2)) (list (sort (drop l 2))))
          (append (sort_third (take l 1)) (list (car l)) (sort_third (drop l 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate sort_third))
    (check-equal? (candidate (list 5 6 3 4 8 9 2)) (list 2 6 3 4 8 9 5))
    (check-equal? (candidate (list 5 8 3 4 6 9 2)) (list 2 8 3 4 6 9 5))
    (check-equal? (candidate (list 5 6 9 4 8 3 2)) (list 2 6 9 4 8 3 5))
    (check-equal? (candidate (list 5 6 3 4 8 9 2 1)) (list 2 6 3 4 8 9 5 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_147_get_max_triples --------
#lang racket

;; You are given a positive integer n. You have to create an integer list a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; >>> (get_max_triples 5)
;; 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (get-triples a)
    (define (get-triples-helper a i j k)
      (cond
        [(or (= i j) (= j k)) (get-triples-helper a (+ i 1) (+ j 1) (+ k 1))]
        [(= i n) 0]
        [(= j n) (get-triples-helper a (+ i 1) (+ i 2) (+ i 3))]
        [(= k n) (get-triples-helper a i (+ j 1) (+ j 2))]
        [(= (modulo (+ (list-ref a i) (list-ref a j) (list-ref a k)) 3) 0) (+ 1 (get-triples-helper a i j k))]
        [else (get-triples-helper a i j k)]))
    (get-triples-helper a 1 2 3))
  (get-triples (build-list n (lambda (x) (- (* x x) x 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is_prime-iter n (+ i 1)))))
  (is_prime-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (let loop ((i 2))
    (if (= i n)
        #t
        (if (= (remainder n i) 0)
            #f
            (loop (+ i 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_31_is_prime --------
#lang racket

;; Return true if a given number is prime, and false otherwise.
;; >>> (is_prime 6)
;; #f
;; >>> (is_prime 101)
;; #t
;; >>> (is_prime 11)
;; #t
;; >>> (is_prime 13441)
;; #t
;; >>> (is_prime 61)
;; #t
;; >>> (is_prime 4)
;; #f
;; >>> (is_prime 1)
;; #f
(define (is_prime n)
  (define (is_prime-iter n i)
    (if (= i n)
        #t
        (if (= (remainder n i) 0)
            #f
            (is_prime-iter n (+ i 1)))))
  (is_prime-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_prime))
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 101) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 13441) #t)
    (check-equal? (candidate 61) #t)
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 1) #f)
    (check-equal? (candidate 5) #t)
    (check-equal? (candidate 11) #t)
    (check-equal? (candidate 17) #t)
    (check-equal? (candidate 85) #f)
    (check-equal? (candidate 77) #f)
    (check-equal? (candidate 255379) #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (is-substring? lst1 lst2)
    (if (null? lst1)
        #t
        (if (equal? (car lst1) (car lst2))
            (is-substring? (cdr lst1) (cdr lst2))
            #f)))
  (define (is-substring-rotation? lst1 lst2)
    (if (null? lst2)
        #f
        (if (is-substring? lst1 lst2)
            #t
            (is-substring-rotation? lst1 (rotate lst2)))))
  (is-substring-rotation? (string->list a) (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (check s1 s2)
    (if (string=? s1 s2)
        #t
        (check s1 (rotate s2))))
  (check a b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until (rotate lst))))
  (rotate-until (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (substring? s1 s2)
    (if (string=? s1 s2)
        #t
        (substring? (rotate s1) s2)))
  (substring? b a))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until (rotate lst))))
  (rotate-until (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotate-until s)
    (if (string-contains? a s)
        #t
        (rotate-until (rotate s))))
  (rotate-until b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-until-match lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until-match (rotate lst))))
  (rotate-until-match (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotations lst)
    (if (null? lst)
        empty
        (cons lst (rotations (rotate lst)))))
  (define (substring? a b)
    (if (null? b)
        #t
        (if (null? a)
            #f
            (if (equal? (car a) (car b))
                (substring? (cdr a) (cdr b))
                (substring? (cdr a) b)))))
  (define (any-substring? a b)
    (if (null? b)
        #f
        (if (substring? a (car b))
            #t
            (any-substring? a (cdr b)))))
  (any-substring? (string->list a) (rotations (string->list b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until (rotate lst))))
  (rotate-until (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotate-until s)
    (cond
      [(string=? s b) #t]
      [else (rotate-until (rotate s))]))
  (cond
    [(string=? a b) #t]
    [(string-contains? a b) #t]
    [else (rotate-until a)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (check-rotations lst)
    (if (string-contains? a (list->string lst))
        #t
        (if (null? (cdr lst))
            #f
            (check-rotations (rotate lst)))))
  (check-rotations (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotations lst)
    (define (rotations-iter lst acc)
      (if (null? lst)
          acc
          (rotations-iter (rotate lst) (append acc (list lst)))))
    (rotations-iter lst '()))
  (define (substring? a b)
    (define (substring-iter a b)
      (if (null? b)
          #t
          (if (equal? (car a) (car b))
              (substring-iter (cdr a) (cdr b))
              #f)))
    (substring-iter a b))
  (define (any? lst pred)
    (if (null? lst)
        #f
        (if (pred (car lst))
            #t
            (any? (cdr lst) pred))))
  (any? (rotations (string->list b)) (lambda (x) (substring? (string->list a) x))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (is-substring? lst1 lst2)
    (if (null? lst1)
        #t
        (if (equal? (car lst1) (car lst2))
            (is-substring? (cdr lst1) (cdr lst2))
            #f)))
  (define (check-rotations lst1 lst2)
    (if (null? lst1)
        #f
        (if (is-substring? lst1 lst2)
            #t
            (check-rotations (rotate lst1) lst2))))
  (check-rotations (string->list a) (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until (rotate lst))))
  (rotate-until (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (check-rotations s)
    (if (string-contains? a s)
        #t
        (check-rotations (rotate s))))
  (check-rotations b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until-match lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until-match (rotate lst))))
  (rotate-until-match (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (check s1 s2)
    (if (string=? s1 s2)
        #t
        (check s1 (rotate s2))))
  (check a b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (check lst)
    (if (equal? lst b)
        #t
        (check (rotate lst))))
  (check (string->list a)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotate-until s)
    (if (string-contains? a s)
        #t
        (rotate-until (rotate s))))
  (rotate-until b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until (rotate lst))))
  (rotate-until (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (check s)
    (cond
      [(empty? s) #f]
      [(string-contains? a s) #t]
      [else (check (rotate s))]))
  (check b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (check-rotations lst)
    (if (string-contains? a (list->string lst))
        #t
        (check-rotations (rotate lst))))
  (check-rotations (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate l)
    (append (cdr l) (list (car l))))
  (define (rotate-n l n)
    (if (= n 0)
        l
        (rotate-n (rotate l) (- n 1))))
  (define (check l)
    (if (null? l)
        #f
        (if (string-contains? a (list->string l))
            #t
            (check (rotate l)))))
  (check (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotations lst)
    (define (helper lst acc)
      (if (null? lst)
          acc
          (helper (rotate lst) (append acc (list lst)))))
    (helper lst '()))
  (define (substring? lst1 lst2)
    (define (helper lst1 lst2)
      (if (null? lst1)
          #t
          (if (null? lst2)
              #f
              (if (equal? (car lst1) (car lst2))
                  (helper (cdr lst1) (cdr lst2))
                  #f))))
    (if (null? lst1)
        #t
        (if (null? lst2)
            #f
            (or (helper lst1 lst2)
                (substring? lst1 (cdr lst2))))))
  (define (substring-any? lst1 lst2)
    (if (null? lst2)
        #f
        (or (substring? lst1 (car lst2))
            (substring-any? lst1 (cdr lst2)))))
  (substring-any? (string->list a) (rotations (string->list b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (substring? s1 s2)
    (if (string=? s1 s2)
        #t
        (substring? (rotate s1) s2)))
  (substring? b a))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotations lst)
    (define (rotations-iter lst acc)
      (if (null? lst)
          acc
          (rotations-iter (rotate lst) (append acc (list lst)))))
    (rotations-iter lst '()))
  (define (substring? a b)
    (define (substring-iter a b)
      (if (null? b)
          #t
          (if (equal? (car a) (car b))
              (substring-iter (cdr a) (cdr b))
              #f)))
    (substring-iter a b))
  (define (any-substring? a b)
    (define (any-substring-iter a b)
      (if (null? b)
          #f
          (if (substring? a (car b))
              #t
              (any-substring-iter a (cdr b)))))
    (any-substring-iter a b))
  (any-substring? a (rotations (string->list b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (sublist? lst1 lst2)
    (if (empty? lst1)
        #t
        (if (empty? lst2)
            #f
            (if (equal? (car lst1) (car lst2))
                (sublist? (cdr lst1) (cdr lst2))
                (sublist? lst1 (cdr lst2))))))
  (define (substring? lst1 lst2)
    (if (empty? lst2)
        #f
        (if (sublist? lst1 lst2)
            #t
            (substring? lst1 (cdr lst2)))))
  (define (check lst1 lst2)
    (if (empty? lst2)
        #f
        (if (substring? lst1 lst2)
            #t
            (check lst1 (rotate lst2)))))
  (check (string->list a) (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (let ([a (string->list a)]
        [b (string->list b)])
    (define (rotate l)
      (append (cdr l) (list (car l))))
    (define (rotate-n l n)
      (if (= n 0)
          l
          (rotate-n (rotate l) (- n 1))))
    (define (rotate-until-match l1 l2)
      (if (equal? l1 l2)
          #t
          (if (equal? l1 (rotate l1))
              #f
              (rotate-until-match (rotate l1) l2))))
    (rotate-until-match a b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotate-until s)
    (if (string-contains? a s)
        #t
        (rotate-until (rotate s))))
  (rotate-until b))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (= n 0)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (rotate-until lst)
    (if (string-contains? a (list->string lst))
        #t
        (rotate-until (rotate lst))))
  (rotate-until (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (let loop ([a a] [b b])
    (if (string=? a b)
        #t
        (loop (string-append (substring a 1) (substring a 0 1)) b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate lst)
    (append (cdr lst) (list (car lst))))
  (define (rotate-n lst n)
    (if (zero? n)
        lst
        (rotate-n (rotate lst) (- n 1))))
  (define (substring? a b)
    (if (or (null? a) (null? b))
        #f
        (if (equal? (car a) (car b))
            (substring? (cdr a) (cdr b))
            (substring? a (cdr b)))))
  (define (rotate-and-substring? a b)
    (if (null? b)
        #f
        (or (substring? a b)
            (rotate-and-substring? a (rotate b)))))
  (rotate-and-substring? (string->list a) (string->list b)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_99_closest_integer --------
#lang racket

;; Create a function that takes a value (string) representing a number
;; and returns the closest integer to it. If the number is equidistant
;; from two integers, round it away from zero.
;; Examples
;; >>> (closest_integer "10")
;; 10
;; >>> (closest_integer "15.3")
;; 15
;; Note:
;; Rounding away from zero means that if the given number is equidistant
;; from two integers, the one you should return is the one that is the
;; farthest from zero. For example closest_integer("14.5") should
;; return 15 and closest_integer("-14.5") should return -15.
(define (closest_integer value)
  (define (closest-integer-helper value)
    (if (integer? value)
        value
        (if (positive? value)
            (closest-integer-helper (+ value 1))
            (closest-integer-helper (- value 1)))))
  (closest-integer-helper (string->number value)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate closest_integer))
    (check-equal? (candidate "10") 10)
    (check-equal? (candidate "14.5") 15)
    (check-equal? (candidate "-15.5") -16)
    (check-equal? (candidate "15.3") 15)
    (check-equal? (candidate "0") 0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman-helper (/ number 10)) (int_to_mini_roman-helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond ((<= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman_helper (/ number 10))
                               (int_to_mini_roman_helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman_helper (/ number 10))
                               (int_to_mini_roman_helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman_helper (/ number 10))
                           (int_to_mini_roman_helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman-helper (/ number 10))
                               (int_to_mini_roman-helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman-helper (/ number 10)) (int_to_mini_roman-helper (modulo number 10)))])
    )
  (string-downcase (int_to_mini_roman-helper number))
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman_helper (/ number 10))
                               (int_to_mini_roman_helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 11) "xi"]
      [(= number 12) "xii"]
      [(= number 13) "xiii"]
      [(= number 14) "xiv"]
      [(= number 15) "xv"]
      [(= number 16) "xvi"]
      [(= number 17) "xvii"]
      [(= number 18) "xviii"]
      [(= number 19) "xix"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman_helper (/ number 10))
                           (int_to_mini_roman_helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman-helper (/ number 10))
                               (int_to_mini_roman-helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 11) "xi")
          ((= number 12) "xii")
          ((= number 13) "xiii")
          ((= number 14) "xiv")
          ((= number 15) "xv")
          ((= number 16) "xvi")
          ((= number 17) "xvii")
          ((= number 18) "xviii")
          ((= number 19) "xix")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman-helper (/ number 10)) (int_to_mini_roman-helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 0) "")
          ((= number 1) "i")
          ((= number 2) "ii")
          ((= number 3) "iii")
          ((= number 4) "iv")
          ((= number 5) "v")
          ((= number 6) "vi")
          ((= number 7) "vii")
          ((= number 8) "viii")
          ((= number 9) "ix")
          ((= number 10) "x")
          ((= number 20) "xx")
          ((= number 30) "xxx")
          ((= number 40) "xl")
          ((= number 50) "l")
          ((= number 60) "lx")
          ((= number 70) "lxx")
          ((= number 80) "lxxx")
          ((= number 90) "xc")
          ((= number 100) "c")
          ((= number 200) "cc")
          ((= number 300) "ccc")
          ((= number 400) "cd")
          ((= number 500) "d")
          ((= number 600) "dc")
          ((= number 700) "dcc")
          ((= number 800) "dccc")
          ((= number 900) "cm")
          ((= number 1000) "m")
          (else (string-append (int_to_mini_roman-helper (/ number 10))
                               (int_to_mini_roman-helper (modulo number 10))))))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 11) "xi"]
      [(= number 12) "xii"]
      [(= number 13) "xiii"]
      [(= number 14) "xiv"]
      [(= number 15) "xv"]
      [(= number 16) "xvi"]
      [(= number 17) "xvii"]
      [(= number 18) "xviii"]
      [(= number 19) "xix"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman_helper (/ number 10)) (int_to_mini_roman_helper (modulo number 10)))])
    )
  (string-downcase (int_to_mini_roman_helper number))
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append
              (int_to_mini_roman_helper (/ number 10))
              (int_to_mini_roman_helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 1000) "m")
          ((= number 900) "cm")
          ((= number 500) "d")
          ((= number 400) "cd")
          ((= number 100) "c")
          ((= number 90) "xc")
          ((= number 50) "l")
          ((= number 40) "xl")
          ((= number 10) "x")
          ((= number 9) "ix")
          ((= number 5) "v")
          ((= number 4) "iv")
          ((= number 1) "i")))
  (cond ((<= number 0) "")
        ((<= number 1000) (string-append (int_to_mini_roman-helper number)
                                         (int_to_mini_roman (- number (remainder number 10)))))
        (else "?")))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond ((= number 1000) "m")
          ((= number 900) "cm")
          ((= number 500) "d")
          ((= number 400) "cd")
          ((= number 100) "c")
          ((= number 90) "xc")
          ((= number 50) "l")
          ((= number 40) "xl")
          ((= number 10) "x")
          ((= number 9) "ix")
          ((= number 5) "v")
          ((= number 4) "iv")
          ((= number 1) "i")
          (else (string-append (int_to_mini_roman-helper (/ number 10))
                               (int_to_mini_roman-helper (remainder number 10))))))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (int_to_mini_roman_helper (modulo number 1000))
            (int_to_mini_roman_helper (/ number 1000))]))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 11) "xi"]
      [(= number 12) "xii"]
      [(= number 13) "xiii"]
      [(= number 14) "xiv"]
      [(= number 15) "xv"]
      [(= number 16) "xvi"]
      [(= number 17) "xvii"]
      [(= number 18) "xviii"]
      [(= number 19) "xix"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman_helper (/ number 10))
                           (int_to_mini_roman_helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (int_to_mini_roman-helper (modulo number 1000))
            (int_to_mini_roman-helper (/ number 1000))]))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 11) "xi"]
      [(= number 12) "xii"]
      [(= number 13) "xiii"]
      [(= number 14) "xiv"]
      [(= number 15) "xv"]
      [(= number 16) "xvi"]
      [(= number 17) "xvii"]
      [(= number 18) "xviii"]
      [(= number 19) "xix"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman-helper (/ number 10))
                           (int_to_mini_roman-helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond
      [(= number 1000) "m"]
      [(= number 900) "cm"]
      [(= number 500) "d"]
      [(= number 400) "cd"]
      [(= number 100) "c"]
      [(= number 90) "xc"]
      [(= number 50) "l"]
      [(= number 40) "xl"]
      [(= number 10) "x"]
      [(= number 9) "ix"]
      [(= number 5) "v"]
      [(= number 4) "iv"]
      [(= number 1) "i"]
      [else (string-append
              (int_to_mini_roman-helper (quotient number (car (filter (lambda (x) (>= x number)) '(1000 900 500 400 100 90 50 40 10 9 5 4 1))))))
             (int_to_mini_roman-helper (remainder number (car (filter (lambda (x) (>= x number)) '(1000 900 500 400 100 90 50 40 10 9 5 4 1)))))]))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman_helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 11) "xi"]
      [(= number 12) "xii"]
      [(= number 13) "xiii"]
      [(= number 14) "xiv"]
      [(= number 15) "xv"]
      [(= number 16) "xvi"]
      [(= number 17) "xvii"]
      [(= number 18) "xviii"]
      [(= number 19) "xix"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append (int_to_mini_roman_helper (/ number 10))
                           (int_to_mini_roman_helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond
      [(= number 0) '()]
      [(= number 1) '(i)]
      [(= number 2) '(i i)]
      [(= number 3) '(i i i)]
      [(= number 4) '(i v)]
      [(= number 5) '(v)]
      [(= number 6) '(v i)]
      [(= number 7) '(v i i)]
      [(= number 8) '(v i i i)]
      [(= number 9) '(i x)]
      [(= number 10) '(x)]
      [(= number 20) '(x x)]
      [(= number 30) '(x x x)]
      [(= number 40) '(x l)]
      [(= number 50) '(l)]
      [(= number 60) '(l x)]
      [(= number 70) '(l x x)]
      [(= number 80) '(l x x x)]
      [(= number 90) '(x c)]
      [(= number 100) '(c)]
      [(= number 200) '(c c)]
      [(= number 300) '(c c c)]
      [(= number 400) '(c d)]
      [(= number 500) '(d)]
      [(= number 600) '(d c)]
      [(= number 700) '(d c c)]
      [(= number 800) '(d c c c)]
      [(= number 900) '(c m)]
      [(= number 1000) '(m)]
      [else (append (int_to_mini_roman-helper (/ number 10))
                    (int_to_mini_roman-helper (remainder number 10)))]))
  (string-join (int_to_mini_roman-helper number) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_156_int_to_mini_roman --------
#lang racket

;; Given a positive integer, obtain its roman numeral equivalent as a string,
;; and return it in lowercase.
;; Restrictions: 1 <= num <= 1000
;; Examples:
;; >>> (int_to_mini_roman 19)
;; "xix"
;; >>> (int_to_mini_roman 152)
;; "clii"
;; >>> (int_to_mini_roman 426)
;; "cdxxvi"
(define (int_to_mini_roman number)
  (define (int_to_mini_roman-helper number)
    (cond
      [(= number 0) ""]
      [(= number 1) "i"]
      [(= number 2) "ii"]
      [(= number 3) "iii"]
      [(= number 4) "iv"]
      [(= number 5) "v"]
      [(= number 6) "vi"]
      [(= number 7) "vii"]
      [(= number 8) "viii"]
      [(= number 9) "ix"]
      [(= number 10) "x"]
      [(= number 11) "xi"]
      [(= number 12) "xii"]
      [(= number 13) "xiii"]
      [(= number 14) "xiv"]
      [(= number 15) "xv"]
      [(= number 16) "xvi"]
      [(= number 17) "xvii"]
      [(= number 18) "xviii"]
      [(= number 19) "xix"]
      [(= number 20) "xx"]
      [(= number 30) "xxx"]
      [(= number 40) "xl"]
      [(= number 50) "l"]
      [(= number 60) "lx"]
      [(= number 70) "lxx"]
      [(= number 80) "lxxx"]
      [(= number 90) "xc"]
      [(= number 100) "c"]
      [(= number 200) "cc"]
      [(= number 300) "ccc"]
      [(= number 400) "cd"]
      [(= number 500) "d"]
      [(= number 600) "dc"]
      [(= number 700) "dcc"]
      [(= number 800) "dccc"]
      [(= number 900) "cm"]
      [(= number 1000) "m"]
      [else (string-append
              (int_to_mini_roman-helper (/ number 10))
              (int_to_mini_roman-helper (modulo number 10)))]))
  (string-downcase (int_to_mini_roman-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate int_to_mini_roman))
    (check-equal? (candidate 19) "xix")
    (check-equal? (candidate 152) "clii")
    (check-equal? (candidate 251) "ccli")
    (check-equal? (candidate 426) "cdxxvi")
    (check-equal? (candidate 500) "d")
    (check-equal? (candidate 1) "i")
    (check-equal? (candidate 4) "iv")
    (check-equal? (candidate 43) "xliii")
    (check-equal? (candidate 90) "xc")
    (check-equal? (candidate 94) "xciv")
    (check-equal? (candidate 532) "dxxxii")
    (check-equal? (candidate 900) "cm")
    (check-equal? (candidate 994) "cmxciv")
    (check-equal? (candidate 1000) "m")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_prime-iter a b)
      (cond ((= b a) #t)
            ((= (modulo a b) 0) #f)
            (else (is_prime-iter a (+ b 1)))))
    (is_prime-iter a 2))
  (define (is_multiply-prime-iter a b)
    (cond ((= a 1) #t)
          ((and (is_prime a) (is_prime b)) #t)
          (else (is_multiply-prime-iter (/ a b) (+ b 1)))))
  (is_multiply-prime-iter a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (- i 1))]))
    (iter (- n 1)))
  (define (iter i)
    (cond
      [(= i a) #f]
      [(and (is_prime i) (is_prime (- a i))) #t]
      [else (iter (+ i 1))]))
  (iter 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor a 2) a))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((is_prime a) (is_multiply_prime_helper (/ a b) b))
          (else #f)))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime_iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (is_prime_iter (+ i 1)))))
    (is_prime_iter 2))
  (define (is_multiply_prime_iter i)
    (if (= i a)
        #f
        (if (and (is_prime i) (is_prime (/ a i)))
            #t
            (is_multiply_prime_iter (+ i 1)))))
  (is_multiply_prime_iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 2) #t]
    [(= a 3) #t]
    [(= a 5) #t]
    [(= a 7) #t]
    [(= a 11) #t]
    [(= a 13) #t]
    [(= a 17) #t]
    [(= a 19) #t]
    [(= a 23) #t]
    [(= a 29) #t]
    [(= a 31) #t]
    [(= a 37) #t]
    [(= a 41) #t]
    [(= a 43) #t]
    [(= a 47) #t]
    [(= a 53) #t]
    [(= a 59) #t]
    [(= a 61) #t]
    [(= a 67) #t]
    [(= a 71) #t]
    [(= a 73) #t]
    [(= a 79) #t]
    [(= a 83) #t]
    [(= a 89) #t]
    [(= a 97) #t]
    [else #f]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime_iter n div)
      (cond ((= div 1) #t)
            ((= (modulo n div) 0) #f)
            (else (is_prime_iter n (- div 1)))))
    (is_prime_iter n (- n 1)))
  (define (is_multiply_prime_iter a b)
    (cond ((= b 1) #f)
          ((and (is_prime b) (is_prime (/ a b))) #t)
          (else (is_multiply_prime_iter a (- b 1)))))
  (is_multiply_prime_iter a a))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (cond ((= a 1) #f)
          ((= a 2) #t)
          ((even? a) #f)
          (else (is_prime_aux a 3))))
  (define (is_prime_aux a b)
    (cond ((= b (/ a 2)) #t)
          ((= (modulo a b) 0) #f)
          (else (is_prime_aux a (+ b 2)))))
  (define (is_multiply_prime_aux a b)
    (cond ((= b (/ a 2)) #f)
          ((and (is_prime b) (is_prime (/ a b))) #t)
          (else (is_multiply_prime_aux a (+ b 2)))))
  (is_multiply_prime_aux a 3))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (divides? a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((divides? n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor n 2) n))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((is_prime test-divisor)
           (if (divides? n test-divisor)
               (if (is_multiply_prime (/ n test-divisor))
                   #t
                   #f)
               (find-divisor n (+ test-divisor 1))))
          (else (find-divisor n (+ test-divisor 1)))))
  (find-divisor a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= n (find-divisor n 2)))
  (define (is_multiply_prime_iter a b)
    (cond ((= a 1) #t)
          ((is_prime a) (is_multiply_prime_iter (/ a b) b))
          ((is_prime b) (is_multiply_prime_iter a (/ b b)))
          (else #f)))
  (is_multiply_prime_iter a a))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 5) #f]
    [(= a 7) #f]
    [(= a 11) #f]
    [(= a 13) #f]
    [(= a 17) #f]
    [(= a 19) #f]
    [(= a 23) #f]
    [(= a 29) #f]
    [(= a 31) #f]
    [(= a 37) #f]
    [(= a 41) #f]
    [(= a 43) #f]
    [(= a 47) #f]
    [(= a 53) #f]
    [(= a 59) #f]
    [(= a 61) #f]
    [(= a 67) #f]
    [(= a 71) #f]
    [(= a 73) #f]
    [(= a 79) #f]
    [(= a 83) #f]
    [(= a 89) #f]
    [(= a 97) #f]
    [else #t]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (is_prime_helper n 3))))
  (define (is_prime_helper n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is_prime_helper n (+ i 2)))))
  (cond ((= a 1) #f)
        ((= a 2) #t)
        ((= a 3) #t)
        ((= a 5) #t)
        ((= a 7) #t)
        ((= a 11) #t)
        ((= a 13) #t)
        ((= a 17) #t)
        ((= a 19) #t)
        ((= a 23) #t)
        ((= a 29) #t)
        ((= a 31) #t)
        ((= a 37) #t)
        ((= a 41) #t)
        ((= a 43) #t)
        ((= a 47) #t)
        ((= a 53) #t)
        ((= a 59) #t)
        ((= a 61) #t)
        ((= a 67) #t)
        ((= a 71) #t)
        ((= a 73) #t)
        ((= a 79) #t)
        ((= a 83) #t)
        ((= a 89) #t)
        ((= a 97) #t)
        (else (is_prime_helper a 2))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond
      [(= n 1) #f]
      [(= n 2) #t]
      [(even? n) #f]
      [else (is_prime_helper n 3)]))
  (define (is_prime_helper n i)
    (cond
      [(> (* i i) n) #t]
      [(zero? (modulo n i)) #f]
      [else (is_prime_helper n (+ i 2))]))
  (define (is_multiply_prime_helper a b c)
    (cond
      [(and (is_prime a) (is_prime b) (is_prime c)) #t]
      [else #f]))
  (cond
    [(and (is_prime a) (is_prime b) (is_prime c)) #t]
    [(is_multiply_prime_helper a b c) #t]
    [else #f]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= n (find-divisor n 2)))
  (define (is_multiply_prime-iter n)
    (cond ((= n 1) #t)
          ((is_prime n) (is_multiply_prime-iter (/ a n)))
          (else #f)))
  (is_multiply_prime-iter a))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor n 2) n))
  (define (is_multiply_prime-iter a b)
    (cond ((= b 0) #t)
          ((is_prime a) (is_multiply_prime-iter (/ a b) (- b 1)))
          (else #f)))
  (is_multiply_prime-iter a 3))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime_helper n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper n (+ i 1)))))
    (is_prime_helper n 2))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((and (is_prime a) (is_prime b)) #t)
          (else (is_multiply_prime_helper (/ a b) b))))
  (is_multiply_prime_helper a 3))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (divides? a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((divides? n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor n 2) n))
  (define (find-prime-divisor n)
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((and (divides? n test-divisor) (is_prime test-divisor)) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (find-divisor n 2))
  (define (find-prime-divisors n)
    (cond ((= n 1) '())
          ((is_prime n) (list n))
          (else (cons (find-prime-divisor n) (find-prime-divisors (/ n (find-prime-divisor n)))))))
  (cond ((= a 1) #f)
        ((is_prime a) #f)
        ((= (length (find-prime-divisors a)) 3) #t)
        (else #f)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (iter b)
      (cond ((= b 1) #t)
            ((= (modulo a b) 0) #f)
            (else (iter (- b 1)))))
    (iter (- a 1)))
  (define (iter b)
    (cond ((= b 1) #f)
          ((and (is_prime b) (is_prime (/ a b))) #t)
          (else (iter (- b 1)))))
  (iter (/ a 3)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime_helper n divisor)
      (cond ((= divisor 1) #t)
            ((= (modulo n divisor) 0) #f)
            (else (is_prime_helper n (- divisor 1)))))
    (is_prime_helper n (- n 1)))
  (define (is_multiply_prime_helper a b c)
    (cond ((and (is_prime a) (is_prime b) (is_prime c)) #t)
          ((= a c) #f)
          (else (is_multiply_prime_helper a b (+ c 1)))))
  (is_multiply_prime_helper a a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor a 2) a))
  (define (is_multiply_prime_iter a b)
    (cond ((= a 1) #t)
          ((is_prime a) (is_multiply_prime_iter (/ a b) b))
          (else #f)))
  (is_multiply_prime_iter a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (loop i)
      (cond ((= i a) #t)
            ((is_divisible a i) #f)
            (else (loop (+ i 1)))))
    (loop 2))
  (define (loop i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (loop (+ i 1)))))
  (loop 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (loop i)
      (cond ((= i a) #t)
            ((is_divisible a i) #f)
            (else (loop (+ i 1)))))
    (loop 2))
  (define (loop i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (loop (+ i 1)))))
  (loop 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (cond ((= a 1) #f)
          ((= a 2) #t)
          ((= (remainder a 2) 0) #f)
          (else (is_prime_helper a 3))))
  (define (is_prime_helper a b)
    (cond ((= b a) #t)
          ((= (remainder a b) 0) #f)
          (else (is_prime_helper a (+ b 2)))))
  (define (is_multiply_prime_helper a b)
    (cond ((= b a) #f)
          ((= (remainder a b) 0)
           (cond ((is_prime b)
                  (cond ((= (remainder (/ a b) 2) 0)
                         (is_multiply_prime_helper (/ a b) 3))
                        ((= (remainder (/ a b) 3) 0)
                         (is_multiply_prime_helper (/ a b) 5))
                        (else #f)))
                 (else #f)))
          (else (is_multiply_prime_helper a (+ b 2)))))
  (is_multiply_prime_helper a 3))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor a 2) a))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((is_prime a) (is_multiply_prime_helper (/ a b) b))
          (else #f)))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 5) #f]
    [(= a 7) #f]
    [(= a 11) #f]
    [(= a 13) #f]
    [(= a 17) #f]
    [(= a 19) #f]
    [(= a 23) #f]
    [(= a 29) #f]
    [(= a 31) #f]
    [(= a 37) #f]
    [(= a 41) #f]
    [(= a 43) #f]
    [(= a 47) #f]
    [(= a 53) #f]
    [(= a 59) #f]
    [(= a 61) #f]
    [(= a 67) #f]
    [(= a 71) #f]
    [(= a 73) #f]
    [(= a 79) #f]
    [(= a 83) #f]
    [(= a 89) #f]
    [(= a 97) #f]
    [else #t]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime-iter n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime-iter n (+ i 1)))))
    (is_prime-iter n 2))
  (define (is_multiply-prime-iter a b c)
    (cond ((and (is_prime a) (is_prime b) (is_prime c)) #t)
          ((= a b) (is_multiply-prime-iter a (+ b 1) c))
          ((= b c) (is_multiply-prime-iter a b (+ c 1)))
          (else (is_multiply-prime-iter (+ a 1) b c))))
  (is_multiply-prime-iter 1 1 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (is_prime_helper n 3))))
  (define (is_prime_helper n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is_prime_helper n (+ i 2)))))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((= (remainder a b) 0) (is_multiply_prime_helper (/ a b) b))
          ((is_prime b) (is_multiply_prime_helper a (+ b 2)))
          (else (is_multiply_prime_helper a (+ b 2)))))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime_helper n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is_prime_helper n (+ i 1)))))
    (is_prime_helper n 2))
  (define (is_multiply_prime_helper a b)
    (cond ((= (modulo a b) 0) (and (is_prime b) (is_multiply_prime_helper (/ a b) b)))
          ((= b a) #t)
          (else (is_multiply_prime_helper a (+ b 1)))))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (is_prime_helper n 3))))
  (define (is_prime_helper n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is_prime_helper n (+ i 2)))))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((= (remainder a b) 0) (is_multiply_prime_helper (/ a b) b))
          ((is_prime b) (is_multiply_prime_helper a (+ b 2)))
          (else (is_multiply_prime_helper a (+ b 2)))))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (is_prime_helper n 3))))
  (define (is_prime_helper n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is_prime_helper n (+ i 2)))))
  (define (is_multiply_prime_helper a b c)
    (cond ((and (is_prime a) (is_prime b) (is_prime c)) #t)
          ((= a b) (is_multiply_prime_helper a (+ b 1) c))
          ((= b c) (is_multiply_prime_helper a b (+ c 1)))
          (else (is_multiply_prime_helper (+ a 1) b c))))
  (is_multiply_prime_helper 1 1 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (is_prime_aux n 3))))
  (define (is_prime_aux n i)
    (cond ((= i n) #t)
          ((= (remainder n i) 0) #f)
          (else (is_prime_aux n (+ i 2)))))
  (define (is_multiply_prime_aux a b)
    (cond ((= a 1) #t)
          ((= (remainder a b) 0) (is_multiply_prime_aux (/ a b) b))
          ((is_prime b) (is_multiply_prime_aux a (+ b 2)))
          (else (is_multiply_prime_aux a (+ b 2)))))
  (is_multiply_prime_aux a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor a 2) a))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((is_prime a) (is_multiply_prime_helper (/ a b) b))
          (else #f)))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime-iter n i)
      (if (= n 1)
          #f
          (if (= n i)
              #t
              (if (= (remainder n i) 0)
                  #f
                  (is_prime-iter n (+ i 1))))))
    (is_prime-iter n 2))
  (define (is_multiply-prime-iter a i)
    (if (= a 1)
        #f
        (if (is_prime i)
            (if (= (remainder a i) 0)
                (if (is_multiply-prime-iter (/ a i) i)
                    #t
                    (is_multiply-prime-iter a (+ i 1)))
                (is_multiply-prime-iter a (+ i 1)))
            (is_multiply-prime-iter a (+ i 1)))))
  (is_multiply-prime-iter a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime a)
    (define (is_divisible a b)
      (= (remainder a b) 0))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((is_divisible n test-divisor) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (= (find-divisor a 2) a))
  (define (is_multiply_prime_helper a b)
    (cond ((= a 1) #t)
          ((is_prime a) (is_multiply_prime_helper (/ a b) b))
          (else #f)))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (cond
    [(= a 1) #f]
    [(= a 2) #f]
    [(= a 3) #f]
    [(= a 5) #f]
    [(= a 7) #f]
    [(= a 11) #f]
    [(= a 13) #f]
    [(= a 17) #f]
    [(= a 19) #f]
    [(= a 23) #f]
    [(= a 29) #f]
    [(= a 31) #f]
    [(= a 37) #f]
    [(= a 41) #f]
    [(= a 43) #f]
    [(= a 47) #f]
    [(= a 53) #f]
    [(= a 59) #f]
    [(= a 61) #f]
    [(= a 67) #f]
    [(= a 71) #f]
    [(= a 73) #f]
    [(= a 79) #f]
    [(= a 83) #f]
    [(= a 89) #f]
    [(= a 97) #f]
    [else #t]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter i)
    (cond ((= i a) #f)
          ((and (is_prime i) (is_prime (/ a i))) #t)
          (else (iter (+ i 1)))))
  (iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_75_is_multiply_prime --------
#lang racket

;; Write a function that returns true if the given number is the multiplication of 3 prime numbers
;; and false otherwise.
;; Knowing that (a) is less then 100. 
;; Example:
;; >>> (is_multiply_prime 30)
;; #t
;; 30 = 2 * 3 * 5
(define (is_multiply_prime a)
  (define (is_prime n)
    (define (is_prime_helper n i)
      (cond
        [(= i 1) #t]
        [(= (modulo n i) 0) #f]
        [else (is_prime_helper n (- i 1))]))
    (is_prime_helper n (- n 1)))
  (define (is_multiply_prime_helper a b)
    (cond
      [(= (modulo a b) 0) (and (is_prime b) (is_multiply_prime_helper (/ a b) b))]
      [else (is_multiply_prime_helper a (+ b 1))]))
  (is_multiply_prime_helper a 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_multiply_prime))
    (check-equal? (candidate 5) #f)
    (check-equal? (candidate 30) #t)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #f)
    (check-equal? (candidate 125) #t)
    (check-equal? (candidate 105) #t)
    (check-equal? (candidate 126) #f)
    (check-equal? (candidate 729) #f)
    (check-equal? (candidate 891) #f)
    (check-equal? (candidate 1001) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (cond
    [(empty? arr) -1]
    [(empty? (rest arr)) -1]
    [else
     (let ([curr (first arr)]
           [next (first (rest arr))])
       (if (<= curr next)
           (can_arrange (rest arr))
           (can_arrange (rest arr) (add1 (can_arrange arr)))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-i -1])
    (cond [(empty? arr) max-i]
          [(>= (first arr) (second arr)) (loop (+ i 1) max-i)]
          [else (loop (+ i 1) i)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (null? arr)
        max-index
        (if (<= (car arr) (cadr arr))
            (loop (+ i 1) i)
            (loop (+ i 1) max-index)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max 0])
    (cond [(empty? arr) (sub1 max)]
          [(>= (first arr) (second arr)) (loop (add1 i) (add1 i))]
          [else (loop (add1 i) max)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [max-index -1])
    (if (null? arr)
        max-index
        (if (<= (car arr) (cadr arr))
            (loop (+ i 1) max-index)
            (loop (+ i 1) i)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [prev (car arr)])
    (if (null? arr)
        -1
        (if (<= (car arr) prev)
            (loop (+ i 1) (car arr))
            i))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [prev (car arr)])
    (cond [(null? arr) -1]
          [(>= (car arr) prev) (loop (+ i 1) (car arr))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_135_can_arrange --------
#lang racket

;; Create a function which returns the largest index of an element which
;; is not greater than or equal to the element immediately preceding it. If
;; no such element exists then return -1. The given list will not contain
;; duplicate values.
;; Examples:
;; >>> (can_arrange (list 1 2 4 3 5))
;; 3
;; >>> (can_arrange (list 1 2 3))
;; -1
(define (can_arrange arr)
  (let loop ([i 0] [prev (car arr)])
    (cond [(empty? arr) -1]
          [(<= (car arr) prev) (loop (+ i 1) (car arr))]
          [else i])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate can_arrange))
    (check-equal? (candidate (list 1 2 4 3 5)) 3)
    (check-equal? (candidate (list 1 2 4 5)) -1)
    (check-equal? (candidate (list 1 4 2 5 6 7 8 9 10)) 2)
    (check-equal? (candidate (list 4 8 5 7 3)) 4)
    (check-equal? (candidate (list )) -1)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_46_fib4 --------
#lang racket

;; The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
;; fib4(0) -> 0
;; fib4(1) -> 0
;; fib4(2) -> 2
;; fib4(3) -> 0
;; fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
;; Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
;; >>> (fib4 5)
;; 4
;; >>> (fib4 6)
;; 8
;; >>> (fib4 7)
;; 14
(define (fib4 n)
  (define (fib4-helper n-1 n-2 n-3 n-4)
    (cond
      [(= n 0) n-1]
      [(= n 1) n-2]
      [(= n 2) n-3]
      [(= n 3) n-4]
      [else (fib4-helper (+ n-1 n-2 n-3 n-4) n-1 n-2 n-3)]))
  (fib4-helper 0 0 2 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fib4))
    (check-equal? (candidate 5) 4)
    (check-equal? (candidate 8) 28)
    (check-equal? (candidate 10) 104)
    (check-equal? (candidate 12) 386)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_46_fib4 --------
#lang racket

;; The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
;; fib4(0) -> 0
;; fib4(1) -> 0
;; fib4(2) -> 2
;; fib4(3) -> 0
;; fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
;; Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
;; >>> (fib4 5)
;; 4
;; >>> (fib4 6)
;; 8
;; >>> (fib4 7)
;; 14
(define (fib4 n)
  (define (fib4-helper n-1 n-2 n-3 n-4)
    (cond
      [(= n 0) n-1]
      [(= n 1) n-2]
      [(= n 2) n-3]
      [(= n 3) n-4]
      [else (fib4-helper (+ n-1 n-2 n-3 n-4) n-1 n-2 n-3)]))
  (fib4-helper 0 0 2 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fib4))
    (check-equal? (candidate 5) 4)
    (check-equal? (candidate 8) 28)
    (check-equal? (candidate 10) 104)
    (check-equal? (candidate 12) 386)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_46_fib4 --------
#lang racket

;; The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
;; fib4(0) -> 0
;; fib4(1) -> 0
;; fib4(2) -> 2
;; fib4(3) -> 0
;; fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
;; Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
;; >>> (fib4 5)
;; 4
;; >>> (fib4 6)
;; 8
;; >>> (fib4 7)
;; 14
(define (fib4 n)
  (define (fib4-helper n-1 n-2 n-3 n-4)
    (cond [(= n 0) n-1]
          [(= n 1) n-2]
          [(= n 2) n-3]
          [(= n 3) n-4]
          [else (fib4-helper (+ n-1 n-2 n-3 n-4) n-1 n-2 n-3)]))
  (fib4-helper 0 0 2 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fib4))
    (check-equal? (candidate 5) 4)
    (check-equal? (candidate 8) 28)
    (check-equal? (candidate 10) 104)
    (check-equal? (candidate 12) 386)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_46_fib4 --------
#lang racket

;; The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
;; fib4(0) -> 0
;; fib4(1) -> 0
;; fib4(2) -> 2
;; fib4(3) -> 0
;; fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
;; Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
;; >>> (fib4 5)
;; 4
;; >>> (fib4 6)
;; 8
;; >>> (fib4 7)
;; 14
(define (fib4 n)
  (define (fib4-helper n1 n2 n3 n4)
    (cond [(= n 0) n1]
          [(= n 1) n2]
          [(= n 2) n3]
          [(= n 3) n4]
          [else (fib4-helper n2 n3 n4 (+ n1 n2 n3 n4))]))
  (fib4-helper 0 0 2 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fib4))
    (check-equal? (candidate 5) 4)
    (check-equal? (candidate 8) 28)
    (check-equal? (candidate 10) 104)
    (check-equal? (candidate 12) 386)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_46_fib4 --------
#lang racket

;; The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
;; fib4(0) -> 0
;; fib4(1) -> 0
;; fib4(2) -> 2
;; fib4(3) -> 0
;; fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
;; Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
;; >>> (fib4 5)
;; 4
;; >>> (fib4 6)
;; 8
;; >>> (fib4 7)
;; 14
(define (fib4 n)
  (define (fib4-helper n1 n2 n3 n4)
    (cond
      [(= n 0) n1]
      [(= n 1) n2]
      [(= n 2) n3]
      [(= n 3) n4]
      [else (fib4-helper n2 n3 n4 (+ n1 n2 n3 n4))]))
  (fib4-helper 0 0 2 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fib4))
    (check-equal? (candidate 5) 4)
    (check-equal? (candidate 8) 28)
    (check-equal? (candidate 10) 104)
    (check-equal? (candidate 12) 386)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter (+ i 1))
        (- i 1)))
  (largest_divisor_iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n divisor)
    (if (= (modulo n divisor) 0)
        (largest_divisor-iter n (+ divisor 1))
        (- divisor 1)))
  (largest_divisor-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (zero? (modulo n i))
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (divisor n m)
    (if (= (remainder n m) 0)
        m
        (divisor n (- m 1))))
  (divisor n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter (+ i 1))
        (- i 1)))
  (largest_divisor_iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter (+ i 1))
        (- i 1)))
  (largest_divisor_iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter (+ i 1))
        (- i 1)))
  (largest_divisor_iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter (+ i 1))
        (- i 1)))
  (largest_divisor_iter 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter n (- i 1))))
  (largest_divisor_iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter i)
    (if (= (remainder n i) 0)
        i
        (largest_divisor-iter (- i 1))))
  (largest_divisor-iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter n i)
    (if (= (modulo n i) 0)
        (largest_divisor_iter n (+ i 1))
        (- i 1)))
  (largest_divisor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor-iter n i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor-iter n (- i 1))))
  (largest_divisor-iter n (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (- n 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (largest_divisor_iter i)
    (if (= (modulo n i) 0)
        i
        (largest_divisor_iter (- i 1))))
  (largest_divisor_iter (/ n 2)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (iter sentence)
    (cond ((null? sentence) '())
          ((is-prime? (string-length (car sentence)))
           (cons (car sentence) (iter (cdr sentence))))
          (else (iter (cdr sentence)))))
  (string-join (iter (string-split sentence " ")) " "))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (word-lengths-are-prime? sentence)
    (define (iter words)
      (cond ((null? words) #t)
            ((is-prime? (string-length (car words)))
             (iter (cdr words)))
            (else #f)))
    (iter (string-split sentence)))
  (string-join (filter word-lengths-are-prime? (string-split sentence))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime? n)
    (define (is-prime-helper n i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (is-prime-helper n (+ i 1))]))
    (is-prime-helper n 2))
  (define (words-in-sentence-helper sentence result)
    (cond
      [(empty? sentence) result]
      [(is-prime? (string-length (first sentence)))
       (words-in-sentence-helper (rest sentence) (string-append result (first sentence) " "))]
      [else (words-in-sentence-helper (rest sentence) result)]))
  (words-in-sentence-helper (string-split sentence) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_143_words_in_sentence --------
#lang racket

;; You are given a string representing a sentence,
;; the sentence contains some words separated by a space,
;; and you have to return a string that contains the words from the original sentence,
;; whose lengths are prime numbers,
;; the order of the words in the new string should be the same as the original one.
;; Example 1:
;; >>> (words_in_sentence "This is a test")
;; "is"
;; Example 2:
;; >>> (words_in_sentence "lets go for swimming")
;; "go for"
;; Constraints:
;; * 1 <= len(sentence) <= 100
;; * sentence contains only letters
(define (words_in_sentence sentence)
  (define (is-prime n)
    (define (is-prime-iter n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (is-prime-iter n (+ i 1)))))
    (is-prime-iter n 2))
  (define (words-in-sentence-iter sentence result)
    (cond ((null? sentence) result)
          ((is-prime (string-length (car sentence)))
           (words-in-sentence-iter (cdr sentence) (string-append result " " (car sentence))))
          (else (words-in-sentence-iter (cdr sentence) result))))
  (words-in-sentence-iter (string-split sentence) ""))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate words_in_sentence))
    (check-equal? (candidate "This is a test") "is")
    (check-equal? (candidate "lets go for swimming") "go for")
    (check-equal? (candidate "there is no place available here") "there is no place")
    (check-equal? (candidate "Hi I am Hussein") "Hi am Hussein")
    (check-equal? (candidate "go for it") "go for it")
    (check-equal? (candidate "here") "")
    (check-equal? (candidate "here is") "is")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_iter n i)
    (cond
      [(= i n) #t]
      [(= i 0) (is_equal_to_sum_even_iter n (+ i 2))]
      [(= n i) #f]
      [else (or (is_equal_to_sum_even_iter (- n i) (+ i 2))
                (is_equal_to_sum_even_iter n (+ i 2)))]))
  (is_equal_to_sum_even_iter n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_iter n i)
    (cond ((= n 0) #t)
          ((= i n) #f)
          ((even? i) (or (is_equal_to_sum_even_iter (- n i) (+ i 2))
                         (is_equal_to_sum_even_iter n (+ i 2))))
          (else (is_equal_to_sum_even_iter n (+ i 2)))))
  (is_equal_to_sum_even_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even-iter n i)
    (cond
      [(= n (* i 4)) #t]
      [(> n (* i 4)) #f]
      [else (is_equal_to_sum_even-iter n (+ i 2))]))
  (is_equal_to_sum_even-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_iter n i)
    (cond ((= n 0) #t)
          ((= i n) #f)
          ((and (even? i) (is_equal_to_sum_even_iter (- n i) (+ i 2))) #t)
          (else (is_equal_to_sum_even_iter n (+ i 2)))))
  (is_equal_to_sum_even_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_helper n i)
    (cond
      [(= i n) #t]
      [(= i 0) (is_equal_to_sum_even_helper n (+ i 2))]
      [(= i n) #t]
      [else (or (is_equal_to_sum_even_helper (- n i) (+ i 2))
                (is_equal_to_sum_even_helper n (+ i 2)))]))
  (is_equal_to_sum_even_helper n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_helper n i)
    (cond
      [(= n 0) #t]
      [(= i n) #f]
      [(= 0 (modulo n i)) (is_equal_to_sum_even_helper (- n i) (+ i 2))]
      [else (is_equal_to_sum_even_helper n (+ i 2))]))
  (is_equal_to_sum_even_helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even-iter n i)
    (cond
      [(= n (* i 4)) #t]
      [(> n (* i 4)) #f]
      [else (is_equal_to_sum_even-iter n (+ i 2))]))
  (is_equal_to_sum_even-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_iter n sum count)
    (cond
      [(= n sum) (= count 4)]
      [(< n sum) #f]
      [else (or (is_equal_to_sum_even_iter n (+ sum 2) (+ count 1))
                (is_equal_to_sum_even_iter n sum count))]))
  (is_equal_to_sum_even_iter n 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_iter n sum count)
    (cond
      [(= n sum) (= count 4)]
      [(< n sum) #f]
      [else (or (is_equal_to_sum_even_iter n (+ sum 2) (+ count 1))
                (is_equal_to_sum_even_iter n sum count))]))
  (is_equal_to_sum_even_iter n 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even-iter n i)
    (cond
      [(= n (* i 4)) #t]
      [(> n (* i 4)) #f]
      [else (is_equal_to_sum_even-iter n (+ i 2))]))
  (is_equal_to_sum_even-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even-iter n i)
    (cond
      [(= n (* i 4)) #t]
      [(> n (* i 4)) #f]
      [else (is_equal_to_sum_even-iter n (+ i 2))]))
  (is_equal_to_sum_even-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_helper n i)
    (cond
      [(= i n) #t]
      [(= i 0) (is_equal_to_sum_even_helper n (+ i 2))]
      [else (or (is_equal_to_sum_even_helper (- n i) (+ i 2))
                (is_equal_to_sum_even_helper n (+ i 2)))]))
  (is_equal_to_sum_even_helper n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_138_is_equal_to_sum_even --------
#lang racket

;; Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
;; Example
;; >>> (is_equal_to_sum_even 4)
;; #f
;; >>> (is_equal_to_sum_even 6)
;; #f
;; >>> (is_equal_to_sum_even 8)
;; #t
(define (is_equal_to_sum_even n)
  (define (is_equal_to_sum_even_iter n count)
    (cond
      [(= n 0) (= count 4)]
      [(= n 2) (= count 3)]
      [(= n 4) (= count 2)]
      [(= n 6) (= count 1)]
      [(= n 8) (= count 0)]
      [else (or (is_equal_to_sum_even_iter (- n 2) (+ count 1))
                (is_equal_to_sum_even_iter (- n 4) (+ count 1))
                (is_equal_to_sum_even_iter (- n 6) (+ count 1))
                (is_equal_to_sum_even_iter (- n 8) (+ count 1)))]))
  (is_equal_to_sum_even_iter n 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_equal_to_sum_even))
    (check-equal? (candidate 4) #f)
    (check-equal? (candidate 6) #f)
    (check-equal? (candidate 8) #t)
    (check-equal? (candidate 10) #t)
    (check-equal? (candidate 11) #f)
    (check-equal? (candidate 12) #t)
    (check-equal? (candidate 13) #f)
    (check-equal? (candidate 16) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (cond ((= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (prime?-iter 3 n))))
  (define (prime?-iter i n)
    (cond ((> (* i i) n) #t)
          ((= (remainder n i) 0) #f)
          (else (prime?-iter (+ i 2) n))))
  (define (prime_fib-iter n i)
    (cond ((= n 1) 2)
          ((= n 2) 3)
          ((and (prime? i) (prime? (+ i (fib (- i 2)))))
           (prime_fib-iter (- n 1) (+ i 1)))
          (else (prime_fib-iter n (+ i 1)))))
  (prime_fib-iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (+ i 1)))))
    (prime? n 2))
  (define (prime_fib n i)
    (cond ((= n 1) 2)
          ((= n 2) 3)
          ((= n 3) 5)
          ((= n 4) 13)
          ((= n 5) 89)
          ((and (prime? i) (= (fib i) i)) (prime_fib (- n 1) (+ i 1)))
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (fib n)
    (define (iter i a b)
      (cond ((= i n) b)
            (else (iter (+ i 1) b (+ a b)))))
    (iter 0 0 1))
  (define (iter i)
    (cond ((= i n) (fib i))
          ((and (prime? (fib i)) (prime? (fib (+ i 1)))) (fib (+ i 1)))
          (else (iter (+ i 1)))))
  (iter 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime-helper n i)
      (if (= i 1)
          #t
          (if (= (remainder n i) 0)
              #f
              (prime-helper n (- i 1)))))
    (prime-helper n (floor (/ n 2))))
  (define (fib-helper n i)
    (if (= i n)
        (fib-helper n (- i 1))
        (if (prime? (fib-helper n (- i 1)))
            (fib-helper n (- i 1))
            (fib-helper n (- i 1)))))
  (fib-helper n n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (- n 1)))
  (define (prime_fib n i)
    (cond ((= n 1) i)
          ((and (prime? i) (= (fib n) i)) i)
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (prime? n)
    (define (prime?-iter n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime?-iter n (- i 1)))))
    (prime?-iter n (floor (/ n 2))))
  (define (fib-iter n a b)
    (cond ((= n 1) a)
          ((= n 2) b)
          (else (fib-iter (- n 1) b (+ a b)))))
  (define (prime-fib-iter n a b i)
    (cond ((= i n) (fib-iter n a b))
          ((prime? (fib-iter i a b)) (prime-fib-iter n a b (+ i 1)))
          (else (prime-fib-iter n a b (+ i 1)))))
  (prime-fib-iter n 1 1 3))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime-helper n d)
      (cond ((= d n) #t)
            ((= (remainder n d) 0) #f)
            (else (prime-helper n (+ d 1)))))
    (prime-helper n 2))
  (define (prime-fib-helper n i)
    (cond ((= n 1) 2)
          ((= n 2) 3)
          ((and (prime? (fib i)) (= n (- i 1))) (fib i))
          (else (prime-fib-helper n (+ i 1)))))
  (prime-fib-helper n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (+ i 1)))))
    (prime? n 2))
  (define (prime_fib n i)
    (cond ((= n 1) 2)
          ((prime? (fib i)) (prime_fib (- n 1) (+ i 1)))
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_39_prime_fib --------
#lang racket

;; prime_fib returns n-th number that is a Fibonacci number and it's also prime.
;; >>> (prime_fib 1)
;; 2
;; >>> (prime_fib 2)
;; 3
;; >>> (prime_fib 3)
;; 5
;; >>> (prime_fib 4)
;; 13
;; >>> (prime_fib 5)
;; 89
(define (prime_fib n)
  (define (fib n)
    (cond ((= n 1) 1)
          ((= n 2) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
  (define (prime? n)
    (define (prime? n i)
      (cond ((= i 1) #t)
            ((= (modulo n i) 0) #f)
            (else (prime? n (- i 1)))))
    (prime? n (floor (sqrt n))))
  (define (prime_fib n i)
    (cond ((= n 1) 2)
          ((= n 2) 3)
          ((and (prime? i) (= (fib n) i)) i)
          (else (prime_fib n (+ i 1)))))
  (prime_fib n 3))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_fib))
    (check-equal? (candidate 1) 2)
    (check-equal? (candidate 2) 3)
    (check-equal? (candidate 3) 5)
    (check-equal? (candidate 4) 13)
    (check-equal? (candidate 5) 89)
    (check-equal? (candidate 6) 233)
    (check-equal? (candidate 7) 1597)
    (check-equal? (candidate 8) 28657)
    (check-equal? (candidate 9) 514229)
    (check-equal? (candidate 10) 433494437)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_148_bf --------
#lang racket

;; There are eight planets in our solar system: the closerst to the Sun 
;; is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
;; Uranus, Neptune.
;; Write a function that takes two planet names as strings planet1 and planet2. 
;; The function should return a list containing all planets whose orbits are 
;; located between the orbit of planet1 and the orbit of planet2, sorted by 
;; the proximity to the sun. 
;; The function should return an empty list if planet1 or planet2
;; are not correct planet names. 
;; Examples
;; >>> (bf "Jupiter" "Neptune")
;; (list "Saturn" "Uranus")
;; >>> (bf "Earth" "Mercury")
;; "Venus"
;; >>> (bf "Mercury" "Uranus")
;; (list "Venus" "Earth" "Mars" "Jupiter" "Saturn")
(define (bf planet1 planet2)
  (cond
    [(or (not (string? planet1)) (not (string? planet2)) ) '()]
    [(string=? planet1 planet2) '()]
    [(string<? planet1 planet2) (bf planet1 planet2)]
    [(string<? planet2 planet1) (bf planet2 planet1)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate bf))
    (check-equal? (candidate "Jupiter" "Neptune") (list "Saturn" "Uranus"))
    (check-equal? (candidate "Earth" "Mercury") (list "Venus"))
    (check-equal? (candidate "Mercury" "Uranus") (list "Venus" "Earth" "Mars" "Jupiter" "Saturn"))
    (check-equal? (candidate "Neptune" "Venus") (list "Earth" "Mars" "Jupiter" "Saturn" "Uranus"))
    (check-equal? (candidate "Earth" "Earth") (list ))
    (check-equal? (candidate "Mars" "Earth") (list ))
    (check-equal? (candidate "Jupiter" "Makemake") (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_148_bf --------
#lang racket

;; There are eight planets in our solar system: the closerst to the Sun 
;; is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
;; Uranus, Neptune.
;; Write a function that takes two planet names as strings planet1 and planet2. 
;; The function should return a list containing all planets whose orbits are 
;; located between the orbit of planet1 and the orbit of planet2, sorted by 
;; the proximity to the sun. 
;; The function should return an empty list if planet1 or planet2
;; are not correct planet names. 
;; Examples
;; >>> (bf "Jupiter" "Neptune")
;; (list "Saturn" "Uranus")
;; >>> (bf "Earth" "Mercury")
;; "Venus"
;; >>> (bf "Mercury" "Uranus")
;; (list "Venus" "Earth" "Mars" "Jupiter" "Saturn")
(define (bf planet1 planet2)
  (cond
    [(or (not (string? planet1)) (not (string? planet2)) (not (member planet1 '("Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune"))) (not (member planet2 '("Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune")))) empty]
    [(string=? planet1 planet2) empty]
    [(member planet1 '("Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune")) (bf planet1 planet2)]
    [(member planet2 '("Mercury" "Venus" "Earth" "Mars" "Jupiter" "Saturn" "Uranus" "Neptune")) (bf planet1 planet2)]
    [else (bf planet1 planet2)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate bf))
    (check-equal? (candidate "Jupiter" "Neptune") (list "Saturn" "Uranus"))
    (check-equal? (candidate "Earth" "Mercury") (list "Venus"))
    (check-equal? (candidate "Mercury" "Uranus") (list "Venus" "Earth" "Mars" "Jupiter" "Saturn"))
    (check-equal? (candidate "Neptune" "Venus") (list "Earth" "Mars" "Jupiter" "Saturn" "Uranus"))
    (check-equal? (candidate "Earth" "Earth") (list ))
    (check-equal? (candidate "Mars" "Earth") (list ))
    (check-equal? (candidate "Jupiter" "Makemake") (list ))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_129_minPath --------
#lang racket

;; Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
;; each cell of the grid contains a value. Every integer in the range [1, N * N]
;; inclusive appears exactly once on the cells of the grid.
;; You have to find the minimum path of length k in the grid. You can start
;; from any cell, and in each step you can move to any of the neighbor cells,
;; in other words, you can go to cells which share an edge with you current
;; cell.
;; Please note that a path of length k means visiting exactly k cells (not
;; necessarily distinct).
;; You CANNOT go off the grid.
;; A path A (of length k) is considered less than a path B (of length k) if
;; after making the ordered lists of the values on the cells that A and B go
;; through (let's call them lst_A and lst_B), lst_A is lexicographically less
;; than lst_B, in other words, there exist an integer index i (1 <= i <= k)
;; such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
;; lst_A[j] = lst_B[j].
;; It is guaranteed that the answer is unique.
;; Return an ordered list of the values on the cells that the minimum path go through.
;; Examples:    
;; >>> (minPath (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3)
;; (list 1 2 1)
;; >>> (minPath (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1)
;; (list 1)
(define (minPath grid k)
  (define (minPath-helper grid k)
    (define (get-neighbors grid x y)
      (define (get-neighbors-helper grid x y neighbors)
        (cond
          [(and (< x (length grid)) (< y (length (car grid))))
           (get-neighbors-helper grid (+ x 1) y (cons (list x y) neighbors))]
          [(and (< x (length grid)) (> y 0))
           (get-neighbors-helper grid (+ x 1) (- y 1) (cons (list x y) neighbors))]
          [(and (> x 0) (< y (length (car grid))))
           (get-neighbors-helper grid (- x 1) (+ y 1) (cons (list x y) neighbors))]
          [(and (> x 0) (> y 0))
           (get-neighbors-helper grid (- x 1) (- y 1) (cons (list x y) neighbors))]
          [else neighbors]))
      (get-neighbors-helper grid 0 0 '()))
    (define (get-min-path grid k x y)
      (cond
        [(= k 0) '()]
        [(= k 1) (list (list-ref (list-ref grid x) y))]
        [else
         (let* ([neighbors (get-neighbors grid x y)]
                [min-path (apply min (map (lambda (n) (get-min-path grid (- k 1) (car n) (cadr n))) neighbors))]
                [min-path-value (list-ref (list-ref grid x) y)])
           (cons min-path-value min-path))]))
    (get-min-path grid k 0 0))
  (minPath-helper grid k))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minPath))
    (check-equal? (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) (list 1 2 1))
    (check-equal? (candidate (list (list 5 9 3) (list 4 1 6) (list 7 8 2)) 1) (list 1))
    (check-equal? (candidate (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)) 4) (list 1 2 1 2))
    (check-equal? (candidate (list (list 6 4 13 10) (list 5 7 12 1) (list 3 16 11 15) (list 8 14 9 2)) 7) (list 1 10 1 10 1 10 1))
    (check-equal? (candidate (list (list 8 14 9 2) (list 6 4 13 15) (list 5 7 1 12) (list 3 10 11 16)) 5) (list 1 7 1 7 1))
    (check-equal? (candidate (list (list 11 8 7 2) (list 5 16 14 4) (list 9 3 15 6) (list 12 13 10 1)) 9) (list 1 6 1 6 1 6 1 6 1))
    (check-equal? (candidate (list (list 12 13 10 1) (list 9 3 15 6) (list 5 16 14 4) (list 11 8 7 2)) 12) (list 1 6 1 6 1 6 1 6 1 6 1 6))
    (check-equal? (candidate (list (list 2 7 4) (list 3 1 5) (list 6 8 9)) 8) (list 1 3 1 3 1 3 1 3))
    (check-equal? (candidate (list (list 6 1 5) (list 3 8 9) (list 2 7 4)) 8) (list 1 5 1 5 1 5 1 5))
    (check-equal? (candidate (list (list 1 2) (list 3 4)) 10) (list 1 2 1 2 1 2 1 2 1 2))
    (check-equal? (candidate (list (list 1 3) (list 3 2)) 10) (list 1 3 1 3 1 3 1 3 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1)))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (tri n) (list (+ 1 (/ n 2))))
                  (cons (tri n) (list (+ (car (tri (- n 1))) (car (tri (- n 2))) (car (tri (+ n 1)))))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri (- n 1)) (list (+ 1 (/ n 2))))
                  (cons (tri (- n 1)) (list (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (cons (/ n 2) (tri (- n 1))))
                  (cons (tri n) (cons (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))) (tri (- n 1)))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) n)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (+ (list-ref (tri (- n 1)) (- n 1))
                                 (list-ref (tri (- n 2)) (- n 2))
                                 (list-ref (tri (+ n 1)) (+ n 1))))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (+ 1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (zero? n)
      (list 1)
      (if (zero? (modulo n 2))
          (cons (quotient n 2) (tri (- n 1)))
          (cons (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) n)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (quotient n 2) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (list (+ 1 (/ n 2))))
                  (cons (tri n) (list (+ (car (tri (- n 1))) (car (tri (- n 2))) (car (tri (+ n 1)))))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (zero? n)
      (list 1)
      (if (zero? (modulo n 2))
          (cons (quotient n 2) (tri (- n 1)))
          (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (+ n 1)) n))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (+ n 1)) n))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (round (/ (+ n 1) 2)) (tri (- n 1)))
                  (append (tri (- n 1)) (list (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      '()
      (cons (if (= n 1)
                3
                (if (even? n)
                    (+ 1 (/ n 2))
                    (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1)))))
            (tri (- n 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (+ n 1)) n))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) 0) (list-ref (tri (- n 2)) 0) (list-ref (tri (+ n 1)) 0)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (add1 (+ (list-ref (tri (- n 1)) (- n 1))
                                 (list-ref (tri (- n 2)) (- n 2))
                                 (list-ref (tri (+ n 1)) (+ n 1))))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri (- n 1)) (/ n 2))
                  (cons (tri (- n 1)) (+ (tri (- n 2)) (tri (- n 1)) (tri (+ n 1)))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      '()
      (cons (if (= n 1) 3 (if (even? n) (+ 1 (/ n 2)) (+ (tri (- n 1)) (tri (- n 2)) (tri (+ n 1)))))
            (tri (- n 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) n)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (zero? n)
      (list 1)
      (if (zero? (modulo n 2))
          (cons (quotient n 2) (tri (- n 1)))
          (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (tri n) (tri (- n 1)))
                  (cons (tri n) (tri (- n 1)))
                  )))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (+ 1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (+ n 1)) n))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (quotient (+ n 1) 2) (tri (- n 1)))
                  (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) n)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 2)) (- n 2))
                           (list-ref (tri (+ n 1)) (+ n 1)))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (round (/ (+ n 1) 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) n)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 1)) (- n 2)) (list-ref (tri (+ n 1)) n)) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (append (tri (- n 1)) (tri (- n 2)) (tri (+ n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (letrec ([tri-helper (lambda (n)
                         (if (zero? n)
                             '()
                             (cons (tri-rec n) (tri-helper (sub1 n)))))]
           [tri-rec (lambda (n)
                      (if (zero? n)
                          3
                          (if (even? n)
                              (add1 (quotient n 2))
                              (add1 (tri-rec (sub1 n)) (tri-rec (sub1 (sub1 n))) (tri-rec (add1 n))))))])
    (tri-helper n)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (remainder n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1)) (list-ref (tri (- n 2)) (- n 2)) (list-ref (tri (+ n 1)) (+ n 1))) (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_130_tri --------
#lang racket

;; Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
;; the last couple centuries. However, what people don't know is Tribonacci sequence.
;; Tribonacci sequence is defined by the recurrence:
;; tri(1) = 3
;; tri(n) = 1 + n / 2, if n is even.
;; tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
;; For example:
;; tri(2) = 1 + (2 / 2) = 2
;; tri(4) = 3
;; tri(3) = tri(2) + tri(1) + tri(4)
;; = 2 + 3 + 3 = 8 
;; You are given a non-negative integer number n, you have to a return a list of the 
;; first n + 1 numbers of the Tribonacci sequence.
;; Examples:
;; >>> (tri 3)
;; (list 1 3 2 8)
(define (tri n)
  (if (= n 0)
      (list 1)
      (if (= n 1)
          (list 1 3)
          (if (= n 2)
              (list 1 3 2)
              (if (= (modulo n 2) 0)
                  (cons (add1 (/ n 2)) (tri (- n 1)))
                  (cons (+ (list-ref (tri (- n 1)) (- n 1))
                           (list-ref (tri (- n 1)) (- n 2))
                           (list-ref (tri (+ n 1)) n))
                        (tri (- n 1))))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate tri))
    (check-equal? (candidate 3) (list 1 3 2 8))
    (check-equal? (candidate 4) (list 1 3 2 8 3))
    (check-equal? (candidate 5) (list 1 3 2 8 3 15))
    (check-equal? (candidate 6) (list 1 3 2 8 3 15 4))
    (check-equal? (candidate 7) (list 1 3 2 8 3 15 4 24))
    (check-equal? (candidate 8) (list 1 3 2 8 3 15 4 24 5))
    (check-equal? (candidate 9) (list 1 3 2 8 3 15 4 24 5 35))
    (check-equal? (candidate 20) (list 1 3 2 8 3 15 4 24 5 35 6 48 7 63 8 80 9 99 10 120 11))
    (check-equal? (candidate 0) (list 1))
    (check-equal? (candidate 1) (list 1 3))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_59_largest_prime_factor --------
#lang racket

;; Return the largest prime factor of n. Assume n > 1 and is not a prime.
;; >>> (largest_prime_factor 13195)
;; 29
;; >>> (largest_prime_factor 2048)
;; 2
(define (largest_prime_factor n)
  (define (prime? n)
    (define (prime-helper n i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (prime-helper n (+ i 1)))))
    (prime-helper n 2))
  (define (largest-prime-factor-helper n i)
    (cond ((= i n) n)
          ((and (= (remainder n i) 0) (prime? i)) (largest-prime-factor-helper n i))
          (else (largest-prime-factor-helper n (+ i 1)))))
  (largest-prime-factor-helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_prime_factor))
    (check-equal? (candidate 15) 5)
    (check-equal? (candidate 27) 3)
    (check-equal? (candidate 63) 7)
    (check-equal? (candidate 330) 11)
    (check-equal? (candidate 13195) 29)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_59_largest_prime_factor --------
#lang racket

;; Return the largest prime factor of n. Assume n > 1 and is not a prime.
;; >>> (largest_prime_factor 13195)
;; 29
;; >>> (largest_prime_factor 2048)
;; 2
(define (largest_prime_factor n)
  (define (largest_prime_factor_iter n i)
    (if (= n i)
        (largest_prime_factor_iter n (+ i 1))
        (if (= (remainder n i) 0)
            (largest_prime_factor_iter (/ n i) i)
            (largest_prime_factor_iter n (+ i 1)))))
  (largest_prime_factor_iter n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_prime_factor))
    (check-equal? (candidate 15) 5)
    (check-equal? (candidate 27) 3)
    (check-equal? (candidate 63) 7)
    (check-equal? (candidate 330) 11)
    (check-equal? (candidate 13195) 29)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_59_largest_prime_factor --------
#lang racket

;; Return the largest prime factor of n. Assume n > 1 and is not a prime.
;; >>> (largest_prime_factor 13195)
;; 29
;; >>> (largest_prime_factor 2048)
;; 2
(define (largest_prime_factor n)
  (define (prime? n)
    (define (loop i)
      (cond ((> i (sqrt n)) #t)
            ((zero? (modulo n i)) #f)
            (else (loop (+ i 1)))))
    (loop 2))
  (define (loop i)
    (cond ((> i (sqrt n)) n)
          ((and (zero? (modulo n i)) (prime? i)) (loop i))
          (else (loop (+ i 1)))))
  (loop 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_prime_factor))
    (check-equal? (candidate 15) 5)
    (check-equal? (candidate 27) 3)
    (check-equal? (candidate 63) 7)
    (check-equal? (candidate 330) 11)
    (check-equal? (candidate 13195) 29)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_107_even_odd_palindrome --------
#lang racket

;; Given a positive integer n, return a list that has the number of even and odd
;; integer palindromes that fall within the range(1, n), inclusive.
;; Example 1:
;; >>> (even_odd_palindrome 3)
;; (list 1 2)
;; Explanation:
;; Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
;; Example 2:
;; >>> (even_odd_palindrome 12)
;; (list 4 6)
;; Explanation:
;; Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
;; Note:
;; 1. 1 <= n <= 10^3
;; 2. returned list has the number of even and odd integer palindromes respectively.
(define (even_odd_palindrome n)
  (define (is_palindrome? n)
    (define (reverse-number n)
      (define (reverse-number-helper n acc)
        (if (zero? n)
            acc
            (reverse-number-helper (quotient n 10) (+ (* acc 10) (remainder n 10)))))
      (reverse-number-helper n 0))
    (equal? n (reverse-number n)))
  (define (is_even? n)
    (zero? (remainder n 2)))
  (define (count-even-odd-palindrome n)
    (define (count-even-odd-palindrome-helper n acc-even acc-odd)
      (if (is_palindrome? n)
          (if (is_even? n)
              (count-even-odd-palindrome-helper (- n 1) (+ acc-even 1) acc-odd)
              (count-even-odd-palindrome-helper (- n 1) acc-even (+ acc-odd 1)))
          (count-even-odd-palindrome-helper (- n 1) acc-even acc-odd)))
    (count-even-odd-palindrome-helper n 0 0))
  (count-even-odd-palindrome n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_palindrome))
    (check-equal? (candidate 123) (list 8 13))
    (check-equal? (candidate 12) (list 4 6))
    (check-equal? (candidate 3) (list 1 2))
    (check-equal? (candidate 63) (list 6 8))
    (check-equal? (candidate 25) (list 5 6))
    (check-equal? (candidate 19) (list 4 6))
    (check-equal? (candidate 9) (list 4 5))
    (check-equal? (candidate 1) (list 0 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_107_even_odd_palindrome --------
#lang racket

;; Given a positive integer n, return a list that has the number of even and odd
;; integer palindromes that fall within the range(1, n), inclusive.
;; Example 1:
;; >>> (even_odd_palindrome 3)
;; (list 1 2)
;; Explanation:
;; Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
;; Example 2:
;; >>> (even_odd_palindrome 12)
;; (list 4 6)
;; Explanation:
;; Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
;; Note:
;; 1. 1 <= n <= 10^3
;; 2. returned list has the number of even and odd integer palindromes respectively.
(define (even_odd_palindrome n)
  (define (is_palindrome? n)
    (define (helper n rev)
      (if (zero? n)
          rev
          (helper (quotient n 10) (+ (* rev 10) (remainder n 10)))))
    (define (is_even? n)
      (zero? (remainder n 2)))
    (define (is_odd? n)
      (not (is_even? n)))
    (define (is_palindrome_even? n)
      (and (is_even? n)
           (= n (helper n 0))))
    (define (is_palindrome_odd? n)
      (and (is_odd? n)
           (= n (helper n 0))))
    (list (length (filter is_palindrome_even? (range 1 n)))
          (length (filter is_palindrome_odd? (range 1 n)))))
  (even_odd_palindrome n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_palindrome))
    (check-equal? (candidate 123) (list 8 13))
    (check-equal? (candidate 12) (list 4 6))
    (check-equal? (candidate 3) (list 1 2))
    (check-equal? (candidate 63) (list 6 8))
    (check-equal? (candidate 25) (list 5 6))
    (check-equal? (candidate 19) (list 4 6))
    (check-equal? (candidate 9) (list 4 5))
    (check-equal? (candidate 1) (list 0 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_107_even_odd_palindrome --------
#lang racket

;; Given a positive integer n, return a list that has the number of even and odd
;; integer palindromes that fall within the range(1, n), inclusive.
;; Example 1:
;; >>> (even_odd_palindrome 3)
;; (list 1 2)
;; Explanation:
;; Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
;; Example 2:
;; >>> (even_odd_palindrome 12)
;; (list 4 6)
;; Explanation:
;; Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
;; Note:
;; 1. 1 <= n <= 10^3
;; 2. returned list has the number of even and odd integer palindromes respectively.
(define (even_odd_palindrome n)
  (define (is_palindrome n)
    (define (helper n rev)
      (if (zero? n)
          rev
          (helper (quotient n 10) (+ (* rev 10) (remainder n 10)))))
    (define (is_even n)
      (if (zero? (remainder n 2))
          #t
          #f))
    (if (is_even n)
        (list (helper n 0) (helper n 0))
        (list (helper n 0) (helper n 0))))
  (define (helper n)
    (if (zero? n)
        (list 0 0)
        (let ((p (is_palindrome n)))
          (if (equal? (car p) (cadr p))
              (list (+ 1 (car (helper (- n 1)))) (cadr (helper (- n 1))))
              (list (car (helper (- n 1))) (+ 1 (cadr (helper (- n 1)))))))))
  (helper n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_palindrome))
    (check-equal? (candidate 123) (list 8 13))
    (check-equal? (candidate 12) (list 4 6))
    (check-equal? (candidate 3) (list 1 2))
    (check-equal? (candidate 63) (list 6 8))
    (check-equal? (candidate 25) (list 5 6))
    (check-equal? (candidate 19) (list 4 6))
    (check-equal? (candidate 9) (list 4 5))
    (check-equal? (candidate 1) (list 0 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_107_even_odd_palindrome --------
#lang racket

;; Given a positive integer n, return a list that has the number of even and odd
;; integer palindromes that fall within the range(1, n), inclusive.
;; Example 1:
;; >>> (even_odd_palindrome 3)
;; (list 1 2)
;; Explanation:
;; Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
;; Example 2:
;; >>> (even_odd_palindrome 12)
;; (list 4 6)
;; Explanation:
;; Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
;; Note:
;; 1. 1 <= n <= 10^3
;; 2. returned list has the number of even and odd integer palindromes respectively.
(define (even_odd_palindrome n)
  (define (is_palindrome? n)
    (define (helper n1 n2)
      (if (< n1 n2)
          #t
          (and (equal? (modulo n1 10) (modulo n2 10))
               (helper (quotient n1 10) (quotient n2 10)))))
    (helper n (reverse-number n)))
  (define (reverse-number n)
    (define (helper n1 n2)
      (if (zero? n1)
          n2
          (helper (quotient n1 10) (+ (* n2 10) (modulo n1 10)))))
    (helper n 0))
  (define (even_odd_palindrome_helper n even odd)
    (if (zero? n)
        (list even odd)
        (if (is_palindrome? n)
            (if (even? n)
                (even_odd_palindrome_helper (- n 1) (+ even 1) odd)
                (even_odd_palindrome_helper (- n 1) even (+ odd 1)))
            (even_odd_palindrome_helper (- n 1) even odd))))
  (even_odd_palindrome_helper n 0 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate even_odd_palindrome))
    (check-equal? (candidate 123) (list 8 13))
    (check-equal? (candidate 12) (list 4 6))
    (check-equal? (candidate 3) (list 1 2))
    (check-equal? (candidate 63) (list 6 8))
    (check-equal? (candidate 25) (list 5 6))
    (check-equal? (candidate 19) (list 4 6))
    (check-equal? (candidate 9) (list 4 5))
    (check-equal? (candidate 1) (list 0 1))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (define (iter lst max)
    (cond ((null? lst) (sum-digits max))
          ((and (is-prime (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) max))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (prime-list lst)
    (cond ((null? lst) '())
          ((is-prime? (car lst)) (cons (car lst) (prime-list (cdr lst))))
          (else (prime-list (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (sum-digits (apply max (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (define (sum-digits n)
    (cond
      [(< n 10) n]
      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (prime-digits n)
    (define (iter i)
      (cond ((= i 0) '())
            ((is-prime? i) (cons i (iter (- i 1))))
            (else (iter (- i 1)))))
    (iter n))
  (define (sum-digits n)
    (define (iter i)
      (cond ((= i 0) 0)
            (else (+ (modulo i 10) (iter (/ i 10))))))
    (iter n))
  (define (sum-primes lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (+ (car lst) (sum-primes (cdr lst))))
          (else (sum-primes (cdr lst)))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (prime-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (remainder n 10) (prime-digits (quotient n 10)))]))
  (define (iter lst max)
    (cond
      [(empty? lst) max]
      [(and (is-prime? (first lst))
            (> (prime-digits (first lst)) max))
       (iter (rest lst) (prime-digits (first lst)))]
      [else (iter (rest lst) max)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (max-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max (car lst) (max-prime (cdr lst)))]
      [else (max-prime (cdr lst))]))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((and (is-prime (car lst))
                (> (car lst) acc))
           (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (find-largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (car lst) (find-largest-prime (cdr lst))))
          (else (find-largest-prime (cdr lst)))))
  (sum-digits (find-largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((and (is-prime (car lst))
                (> (car lst) acc))
           (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime (car lst)) (max (car lst) (largest-prime (cdr lst)))]
      [else (largest-prime (cdr lst))]))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(and (is-prime? (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) acc)]))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter i)
      (cond ((= i 0) 0)
            (else (+ (remainder i 10) (iter (quotient i 10))))))
    (iter n))
  (define (largest-prime lst)
    (define (iter lst)
      (cond ((null? lst) 0)
            ((is-prime (car lst)) (max (car lst) (iter (cdr lst))))
            (else (iter (cdr lst)))))
    (iter lst))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((and (is-prime (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n sum)
      (cond
        [(= n 0) sum]
        [else (iter (quotient n 10) (+ sum (remainder n 10)))]))
    (iter n 0))
  (define (max-prime lst)
    (cond
      [(null? lst) 0]
      [(is-prime? (car lst)) (max-prime (cdr lst))]
      [else (max (car lst) (max-prime (cdr lst)))]))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter s n)
      (cond ((= n 0) s)
            (else (iter (+ s (remainder n 10)) (/ n 10)))))
    (iter 0 n))
  (define (iter lst max)
    (cond ((null? lst) (sum-digits max))
          ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) max))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))
  (define (iter lst max)
    (cond
      [(null? lst) (sum-digits max)]
      [(and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) max)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (if (= i n) #t
          (if (= (remainder n i) 0) #f
              (iter (+ i 1)))))
    (iter 2))
  (define (prime-lst lst)
    (cond ((null? lst) '())
          ((is-prime? (car lst)) (cons (car lst) (prime-lst (cdr lst))))
          (else (prime-lst (cdr lst)))))
  (define (max-prime lst)
    (cond ((null? (cdr lst)) (car lst))
          ((> (car lst) (car (cdr lst))) (max-prime (cons (car lst) (cddr lst))))
          (else (max-prime (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (sum-digits (max-prime (prime-lst lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter s n)
      (cond ((= n 0) s)
            (else (iter (+ s (remainder n 10)) (/ n 10)))))
    (iter 0 n))
  (define (largest-prime lst)
    (define (iter lst max)
      (cond ((null? lst) max)
            ((and (is-prime (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) max))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond
        [(null? lst) acc]
        [(and (is-prime (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst))]
        [else (iter (cdr lst) acc)]))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((and (is-prime? (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond
        [(null? lst) acc]
        [(is-prime? (car lst)) (iter (cdr lst) (car lst))]
        [else (iter (cdr lst) acc)]))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n sum)
      (cond ((= n 0) sum)
            (else (iter (quotient n 10) (+ sum (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst max)
      (cond ((null? lst) max)
            ((and (is-prime (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) max))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (isPrime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sumDigits n)
    (cond
      [(= n 0) 0]
      [else (+ (modulo n 10) (sumDigits (quotient n 10)))]))
  (define (largestPrime lst)
    (cond
      [(null? lst) 0]
      [(isPrime (car lst)) (max (car lst) (largestPrime (cdr lst)))]
      [else (largestPrime (cdr lst))]))
  (sumDigits (largestPrime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (prime-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (prime-digits (quotient n 10))))))
  (define (iter lst largest)
    (cond ((null? lst) (prime-digits largest))
          ((and (is-prime? (car lst)) (> (car lst) largest))
           (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) largest))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(and (is-prime? (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) acc)]))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n sum)
      (cond ((= n 0) sum)
            (else (iter (quotient n 10) (+ sum (remainder n 10))))))
    (iter n 0))
  (define (iter lst max)
    (cond ((null? lst) (sum-digits max))
          ((and (is-prime (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) max))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((is-prime (car lst)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (if (= i n) #t
          (if (= (remainder n i) 0) #f
              (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n s)
      (if (= n 0) s
          (iter (quotient n 10) (+ s (remainder n 10)))))
    (iter n 0))
  (define (iter lst max)
    (if (null? lst) max
        (if (and (is-prime? (car lst)) (> (car lst) max))
            (iter (cdr lst) (car lst))
            (iter (cdr lst) max))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (if (= n 0)
          acc
          (iter (quotient n 10) (+ acc (remainder n 10)))))
    (iter n 0))
  (define (iter lst acc)
    (if (null? lst)
        acc
        (if (is-prime? (car lst))
            (iter (cdr lst) (sum-digits (car lst)))
            (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime-in-list lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((and (is-prime? (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime-in-list lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n sum)
      (cond ((= n 0) sum)
            (else (iter (quotient n 10) (+ sum (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst largest)
      (cond ((null? lst) largest)
            ((and (is-prime? (car lst))
                  (> (car lst) largest))
             (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) largest))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (prime-list lst)
    (cond
      [(empty? lst) empty]
      [(is-prime? (first lst)) (cons (first lst) (prime-list (rest lst)))]
      [else (prime-list (rest lst))]))
  (define (largest-prime lst)
    (cond
      [(empty? lst) 0]
      [(> (first lst) (largest-prime (rest lst))) (first lst)]
      [else (largest-prime (rest lst))]))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))
  (sum-digits (largest-prime (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst))))
          (else (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter i)
      (cond ((= i 0) 0)
            (else (+ (remainder i 10) (iter (quotient i 10))))))
    (iter n))
  (define (max-prime lst)
    (define (iter lst max)
      (cond ((null? lst) max)
            ((and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) max))))
    (iter lst 0))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (prime-list lst)
    (cond
      [(null? lst) '()]
      [(is-prime? (car lst)) (cons (car lst) (prime-list (cdr lst)))]
      [else (prime-list (cdr lst))]))
  (define (max-prime lst)
    (cond
      [(null? lst) 0]
      [(null? (cdr lst)) (car lst)]
      [(> (car lst) (car (cdr lst))) (max-prime (cons (car lst) (cdr (cdr lst))))]
      [else (max-prime (cdr lst))]))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))
  (sum-digits (max-prime (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (prime-lst lst)
    (cond ((null? lst) '())
          ((is-prime (car lst)) (cons (car lst) (prime-lst (cdr lst))))
          (else (prime-lst (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (sum-digits (apply max (prime-lst lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((and (is-prime (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
            ((and (is-prime? (car lst)) (> (car lst) acc)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (define (iter lst acc)
      (cond ((null? lst) acc)
            ((is-prime (car lst)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) acc))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter i)
      (cond
        [(= i 0) 0]
        [else (+ (remainder i 10) (iter (quotient i 10)))]))
    (iter n))
  (define (iter lst max)
    (cond
      [(null? lst) (sum-digits max)]
      [(and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) max)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n sum)
      (cond ((= n 0) sum)
            (else (iter (quotient n 10) (+ sum (remainder n 10))))))
    (iter n 0))
  (define (max-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max-prime (cdr lst)))
          (else (max (car lst) (max-prime (cdr lst))))))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (max-prime lst)
    (define (iter lst max)
      (cond ((null? lst) max)
            ((and (is-prime (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) max))))
    (iter lst 0))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (sum-digits n)
    (if (= n 0)
        0
        (+ (modulo n 10) (sum-digits (quotient n 10)))))
  (define (is-prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (modulo n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (define (largest-prime lst)
    (define (iter lst largest)
      (if (null? lst)
          largest
          (if (and (is-prime? (car lst)) (> (car lst) largest))
              (iter (cdr lst) (car lst))
              (iter (cdr lst) largest))))
    (iter lst 0))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
          ((is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst))))
          (else (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (prime-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (prime-digits (quotient n 10))))))
  (define (iter lst max)
    (cond ((null? lst) max)
          ((is-prime? (car lst)) (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) max))))
  (prime-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (helper i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (helper (+ i 1))]))
    (helper 2))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))
  (define (helper lst)
    (cond
      [(null? lst) 0]
      [(is-prime (car lst)) (max (car lst) (helper (cdr lst)))]
      [else (helper (cdr lst))]))
  (sum-digits (helper lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (define (iter lst largest)
    (cond ((null? lst) (sum-digits largest))
          ((and (is-prime? (car lst)) (> (car lst) largest))
           (iter (cdr lst) (car lst)))
          (else (iter (cdr lst) largest))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((is-prime (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(empty? lst) acc]
      [(is-prime (car lst)) (iter (cdr lst) (car lst))]
      [else (iter (cdr lst) acc)]))
  (sum-digits (iter lst 0)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (max-prime lst)
    (define (iter lst max)
      (cond ((null? lst) max)
            ((and (is-prime? (car lst)) (> (car lst) max)) (iter (cdr lst) (car lst)))
            (else (iter (cdr lst) max))))
    (iter lst 0))
  (sum-digits (max-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond
        [(= n 0) acc]
        [else (iter (quotient n 10) (+ acc (remainder n 10)))]))
    (iter n 0))
  (define (iter lst acc)
    (cond
      [(null? lst) acc]
      [(is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst)))]
      [else (iter (cdr lst) acc)]))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (prime-list lst)
    (cond ((null? lst) '())
          ((is-prime? (car lst)) (cons (car lst) (prime-list (cdr lst))))
          (else (prime-list (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))
  (sum-digits (apply max (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (sum-digits n)
    (define (iter n acc)
      (cond ((= n 0) acc)
            (else (iter (quotient n 10) (+ acc (remainder n 10))))))
    (iter n 0))
  (define (iter lst acc)
    (cond ((null? lst) acc)
            ((is-prime? (car lst)) (iter (cdr lst) (sum-digits (car lst))))
            (else (iter (cdr lst) acc))))
  (iter lst 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (remainder n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (define (largest-prime lst)
    (cond ((null? lst) 0)
          ((prime? (car lst)) (max (car lst) (largest-prime (cdr lst))))
          (else (largest-prime (cdr lst)))))
  (define (sum-digits n)
    (cond ((= n 0) 0)
          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))
  (sum-digits (largest-prime lst)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_94_skjkasdkd --------
#lang racket

;; You are given a list of integers.
;; You need to find the largest prime value and return the sum of its digits.
;; Examples:
;; >>> (skjkasdkd (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3))
;; 10
;; >>> (skjkasdkd (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1))
;; 25
;; >>> (skjkasdkd (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3))
;; 13
;; >>> (skjkasdkd (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6))
;; 11
;; >>> (skjkasdkd (list 0 81 12 3 1 21))
;; 3
;; >>> (skjkasdkd (list 0 8 1 2 1 7))
;; 7
(define (skjkasdkd lst)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (remainder n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (define (prime-list lst)
    (cond
      [(null? lst) '()]
      [(is-prime? (car lst)) (cons (car lst) (prime-list (cdr lst)))]
      [else (prime-list (cdr lst))]))
  (define (largest-prime lst)
    (cond
      [(null? lst) 0]
      [(null? (cdr lst)) (car lst)]
      [else (max (car lst) (largest-prime (cdr lst)))]))
  (define (sum-digits n)
    (cond
      [(= n 0) 0]
      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))
  (sum-digits (largest-prime (prime-list lst))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate skjkasdkd))
    (check-equal? (candidate (list 0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3)) 10)
    (check-equal? (candidate (list 1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1)) 25)
    (check-equal? (candidate (list 1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3)) 13)
    (check-equal? (candidate (list 0 724 32 71 99 32 6 0 5 91 83 0 5 6)) 11)
    (check-equal? (candidate (list 0 81 12 3 1 21)) 3)
    (check-equal? (candidate (list 0 8 1 2 1 7)) 7)
    (check-equal? (candidate (list 8191)) 19)
    (check-equal? (candidate (list 8191 123456 127 7)) 19)
    (check-equal? (candidate (list 127 97 8192)) 10)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_110_exchange --------
#lang racket

;; In this problem, you will implement a function that takes two lists of numbers,
;; and determines whether it is possible to perform an exchange of elements
;; between them to make lst1 a list of only even numbers.
;; There is no limit on the number of exchanged elements between lst1 and lst2.
;; If it is possible to exchange elements between the lst1 and lst2 to make
;; all the elements of lst1 to be even, return "YES".
;; Otherwise, return "NO".
;; For example:
;; >>> (exchange (list 1 2 3 4) (list 1 2 3 4))
;; "YES"
;; >>> (exchange (list 1 2 3 4) (list 1 5 3 4))
;; "NO"
;; It is assumed that the input lists will be non-empty.
(define (exchange lst1 lst2)
  (cond
    [(empty? lst1) "YES"]
    [(and (even? (first lst1)) (empty? lst2)) "NO"]
    [(and (even? (first lst1)) (even? (first lst2))) (exchange (rest lst1) (rest lst2))]
    [(and (odd? (first lst1)) (even? (first lst2))) (exchange (rest lst1) (rest lst2))]
    [(and (odd? (first lst1)) (odd? (first lst2))) (exchange (cons (first lst2) (rest lst1)) (cons (first lst1) (rest lst2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate exchange))
    (check-equal? (candidate (list 1 2 3 4) (list 1 2 3 4)) "YES")
    (check-equal? (candidate (list 1 2 3 4) (list 1 5 3 4)) "NO")
    (check-equal? (candidate (list 1 2 3 4) (list 2 1 4 3)) "YES")
    (check-equal? (candidate (list 5 7 3) (list 2 6 4)) "YES")
    (check-equal? (candidate (list 5 7 3) (list 2 6 3)) "NO")
    (check-equal? (candidate (list 3 2 6 1 8 9) (list 3 5 5 1 1 1)) "NO")
    (check-equal? (candidate (list 100 200) (list 200 200)) "YES")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is_prime n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (is_prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (if (= i n)
          #t
          (if (= (remainder n i) 0)
              #f
              (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (is-prime n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (is-prime (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond
        [(= i n) #t]
        [(= (modulo n i) 0) #f]
        [else (iter (+ i 1))]))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_82_prime_length --------
#lang racket

;; Write a function that takes a string and returns #t if the string
;; length is a prime number or #f otherwise
;; Examples
;; >>> (prime_length "Hello")
;; #t
;; >>> (prime_length "abcdcba")
;; #t
;; >>> (prime_length "kittens")
;; #t
;; >>> (prime_length "orange")
;; #f
(define (prime_length string)
  (define (prime? n)
    (define (iter i)
      (cond ((= i n) #t)
            ((= (modulo n i) 0) #f)
            (else (iter (+ i 1)))))
    (iter 2))
  (prime? (string-length string)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate prime_length))
    (check-equal? (candidate "Hello") #t)
    (check-equal? (candidate "abcdcba") #t)
    (check-equal? (candidate "kittens") #t)
    (check-equal? (candidate "orange") #f)
    (check-equal? (candidate "wow") #t)
    (check-equal? (candidate "world") #t)
    (check-equal? (candidate "MadaM") #t)
    (check-equal? (candidate "Wow") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "HI") #t)
    (check-equal? (candidate "go") #t)
    (check-equal? (candidate "gogo") #f)
    (check-equal? (candidate "aaaaaaaaaaaaaaa") #f)
    (check-equal? (candidate "Madam") #t)
    (check-equal? (candidate "M") #f)
    (check-equal? (candidate "0") #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate_number_iter number acc)
    (cond
      [(= number 0) acc]
      [(< number 1) (truncate_number_iter (- number 1) (+ acc 1))]
      [else (truncate_number_iter (/ number 10) (* acc 10))]))
  (/ (truncate_number_iter number 0) (truncate_number_iter number 1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (floor number))))
  (define (truncate-helper2 number)
    (if (integer? number)
        0
        (truncate-helper2 (- number (floor number)))))
  (truncate-helper2 (- number (truncate-helper number))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (sub1 number))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate_number_iter number)
    (if (integer? number)
        0
        (truncate_number_iter (- number 1))))
  (- number (truncate_number_iter number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate_number_helper number)
    (if (integer? number)
        0
        (truncate_number_helper (- number 1))))
  (- number (truncate_number_helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (zero? (floor number))
        (truncate-helper (* number 10))
        (number)))
  (define (truncate-helper-2 number)
    (if (zero? (floor number))
        (truncate-helper-2 (/ number 10))
        (number)))
  (truncate-helper-2 (- number (floor number))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (sub1 number))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (not (integer? number))
        (truncate-helper (floor number))
        (truncate-helper (- number (floor number)))))
  (truncate-helper number))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (integer? number)
        0
        (truncate-helper (- number 1))))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number decimals)
    (if (< number 1)
        decimals
        (truncate-helper (floor number) (+ decimals (* (- number (floor number)) 10)))))
  (truncate-helper number 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_77_iscube --------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (cond
    [(= a 0) #t]
    [(< a 0) (iscube (- a))]
    [else (define (iter n)
            (cond
              [(= n a) #t]
              [(> n a) #f]
              [else (iter (* n n n))]))
          (iter 1)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-equal? (candidate 1) #t)
    (check-equal? (candidate 2) #f)
    (check-equal? (candidate -1) #t)
    (check-equal? (candidate 64) #t)
    (check-equal? (candidate 180) #f)
    (check-equal? (candidate 1000) #t)
    (check-equal? (candidate 0) #t)
    (check-equal? (candidate 1729) #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_77_iscube --------
#lang racket

;; Write a function that takes an integer a and returns #t 
;; if this ingeger is a cube of some integer number.
;; Note: you may assume the input is always valid.
;; Examples:
;; >>> (iscube 1)
;; #t
;; >>> (iscube 2)
;; #f
;; >>> (iscube -1)
;; #t
;; >>> (iscube 64)
;; #t
;; >>> (iscube 0)
;; #t
;; >>> (iscube 180)
;; #f
(define (iscube a)
  (cond
    [(= a 0) #t]
    [(< a 0) (iscube (- a))]
    [else (define (iter i)
            (cond
              [(= i a) #t]
              [(> i a) #f]
              [else (iter (* i i i))]))
          (iter 1)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate iscube))
    (check-equal? (candidate 1) #t)
    (check-equal? (candidate 2) #f)
    (check-equal? (candidate -1) #t)
    (check-equal? (candidate 64) #t)
    (check-equal? (candidate 180) #f)
    (check-equal? (candidate 1000) #t)
    (check-equal? (candidate 0) #t)
    (check-equal? (candidate 1729) #f)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (str) (string-prefix? prefix str)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (str) (string-prefix? prefix str)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (cond
    [(empty? strings) (list)]
    [(string-prefix? prefix (first strings))
     (cons (first strings) (filter_by_prefix (rest strings) prefix))]
    [else (filter_by_prefix (rest strings) prefix)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (str) (string-prefix? prefix str)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (string) (string-prefix? prefix string)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (string) (string-prefix? prefix string)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (string) (string-prefix? prefix string)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (str) (string-prefix? prefix str)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (string) (string-prefix? prefix string)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (string) (string-prefix? prefix string)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (string) (string-prefix? prefix string)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (str) (string-prefix? prefix str)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (str) (string-prefix? prefix str)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (cond
    [(empty? strings) (list)]
    [(string-prefix? prefix (first strings))
     (cons (first strings) (filter_by_prefix (rest strings) prefix))]
    [else (filter_by_prefix (rest strings) prefix)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (x) (string-prefix? prefix x)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_29_filter_by_prefix --------
#lang racket

;; Filter an input list of strings only for ones that start with a given prefix.
;; >>> (filter_by_prefix (list ) "a")
;; (list )
;; >>> (filter_by_prefix (list "abc" "bcd" "cde" "array") "a")
;; (list "abc" "array")
(define (filter_by_prefix strings prefix)
  (filter (lambda (s) (string-prefix? prefix s)) strings))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate filter_by_prefix))
    (check-equal? (candidate (list ) "john") (list ))
    (check-equal? (candidate (list "xxx" "asd" "xxy" "john doe" "xxxAAA" "xxx") "xxx") (list "xxx" "xxxAAA" "xxx"))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (reverse-digits x)
    (define (reverse-digits-iter x acc)
      (if (zero? x)
          acc
          (reverse-digits-iter (quotient x 10) (+ (* 10 acc) (remainder x 10)))))
    (reverse-digits-iter x 0))
  (define (shift-digits x shift)
    (define (shift-digits-iter x shift acc)
      (if (zero? x)
          acc
          (shift-digits-iter (quotient x 10) shift (+ (* 10 acc) (remainder x 10)))))
    (shift-digits-iter x shift 0))
  (define (digits x)
    (define (digits-iter x acc)
      (if (zero? x)
          acc
          (digits-iter (quotient x 10) (+ 1 acc))))
    (digits-iter x 0))
  (define (number->string x)
    (number->string x))
  (number->string (if (> shift (digits x))
                      (reverse-digits x)
                      (shift-digits x shift))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (cond
    [(empty? lst) "Yes"]
    [(empty? (cdr lst)) "Yes"]
    [(and (equal? (car lst) ")") (equal? (cadr lst) ")")) "No"]
    [(and (equal? (car lst) "(") (equal? (cadr lst) ")")) (match_parens (cdr lst))]
    [(and (equal? (car lst) "(") (equal? (cadr lst) "(")) (match_parens (append (cdr lst) (list (car lst))))]
    [else (match_parens (append (cdr lst) (list (car lst))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (cond
    [(empty? lst) "Yes"]
    [(empty? (cdr lst)) "Yes"]
    [(and (equal? (car lst) ")") (equal? (cadr lst) ")")) "No"]
    [(and (equal? (car lst) "(") (equal? (cadr lst) ")")) (match_parens (cdr lst))]
    [(and (equal? (car lst) "(") (equal? (cadr lst) "(")) (match_parens (append (cdr lst) (list (car lst))))]
    [else (match_parens (append (cdr lst) (list (car lst))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-helper x n i)
    (cond
      [(= x 1) true]
      [(= x n) true]
      [(= x (* n i)) true]
      [else (is_simple_power-helper x n (+ i 1))]))
  (is_simple_power-helper x n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-helper x n i)
    (cond
      [(= x 1) true]
      [(= x n) true]
      [(= x (* n i)) true]
      [else (is_simple_power-helper x n (+ i 1))]))
  (is_simple_power-helper x n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-helper x n i)
    (if (= x 1)
        #t
        (if (= (expt n i) x)
            #t
            (is_simple_power-helper x n (+ i 1)))))
  (is_simple_power-helper x n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (iter x n i)
    (cond
      [(= x 1) true]
      [(= x n) true]
      [(= x (* n i)) true]
      [else (iter x n (+ i 1))]))
  (iter x n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= i 0) #t]
      [(= x (expt n i)) #t]
      [else (is_simple_power-iter x n (- i 1))]))
  (is_simple_power-iter x n x))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= x 1) #t]
      [(= x n) #t]
      [(> x n) (is_simple_power-iter x n (+ i 1))]
      [else #f]))
  (is_simple_power-iter x n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= x 1) false]
      [(= x n) true]
      [(= x (* n i)) true]
      [else (is_simple_power-iter x n (+ i 1))]))
  (is_simple_power-iter x n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= x 1) true]
      [(= x n) true]
      [(> x n) (is_simple_power-iter x n (+ i 1))]
      [else false]))
  (is_simple_power-iter x n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= x 1) #t]
      [(= x n) #t]
      [(> x n) (is_simple_power-iter x n (+ i 1))]
      [else #f]))
  (is_simple_power-iter x n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (pow n x)
    (if (= x 0)
        1
        (* n (pow n (- x 1)))))
  (if (= x (pow n (log x n)))
      #t
      #f))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= x 1) true]
      [(= x n) true]
      [(= x (* n i)) true]
      [(< x n) false]
      [else (is_simple_power-iter x n (+ i 1))]))
  (is_simple_power-iter x n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (if (= n 1)
      (if (= x 1)
          #t
          #f)
      (if (= x n)
          #t
          (if (= x 1)
              #f
              (is_simple_power (/ x n) n)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_76_is_simple_power --------
#lang racket

;; Your task is to write a function that returns true if a number x is a simple
;; power of n and false in other cases.
;; x is a simple power of n if n**int=x
;; For example:
;; >>> (is_simple_power 1 4)
;; true
;; >>> (is_simple_power 2 2)
;; true
;; >>> (is_simple_power 8 2)
;; true
;; >>> (is_simple_power 3 2)
;; false
;; >>> (is_simple_power 3 1)
;; false
;; >>> (is_simple_power 5 3)
;; false
(define (is_simple_power x n)
  (define (is_simple_power-iter x n i)
    (cond
      [(= i 0) false]
      [(= x (expt n i)) true]
      [else (is_simple_power-iter x n (- i 1))]))
  (is_simple_power-iter x n x))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_simple_power))
    (check-equal? (candidate 16 2) #t)
    (check-equal? (candidate 143214 16) #f)
    (check-equal? (candidate 4 2) #t)
    (check-equal? (candidate 9 3) #t)
    (check-equal? (candidate 16 4) #t)
    (check-equal? (candidate 24 2) #f)
    (check-equal? (candidate 128 4) #f)
    (check-equal? (candidate 12 6) #f)
    (check-equal? (candidate 1 1) #t)
    (check-equal? (candidate 1 12) #t)
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(zero? n) empty]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (make_a_pile-iter n i)
    (if (= i n)
        (list i)
        (cons i (make_a_pile-iter (+ n (if (odd? n) 2 1)) (+ i 1)))))
  (make_a_pile-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (let loop ([n n] [lst (list n)])
    (if (= n 1)
        lst
        (loop (if (odd? n)
                 (add1 (add1 n))
                 (add1 n))
              (cons (if (odd? n)
                       (add1 (add1 n))
                       (add1 n))
                    lst)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (next-odd n)
    (if (odd? n)
        (+ n 2)
        (+ n 1)))
  (define (next-even n)
    (if (even? n)
        (+ n 2)
        (+ n 1)))
  (define (make-pile n)
    (if (= n 1)
        (list n)
        (cons n (make-pile (if (odd? n)
                               (next-odd n)
                               (next-even n))))))
  (make-pile n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(= (remainder n 2) 0) (cons n (make_a_pile (+ n 1)))]
    [else (cons n (make_a_pile (+ n 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (make_a_pile-iter n i)
    (if (= i n)
        (list n)
        (cons n (make_a_pile-iter (+ i (if (odd? n) 2 1)) i))))
  (make_a_pile-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (make_a_pile_iter n i)
    (if (= i n)
        (list n)
        (cons n (make_a_pile_iter (+ i (if (odd? n) 2 1)) i))))
  (make_a_pile_iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(= (remainder n 2) 0) (cons n (make_a_pile (+ n 1)))]
    [else (cons n (make_a_pile (+ n 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (next-odd n)
    (if (odd? n)
        (+ n 2)
        (+ n 1)))
  (define (next-even n)
    (if (even? n)
        (+ n 2)
        (+ n 1)))
  (define (next-level n)
    (if (odd? n)
        (next-odd n)
        (next-even n)))
  (define (make-pile n)
    (if (= n 1)
        (list n)
        (cons n (make-pile (next-level n)))))
  (make-pile n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(= (remainder n 2) 0) (cons n (make_a_pile (+ n 1)))]
    [else (cons n (make_a_pile (+ n 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (next-odd n) (+ n 2))
  (define (next-even n) (+ n 1))
  (define (next n)
    (if (odd? n) (next-odd n) (next-even n)))
  (define (make-pile n)
    (if (= n 1) (list n) (cons n (make-pile (next n)))))
  (make-pile n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (next-odd n)
    (if (odd? n)
        (+ n 2)
        (+ n 1)))
  (define (next-even n)
    (if (even? n)
        (+ n 2)
        (+ n 1)))
  (define (make-pile n)
    (if (= n 1)
        (list n)
        (cons n (make-pile (if (odd? n)
                               (next-odd n)
                               (next-even n))))))
  (make-pile n))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(= (remainder n 2) 0) (cons n (make_a_pile (+ n 1)))]
    [else (cons n (make_a_pile (+ n 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(= (remainder n 2) 0) (cons n (make_a_pile (+ n 1)))]
    [else (cons n (make_a_pile (+ n 2)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(zero? n) empty]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (define (make_a_pile-iter n i)
    (if (= i n)
        '()
        (cons (if (odd? n)
                  (+ n 2)
                  (+ n 1))
              (make_a_pile-iter (if (odd? n)
                                    (+ n 2)
                                    (+ n 1))
                                (+ i 1)))))
  (make_a_pile-iter n 1))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

==========================
------- Program HumanEval_100_make_a_pile --------
#lang racket

;; Given a positive integer n, you have to make a pile of n levels of stones.
;; The first level has n stones.
;; The number of stones in the next level is:
;; - the next odd number if n is odd.
;; - the next even number if n is even.
;; Return the number of stones in each level in a list, where element at index
;; i represents the number of stones in the level (i+1).
;; Examples:
;; >>> (make_a_pile 3)
;; (list 3 5 7)
(define (make_a_pile n)
  (cond
    [(= n 1) (list 1)]
    [(odd? n) (cons n (make_a_pile (+ n 2)))]
    [(even? n) (cons n (make_a_pile (+ n 1)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_a_pile))
    (check-equal? (candidate 3) (list 3 5 7))
    (check-equal? (candidate 4) (list 4 6 8 10))
    (check-equal? (candidate 5) (list 5 7 9 11 13))
    (check-equal? (candidate 6) (list 6 8 10 12 14 16))
    (check-equal? (candidate 8) (list 8 10 12 14 16 18 20 22))
))

(test-humaneval)
------- Status: Timeout --------
-------- stderr -------

