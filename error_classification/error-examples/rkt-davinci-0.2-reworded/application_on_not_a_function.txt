HumanEval_90_next_smallest: 45
HumanEval_160_do_algebra: 32
HumanEval_20_find_closest_elements: 12
HumanEval_10_make_palindrome: 6
HumanEval_109_move_one_ball: 7
HumanEval_153_Strongest_Extension: 3
HumanEval_0_has_close_elements: 17
HumanEval_9_rolling_max: 1
HumanEval_21_rescale_to_unit: 3
HumanEval_18_how_many_times: 45
HumanEval_12_longest: 3
HumanEval_87_get_row: 1
HumanEval_2_truncate_number: 4
HumanEval_158_find_max: 1
HumanEval_114_minSubArraySum: 3
HumanEval_115_max_fill: 1
==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else (let ([min (apply min lst)])
            (cond
              [(null? (cdr (cdr lst))) #f]
              [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0swpbxq9.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0swpbxq9.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0swpbxq9.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp0swpbxq9.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator (reverse operator)]
             [operand (reverse operand)])
    (cond [(empty? operator) (first operand)]
          [(empty? (rest operand)) (first operand)]
          [else
           (loop (rest operator)
                 (cons (eval `(,(first operator) ,(first operand) ,(second operand)))
                       (rest (rest operand))))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp220ttgq0.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp220ttgq0.rkt:37:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("-" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp220ttgq0.rkt:38:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("*" 4 3)
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (closest-pair lst)
    (cond
      [(empty? lst) (error "empty list")]
      [(empty? (rest lst)) (error "list too short")]
      [else (let* ([first (first lst)]
                   [second (first (rest lst))]
                   [diff (abs (- first second))]
                   [rest-diff (closest-pair (rest lst))])
               (if (< diff (first rest-diff))
                   (list diff first second)
                   rest-diff))]))
  (let* ([result (closest-pair numbers)]
         [diff (first result)]
         [first (second result)]
         [second (third result)])
    (if (= diff 0)
        (list first second)
        (if (< first second)
            (list first second)
            (list second first)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3iqz2qp8.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (substring string 1) (string (string-ref string 0)))))
  (define (find-longest-palindrome string)
    (define (find-longest-palindrome-iter string i)
      (if (= i 0)
          ""
          (let ((prefix (substring string 0 i))
                (suffix (substring string i)))
            (if (string=? prefix (reverse suffix))
                prefix
                (find-longest-palindrome-iter string (- i 1))))))
    (find-longest-palindrome-iter string (string-length string)))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3rmhpdcl.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3rmhpdcl.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "z"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3rmhpdcl.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp3rmhpdcl.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "y"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator (reverse operator)] [operand (reverse operand)])
    (if (null? operator)
        (car operand)
        (loop (cdr operator) (cons (eval (list (car operator) (car operand) (car (cdr operand)))) (cdr (cdr operand)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40_nrokb.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40_nrokb.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("-" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp40_nrokb.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("*" 4 3)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_helper operator operand result)
    (cond [(empty? operator) result]
          [(empty? operand) result]
          [(empty? (rest operand)) result]
          [else (do_algebra_helper (rest operator) (rest operand) (eval (list (first operator) (first operand) (second operand))))]))
  (do_algebra_helper operator operand (first operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4_dsq173.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4_dsq173.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4_dsq173.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_iter numbers closest-pair)
    (cond
      [(empty? numbers) closest-pair]
      [(empty? (rest numbers)) closest-pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest-diff (abs (- (first closest-pair) (second closest-pair)))]
              [new-closest-pair (if (< diff closest-diff) (list first second) closest-pair)])
         (find_closest_elements_iter (rest numbers) new-closest-pair))]))
  (find_closest_elements_iter numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4e79jyt9.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4e79jyt9.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4e79jyt9.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4e79jyt9.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4e79jyt9.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let ([first (first arr)]
           [rest (rest arr)])
       (cond
         [(< first (first rest)) (move_one_ball rest)]
         [else #f]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ogkhfy7.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ogkhfy7.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ogkhfy7.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp4ogkhfy7.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest_pair)
    (cond
      [(empty? numbers) closest_pair]
      [(empty? (rest numbers)) closest_pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest_diff (abs (- (first closest_pair) (second closest_pair)))])
         (if (< diff closest_diff)
             (find_closest_elements_helper (rest numbers) (list first second))
             (find_closest_elements_helper (rest numbers) closest_pair)))]))
  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp59ak49_s.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp59ak49_s.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp59ak49_s.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp59ak49_s.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp59ak49_s.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (count_upper str)
    (for/fold ([count 0]) ([c (in-string str)])
      (if (char-upper-case? c)
          (+ count 1)
          count)))
  (define (count_lower str)
    (for/fold ([count 0]) ([c (in-string str)])
      (if (char-lower-case? c)
          (+ count 1)
          count)))
  (define (strength str)
    (- (count_upper str) (count_lower str)))
  (define (strongest_extension lst)
    (for/fold ([strongest (car lst)]
               [strength (strength (car lst))])
        ([ext (in-list (cdr lst))])
      (if (> (strength ext) strength)
          (values ext (strength ext))
          (values strongest strength))))
  (string-append class_name "." (strongest_extension extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:46:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:47:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:48:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:49:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:50:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:51:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:52:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:53:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6bl_fslg.rkt:54:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter oprnd oprtr)
    (cond
      [(empty? oprtr) (first oprnd)]
      [else (do_algebra_iter (cons (eval (list (first oprtr) (first oprnd) (second oprnd))) (rest (rest oprnd))) (rest oprtr))]))
  (do_algebra_iter operand operator))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6gdgnm5d.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6gdgnm5d.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6gdgnm5d.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (min (first lst) (second lst))]
           [max (max (first lst) (second lst))])
       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])
         (let ([new-min (min x min)]
               [new-max (max x max)])
           (if (= new-min min)
               (values new-min new-max)
               (values new-min max))
           )
         )
       )
     ]
    )
  )

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6sy0o7gi.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6sy0o7gi.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6sy0o7gi.rkt:42:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6sy0o7gi.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6sy0o7gi.rkt:44:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6sy0o7gi.rkt:45:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -35
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers smallest_difference smallest_difference_pair)
    (cond
      [(empty? numbers) smallest_difference_pair]
      [(empty? (rest numbers)) smallest_difference_pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [difference (abs (- first second))])
         (if (< difference smallest_difference)
             (find_closest_elements_helper (rest numbers) difference (list first second))
             (find_closest_elements_helper (rest numbers) smallest_difference smallest_difference_pair)))]))
  (find_closest_elements_helper numbers (abs (- (first numbers) (first (rest numbers)))) (list (first numbers) (first (rest numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6t64ht3q.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6t64ht3q.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6t64ht3q.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6t64ht3q.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6t64ht3q.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (min (first lst) (second lst))]
           [max (max (first lst) (second lst))])
       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])
         (let ([new-min (min x min)]
               [new-max (max x max)])
           (cond
             [(= new-min min) (values min max)]
             [(= new-max max) (values min max)]
             [(= new-min new-max) (values min max)]
             [else (values new-min new-max)]))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6zs3s7cp.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6zs3s7cp.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6zs3s7cp.rkt:38:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6zs3s7cp.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6zs3s7cp.rkt:40:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6zs3s7cp.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -35
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (min (first lst) (second lst))]
           [max (max (first lst) (second lst))])
       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])
         (let ([new-min (min x min)]
               [new-max (max x max)])
           (cond
             [(= new-min min) (values new-min max)]
             [(= new-max max) (values min new-max)]
             [else (values new-min new-max)]))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:37:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:39:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -35
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (min (first lst) (second lst))]
           [max (max (first lst) (second lst))])
       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])
         (let ([new-min (min x min)]
               [new-max (max x max)])
           (cond
             [(= new-min min) (values new-min max)]
             [(= new-max max) (values min new-max)]
             [else (values new-min new-max)]))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:37:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:39:4

result arity mismatch;
 expected number of values not received
  expected: 1
  received: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7_gzx75w.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -35
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else
     (let* ([min (apply min lst)]
            [lst (remove min lst)])
       (cond
         [(null? lst) #f]
         [else (apply min lst)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7rxa24ml.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7rxa24ml.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7rxa24ml.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7rxa24ml.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7rxa24ml.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp7rxa24ml.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (substring string 1) (string (string-ref string 0)))))
  (define (find-longest-palindrome string)
    (if (string=? string "")
        ""
        (let ((substr (substring string 0 (- (string-length string) 1))))
          (if (string=? substr (reverse substr))
              (find-longest-palindrome substr)
              string))))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp878lays9.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp878lays9.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp878lays9.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp878lays9.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "jerr"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter opers operands)
    (if (null? opers)
        (car operands)
        (do_algebra_iter (cdr opers)
                         (cons (eval (list (car opers) (car operands) (car (cdr operands))))
                               (cdr (cdr operands))))))
  (do_algebra_iter operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8c23w528.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8c23w528.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp8c23w528.rkt:37:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest-pair)
    (if (empty? numbers)
        closest-pair
        (let* ([first (first numbers)]
               [rest (rest numbers)]
               [new-closest-pair (find-closest-pair first rest closest-pair)])
          (find_closest_elements_helper rest new-closest-pair))))
  (define (find-closest-pair first rest closest-pair)
    (if (empty? rest)
        closest-pair
        (let* ([second (first rest)]
               [rest-rest (rest rest)]
               [distance (abs (- first second))]
               [closest-distance (abs (- (first closest-pair) (second closest-pair)))])
          (if (< distance closest-distance)
              (find-closest-pair first rest-rest (list first second))
              (find-closest-pair first rest-rest closest-pair)))))
  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9tt47zi2.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9tt47zi2.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9tt47zi2.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9tt47zi2.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9tt47zi2.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [rest (rest numbers)]
            [first-rest (first rest)]
            [diff (abs (- first first-rest))])
       (if (< diff threshold)
           #t
           (has_close_elements rest threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [rest (rest numbers)]
            [first-rest (first rest)]
            [diff (abs (- first first-rest))])
       (if (< diff threshold)
           #t
           (has_close_elements rest threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp9u4ec3em.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let* ([first (first arr)]
            [rest (rest arr)]
            [second (first rest)])
       (if (<= first second)
           (move_one_ball rest)
           #f))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_5c18n9p.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_5c18n9p.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_5c18n9p.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_5c18n9p.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter oprnd oprtr)
    (if (null? oprtr)
        (car oprnd)
        (do_algebra_iter (cons (eval (list (car oprtr) (car oprnd) (cadr oprnd))) (cddr oprnd)) (cdr oprtr))))
  (do_algebra_iter operand operator))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_6bph3ct.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_6bph3ct.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_6bph3ct.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_9_rolling_max --------
#lang racket

;; From a given list of integers, generate a list of rolling maximum element found until given moment
;; in the sequence.
;; >>> (rolling_max (list 1 2 3 2 3 4 2))
;; (list 1 2 3 3 3 4 4)
(define (rolling_max numbers)
  (define (rolling_max_iter numbers max)
    (if (null? numbers)
        '()
        (cons max (rolling_max_iter (cdr numbers) (max (car numbers) max)))))
  (rolling_max_iter numbers (car numbers)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rolling_max))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 2 3 4)) (list 1 2 3 4))
    (check-equal? (candidate (list 4 3 2 1)) (list 4 4 4 4))
    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_gtjgz0t.rkt:19:4

car: contract violation
  expected: pair?
  given: '()
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_gtjgz0t.rkt:20:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_gtjgz0t.rkt:21:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_gtjgz0t.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_21_rescale_to_unit --------
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  (define (rescale_to_unit_iter numbers min max result)
    (if (null? numbers)
        result
        (rescale_to_unit_iter (cdr numbers)
                              (min min (car numbers))
                              (max max (car numbers))
                              (append result (list (/ (- (car numbers) min) (- max min)))))))
  (rescale_to_unit_iter numbers (car numbers) (car numbers) '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))
    (check-equal? (candidate (list 100.0 49.9)) (list 1.0 0.0))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))
    (check-equal? (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))
    (check-equal? (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 12.0
--------------------

==========================
------- Program HumanEval_21_rescale_to_unit --------
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  (define (rescale_to_unit_iter numbers min max result)
    (if (null? numbers)
        result
        (rescale_to_unit_iter (cdr numbers)
                              (min min (car numbers))
                              (max max (car numbers))
                              (append result (list (/ (- (car numbers) min) (- max min)))))))
  (rescale_to_unit_iter numbers (car numbers) (car numbers) '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))
    (check-equal? (candidate (list 100.0 49.9)) (list 1.0 0.0))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))
    (check-equal? (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))
    (check-equal? (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_sxtehom.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 12.0
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring) (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring) (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp_ts328u0.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (let ([min (apply min lst)])
    (if (null? lst)
        #f
        (let ([lst (remove min lst)])
          (if (null? lst)
              #f
              (apply min lst))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:30:4

min: arity mismatch;
 the expected number of arguments does not match the given number
  expected: at least 1
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpa2eaqw8_.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator operator] [operand operand] [acc (car operand)])
    (cond [(empty? operator) acc]
          [(empty? operand) acc]
          [else (loop (cdr operator) (cdr operand) (eval `(,(car operator) ,acc ,(car operand))))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaalidlna.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaalidlna.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaalidlna.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (helper string substring count)
    (cond
      [(empty? string) count]
      [(empty? substring) count]
      [(string-prefix? substring string) (helper (substring string (add1 (string-length substring))) substring (add1 count))]
      [else (helper (substring string 1) substring count)]))
  (helper string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpag3do818.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpag3do818.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpag3do818.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpag3do818.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else (do_algebra (rest operator) (cons (eval (list (first operand) (first operator) (second operand))) (rest (rest operand))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaga4v3i6.rkt:31:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "**" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaga4v3i6.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "+" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaga4v3i6.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (7 "//" 3)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond
    [(empty? operator) (first operand)]
    [else (do_algebra (rest operator) (cons (eval (list (first operand) (first operator) (second operand))) (rest (rest operand))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaga4v3i6.rkt:31:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "**" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaga4v3i6.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "+" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpaga4v3i6.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (7 "//" 3)
--------------------

==========================
------- Program HumanEval_12_longest --------
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"
(define (longest strings)
  (cond
    [(empty? strings) #f]
    [(empty? (rest strings)) (first strings)]
    [else
     (let ([longest-so-far (first strings)]
           [rest-of-strings (rest strings)])
       (cond
         [(> (string-length longest-so-far) (string-length (first rest-of-strings)))
          (longest (cons longest-so-far (rest (rest-of-strings))))]
         [else
          (longest (cons (first rest-of-strings) (rest (rest-of-strings))))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list "x" "y" "z")) "x")
    (check-equal? (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajt4wc7c.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '("y" "z")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajt4wc7c.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '("yyy" "zzzz" "www" "kkkk" "abc")
--------------------

==========================
------- Program HumanEval_12_longest --------
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"
(define (longest strings)
  (cond
    [(empty? strings) #f]
    [(empty? (rest strings)) (first strings)]
    [else
     (let ([longest-so-far (first strings)]
           [rest-of-strings (rest strings)])
       (cond
         [(> (string-length longest-so-far) (string-length (first rest-of-strings)))
          (longest (cons longest-so-far (rest (rest-of-strings))))]
         [else
          (longest (cons (first rest-of-strings) (rest (rest-of-strings))))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list "x" "y" "z")) "x")
    (check-equal? (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajt4wc7c.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '("y" "z")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajt4wc7c.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '("yyy" "zzzz" "www" "kkkk" "abc")
--------------------

==========================
------- Program HumanEval_12_longest --------
#lang racket

;; Out of list of strings, return the longest one. Return the first one in case of multiple
;; strings of the same length. Return #f in case the input list is empty.
;; >>> (longest (list ))
;; #f
;; >>> (longest (list "a" "b" "c"))
;; "a"
;; >>> (longest (list "a" "bb" "ccc"))
;; "ccc"
(define (longest strings)
  (cond
    [(empty? strings) #f]
    [(empty? (rest strings)) (first strings)]
    [else
     (let ([longest-so-far (first strings)]
           [rest-of-strings (rest strings)])
       (cond
         [(> (string-length longest-so-far) (string-length (first rest-of-strings)))
          (longest (cons longest-so-far (rest (rest-of-strings))))]
         [else
          (longest (cons (first rest-of-strings) (rest (rest-of-strings))))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate longest))
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list "x" "y" "z")) "x")
    (check-equal? (candidate (list "x" "yyy" "zzzz" "www" "kkkk" "abc")) "zzzz")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajt4wc7c.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '("y" "z")
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpajt4wc7c.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '("yyy" "zzzz" "www" "kkkk" "abc")
--------------------

==========================
------- Program HumanEval_87_get_row --------
#lang racket

;; You are given a 2 dimensional data, as a nested lists,
;; which is similar to matrix, however, unlike matrices,
;; each row may contain a different number of columns.
;; Given lst, and integer x, find integers x in the list,
;; and return list of lists, [(x1, y1), (x2, y2) ...] such that
;; each list is a coordinate - (row, columns), starting with 0.
;; Sort coordinates initially by rows in ascending order.
;; Also, sort coordinates of the row by columns in descending order.
;; Examples:
;; >>> (get_row (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1)
;; (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0))
;; >>> (get_row (list ) 1)
;; (list )
;; >>> (get_row (list (list ) (list 1) (list 1 2 3)) 3)
;; (list (list 2 2))
(define (get_row lst x)
  (define (get_row-helper lst x acc)
    (if (null? lst)
        acc
        (get_row-helper (cdr lst) x (append acc (get-coordinates (car lst) x (length (car lst)) 0)))))
  (define (get-coordinates lst x len y)
    (if (null? lst)
        (list)
        (if (= x (car lst))
            (cons (list y (len - 1)) (get-coordinates (cdr lst) x (len - 1) y))
            (get-coordinates (cdr lst) x (len - 1) y))))
  (sort (get_row-helper lst x (list)) (lambda (x y) (< (car x) (car y)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_row))
    (check-equal? (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0)))
    (check-equal? (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6)) 2) (list (list 0 1) (list 1 1) (list 2 1) (list 3 1) (list 4 1) (list 5 1)))
    (check-equal? (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 1 3 4 5 6) (list 1 2 1 4 5 6) (list 1 2 3 1 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 0) (list 2 1) (list 2 0) (list 3 2) (list 3 0) (list 4 3) (list 4 0) (list 5 4) (list 5 0) (list 6 5) (list 6 0)))
    (check-equal? (candidate (list ) 1) (list ))
    (check-equal? (candidate (list (list 1)) 2) (list ))
    (check-equal? (candidate (list (list ) (list 1) (list 1 2 3)) 3) (list (list 2 2)))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb_rq0him.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 6
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb_rq0him.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 6
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb_rq0him.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 6
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb_rq0him.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpb_rq0him.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (not (integer? number))
        (truncate-helper (floor number))
        (number)))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:21:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 123.0
--------------------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (not (integer? number))
        (truncate-helper (floor number))
        (number)))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:21:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 123.0
--------------------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (not (integer? number))
        (truncate-helper (floor number))
        (number)))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:21:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 123.0
--------------------

==========================
------- Program HumanEval_2_truncate_number --------
#lang racket

;; Given a positive floating point number, it can be decomposed into
;; and integer part (largest integer smaller than given number) and decimals
;; (leftover part always smaller than 1).
;; Return the decimal part of the number.
;; >>> (truncate_number 3.5)
;; 0.5
(define (truncate_number number)
  (define (truncate-helper number)
    (if (not (integer? number))
        (truncate-helper (floor number))
        (number)))
  (- number (truncate-helper number)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate truncate_number))
    (check-equal? (candidate 3.5) 0.5)
    (check-equal? (candidate 1.25) 0.25)
    (check-equal? (candidate 123.0) 0.0)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:21:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbo8e557p.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 123.0
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (helper opers operands)
    (if (null? opers)
        (car operands)
        (helper (cdr opers) (cons (eval (list (car opers) (car operands) (car (cdr operands)))) (cdr (cdr operands))))))
  (helper operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbombqbtp.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbombqbtp.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbombqbtp.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (if (empty? lst)
      #f
      (let ([min (apply min lst)])
        (if (empty? (remove min lst))
            #f
            (apply min (remove min lst))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbwetk3ig.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbwetk3ig.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbwetk3ig.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbwetk3ig.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbwetk3ig.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbwetk3ig.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(null? (cdr (cdr lst))) #f]
         [else
          (let ([min2 (apply min (filter (lambda (x) (not (= x min))) lst))])
            (if (= min min2)
                #f
                min2))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc5skld6y.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc5skld6y.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc5skld6y.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpc5skld6y.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (helper oprands ops)
    (if (null? ops)
        (car oprands)
        (helper (list (eval (list (car ops) (car oprands) (car (cdr oprands))))) (cdr ops))))
  (helper operand operator))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcghv9h4y.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcghv9h4y.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpcghv9h4y.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (let ([min (apply min lst)])
    (if (null? lst)
        #f
        (let ([new-lst (filter (lambda (x) (not (= x min))) lst)])
          (if (null? new-lst)
              #f
              (apply min new-lst))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdftnt_t4.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdftnt_t4.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdftnt_t4.rkt:30:4

min: arity mismatch;
 the expected number of arguments does not match the given number
  expected: at least 1
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdftnt_t4.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdftnt_t4.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let* ([first (first arr)]
            [rest (rest arr)]
            [second (first rest)])
       (cond
         [(> first second) #f]
         [else (move_one_ball rest)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdn1rg5w5.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdn1rg5w5.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdn1rg5w5.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdn1rg5w5.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_158_find_max --------
#lang racket

;; Write a function that accepts a list of strings.
;; The list contains different words. Return the word with maximum number
;; of unique characters. If multiple strings have maximum number of unique
;; characters, return the one which comes first in lexicographical order.
;; >>> (find_max (list "name" "of" "string"))
;; "string"
;; >>> (find_max (list "name" "enam" "game"))
;; "enam"
;; >>> (find_max (list "aaaaaaa" "bb" "cc"))
;; "aaaaaaa"
(define (find_max words)
  (define (count-unique-chars word)
    (length (remove-duplicates (string->list word))))
  (define (max-unique-chars words)
    (foldl (lambda (word max)
             (max (count-unique-chars word) max))
           0
           words))
  (define (max-unique-words words)
    (filter (lambda (word)
              (= (count-unique-chars word)
                 (max-unique-chars words)))
            words))
  (define (lexicographically-first words)
    (foldl (lambda (word min)
             (if (string<? word min)
                 word
                 min))
           (car words)
           words))
  (lexicographically-first (max-unique-words words)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_max))
    (check-equal? (candidate (list "name" "of" "string")) "string")
    (check-equal? (candidate (list "name" "enam" "game")) "enam")
    (check-equal? (candidate (list "aaaaaaa" "bb" "cc")) "aaaaaaa")
    (check-equal? (candidate (list "abc" "cba")) "abc")
    (check-equal? (candidate (list "play" "this" "game" "of" "footbott")) "footbott")
    (check-equal? (candidate (list "we" "are" "gonna" "rock")) "gonna")
    (check-equal? (candidate (list "we" "are" "a" "mad" "nation")) "nation")
    (check-equal? (candidate (list "this" "is" "a" "prrk")) "this")
    (check-equal? (candidate (list "b")) "b")
    (check-equal? (candidate (list "play" "play" "play")) "play")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:45:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:46:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:47:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:48:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpekkapcjr.rkt:49:4

application: not a procedure;
 expected a procedure that can be applied to arguments

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond [(empty? operator) (first operand)]
        [else (do_algebra (rest operator) (cons (eval (list (first operator) (first operand) (second operand))) (rest (rest operand))))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeno7grxy.rkt:30:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeno7grxy.rkt:31:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpeno7grxy.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (substring string 1) (string (string-ref string 0)))))
  (define (make_palindrome-helper string)
    (if (string=? string "")
        ""
        (let ((substring (substring string 0 (- (string-length string) 1))))
          (if (string=? substring (reverse substring))
              substring
              (make_palindrome-helper substring)))))
  (string-append string (reverse (make_palindrome-helper string))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpexilwqye.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpexilwqye.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpexilwqye.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "jerr"
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (if (null? lst)
      #f
      (let ([min (apply min lst)]
            [lst (remove min lst)])
        (if (null? lst)
            #f
            (apply min lst)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf0on4f09.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf0on4f09.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf0on4f09.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf0on4f09.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf0on4f09.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpf0on4f09.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (if (null? operator)
      (car operand)
      (do_algebra (cdr operator) (cons (eval (list (car operand) (car operator) (cadr operand))) (cddr operand)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpmeozd2.rkt:31:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "**" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpmeozd2.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "+" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpmeozd2.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (7 "//" 3)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(null? (cdr (cdr lst))) #f]
         [else
          (let ([min2 (apply min (filter (lambda (x) (not (= x min))) lst))])
            (cond
              [(= min min2) #f]
              [else min2]))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpromxv9.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpromxv9.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpromxv9.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfpromxv9.rkt:39:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([min (min (first lst) (second lst))]
            [max (max (first lst) (second lst))]
            [rest (rest (rest lst))])
       (cond
         [(empty? rest) min]
         [else
          (let loop ([rest rest] [min min] [max max])
            (cond
              [(empty? rest) min]
              [(< (first rest) min) (loop (rest rest) (first rest) max)]
              [(< (first rest) max) (loop (rest rest) min (first rest))]
              [else (loop (rest rest) min max)]))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfw43l0as.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(3 4 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfw43l0as.rkt:38:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(4 3 2)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfw43l0as.rkt:40:4
actual:     1
expected:   #f
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfw43l0as.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(1 1 0)
--------------------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpfw43l0as.rkt:42:4
actual:     1
expected:   #f
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpfw43l0as.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(12 -45)
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times_iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring) (how_many_times_iter (substring string 1) substring (+ count 1))]
      [else (how_many_times_iter (substring string 1) substring count)]))
  (how_many_times_iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg0ux1bms.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg0ux1bms.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg0ux1bms.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpg0ux1bms.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (if (empty? lst)
      #f
      (let ([min (apply min lst)])
        (if (null? (rest lst))
            #f
            (let ([min2 (apply min (filter (lambda (x) (not (= x min))) lst))])
              (if (= min min2)
                  #f
                  min2))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph3wbpi09.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph3wbpi09.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph3wbpi09.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph3wbpi09.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph3wbpi09.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmph3wbpi09.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (if (< (abs (- first second)) threshold)
           #t
           (has_close_elements (rest numbers) threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (if (< (abs (- first second)) threshold)
           #t
           (has_close_elements (rest numbers) threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (if (< (abs (- first second)) threshold)
           #t
           (has_close_elements (rest numbers) threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (if (< (abs (- first second)) threshold)
           #t
           (has_close_elements (rest numbers) threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (if (< (abs (- first second)) threshold)
           #t
           (has_close_elements (rest numbers) threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (if (< (abs (- first second)) threshold)
           #t
           (has_close_elements (rest numbers) threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphgcyncq3.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_helper operator operand result)
    (cond
      [(empty? operator) result]
      [else (do_algebra_helper (rest operator) (rest operand) (eval (list (first operator) result (first operand))))]))
  (do_algebra_helper operator operand (first operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphia3m9ts.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphia3m9ts.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmphia3m9ts.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([min (apply min lst)]
            [lst (remove min lst)])
       (apply min lst))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14fc93i.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14fc93i.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14fc93i.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14fc93i.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14fc93i.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpi14fc93i.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest-pair)
    (cond
      [(empty? numbers) closest-pair]
      [(empty? (rest numbers)) closest-pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest-diff (abs (- (first closest-pair) (second closest-pair)))]
              [new-closest-pair (if (< diff closest-diff) (list first second) closest-pair)])
         (find_closest_elements_helper (rest numbers) new-closest-pair))]))
  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest-pair)
    (cond
      [(empty? numbers) closest-pair]
      [(empty? (rest numbers)) closest-pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest-diff (abs (- (first closest-pair) (second closest-pair)))]
              [new-closest-pair (if (< diff closest-diff) (list first second) closest-pair)])
         (find_closest_elements_helper (rest numbers) new-closest-pair))]))
  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest-pair)
    (cond
      [(empty? numbers) closest-pair]
      [(empty? (rest numbers)) closest-pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest-diff (abs (- (first closest-pair) (second closest-pair)))]
              [new-closest-pair (if (< diff closest-diff) (list first second) closest-pair)])
         (find_closest_elements_helper (rest numbers) new-closest-pair))]))
  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpian14q68.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest_pair)
    (if (empty? numbers)
        closest_pair
        (let* ([first (first numbers)]
               [rest (rest numbers)]
               [closest_pair_so_far (if (empty? closest_pair)
                                        (list first (first rest))
                                        closest_pair)]
               [closest_pair_so_far_diff (abs (- (first closest_pair_so_far) (second closest_pair_so_far)))]
               [new_pair (list first (first rest))]
               [new_pair_diff (abs (- (first new_pair) (second new_pair)))])
          (if (< new_pair_diff closest_pair_so_far_diff)
              (find_closest_elements_helper rest new_pair)
              (find_closest_elements_helper rest closest_pair_so_far)))))
  (find_closest_elements_helper numbers '()))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpijekdhvg.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpijekdhvg.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpijekdhvg.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpijekdhvg.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpijekdhvg.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter operator operand acc)
    (if (null? operator)
        acc
        (do_algebra_iter (cdr operator) (cdr operand) (eval `(,(car operator) ,acc ,(car operand))))))
  (do_algebra_iter operator operand (car operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiw144acu.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiw144acu.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiw144acu.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter operator operand acc)
    (if (null? operator)
        acc
        (do_algebra_iter (cdr operator) (cdr operand) (eval `(,(car operator) ,acc ,(car operand))))))
  (do_algebra_iter operator operand (car operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiw144acu.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiw144acu.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpiw144acu.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (count-upper str)
    (let loop ((i 0) (count 0))
      (if (= i (string-length str))
          count
          (if (char-upper-case? (string-ref str i))
              (loop (+ i 1) (+ count 1))
              (loop (+ i 1) count)))))
  (define (count-lower str)
    (let loop ((i 0) (count 0))
      (if (= i (string-length str))
          count
          (if (char-lower-case? (string-ref str i))
              (loop (+ i 1) (+ count 1))
              (loop (+ i 1) count)))))
  (define (strength str)
    (/ (- (count-upper str) (count-lower str)) (string-length str)))
  (define (strongest-extension extensions)
    (let loop ((extensions extensions) (strongest-extension (car extensions)) (strength (strength (car extensions))))
      (if (null? extensions)
          strongest-extension
          (let ((new-strength (strength (car extensions))))
            (if (> new-strength strength)
                (loop (cdr extensions) (car extensions) new-strength)
                (loop (cdr extensions) strongest-extension strength))))))
  (string-append class_name "." (strongest-extension extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:51:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1/3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:52:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:53:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:54:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:55:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1/3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:56:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1/5
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:57:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1/3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:58:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjh3xrbot.rkt:59:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (cond [(empty? operator) (car operand)]
        [(empty? operand) (car operator)]
        [else (do_algebra (cdr operator) (cons (eval (list (car operator) (car operand) (cadr operand))) (cddr operand)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjvphqn4a.rkt:31:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjvphqn4a.rkt:32:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjvphqn4a.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(string=? string "") count]
      [(string=? substring "") count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyxp4cjc.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyxp4cjc.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpjyxp4cjc.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else (let ([first (first arr)]
                [rest (rest arr)])
            (cond
              [(empty? rest) #t]
              [(<= first (first rest)) (move_one_ball rest)]
              [else #f]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk9lye2is.rkt:40:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk9lye2is.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk9lye2is.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk9lye2is.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (if (null? lst)
      #f
      (let* ([min (apply min lst)]
             [lst (remove min lst)])
        (if (null? lst)
            #f
            (apply min lst)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_9st56q.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_9st56q.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_9st56q.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_9st56q.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_9st56q.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpk_9st56q.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator (reverse operator)]
             [operand (reverse operand)])
    (cond [(null? operator) (car operand)]
          [(null? (cdr operand)) (car operand)]
          [else (loop (cdr operator)
                      (cons (eval (list (car operator) (car operand) (cadr operand)))
                            (cddr operand)))])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl1ow2e00.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl1ow2e00.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("-" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpl1ow2e00.rkt:37:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("*" 4 3)
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (cond
         [(< (abs (- first second)) threshold) #t]
         [else (has_close_elements (rest numbers) threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (cond
         [(< (abs (- first second)) threshold) #t]
         [else (has_close_elements (rest numbers) threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (cond
         [(< (abs (- first second)) threshold) #t]
         [else (has_close_elements (rest numbers) threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (cond
         [(< (abs (- first second)) threshold) #t]
         [else (has_close_elements (rest numbers) threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [second (first (rest numbers))])
       (cond
         [(< (abs (- first second)) threshold) #t]
         [else (has_close_elements (rest numbers) threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmay8neiw.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_21_rescale_to_unit --------
#lang racket

;; Given list of numbers (of at least two elements), apply a linear transform to that list,
;; such that the smallest number will become 0 and the largest will become 1
;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))
;; (list 0.0 0.25 0.5 0.75 1.0)
(define (rescale_to_unit numbers)
  (define (rescale_to_unit_iter numbers min max result)
    (cond
      [(empty? numbers) result]
      [(empty? result) (rescale_to_unit_iter (rest numbers) (first numbers) (first numbers) (list (first numbers)))]
      [else (rescale_to_unit_iter (rest numbers) (min min (first numbers)) (max max (first numbers)) (append result (list (/ (- (first numbers) min) (- max min)))))]))
  (rescale_to_unit_iter numbers (first numbers) (first numbers) (list (first numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate rescale_to_unit))
    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))
    (check-equal? (candidate (list 100.0 49.9)) (list 1.0 0.0))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))
    (check-equal? (candidate (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))
    (check-equal? (candidate (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmilbk_2t.rkt:20:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmilbk_2t.rkt:21:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmilbk_2t.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmilbk_2t.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmilbk_2t.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 12.0
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (helper operator operand)
    (if (null? operator)
        (car operand)
        (helper (cdr operator) (cons (eval (list (car operator) (car operand) (car (cdr operand)))) (cdr (cdr operand))))))
  (helper operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlwawho3.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlwawho3.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlwawho3.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (helper operator operand)
    (if (null? operator)
        (car operand)
        (helper (cdr operator) (cons (eval (list (car operator) (car operand) (car (cdr operand)))) (cdr (cdr operand))))))
  (helper operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlwawho3.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlwawho3.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpmlwawho3.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra-helper operator operand result)
    (cond ((null? operator) result)
          ((= (length operator) 1) (eval (list (car operand) (car operator) (cadr operand))))
          (else (do_algebra-helper (cdr operator) (cdr operand) (eval (list result (car operator) (cadr operand)))))))
  (do_algebra-helper operator operand (car operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn38t03gx.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "**" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn38t03gx.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "+" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn38t03gx.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (7 "//" 3)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (helper opers operands)
    (cond
      [(empty? opers) (first operands)]
      [(empty? (rest operands)) (first operands)]
      [else (helper (rest opers) (cons (eval (list (first operands) (first opers) (second operands))) (rest (rest operands))))]))
  (helper operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn7aoqalo.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "**" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn7aoqalo.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (2 "+" 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn7aoqalo.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (7 "//" 3)
--------------------

==========================
------- Program HumanEval_114_minSubArraySum --------
#lang racket

;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
;; of nums.
;; Example
;; >>> (minSubArraySum (list 2 3 4 1 2 4))
;; 1
;; >>> (minSubArraySum (list -1 -2 -3))
;; -6
(define (minSubArraySum nums)
  (define (minSubArraySum-helper nums sum min)
    (cond
      [(empty? nums) min]
      [else
       (let ([new-sum (+ sum (first nums))])
         (minSubArraySum-helper (rest nums) new-sum (min new-sum sum)))]))
  (minSubArraySum-helper nums 0 (first nums)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minSubArraySum))
    (check-equal? (candidate (list 2 3 4 1 2 4)) 1)
    (check-equal? (candidate (list -1 -2 -3)) -6)
    (check-equal? (candidate (list -1 -2 -3 2 -10)) -14)
    (check-equal? (candidate (list -9999999999999999)) -9999999999999999)
    (check-equal? (candidate (list 0 10 20 1000000)) 0)
    (check-equal? (candidate (list -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 100 -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 10 11 13 8 3 4)) 3)
    (check-equal? (candidate (list 100 -33 32 -1 0 -2)) -33)
    (check-equal? (candidate (list -10)) -10)
    (check-equal? (candidate (list 7)) 7)
    (check-equal? (candidate (list 1 -1)) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -9999999999999999
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpn_qh8jii.rkt:33:4

application: not a procedure;
 expected a procedure that can 
==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_helper operator operand result)
    (cond
      [(empty? operator) result]
      [else (do_algebra_helper (rest operator) (rest operand) (eval `(,(first operator) ,result ,(first operand))))]))
  (do_algebra_helper operator operand (first operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnzxmu104.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnzxmu104.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnzxmu104.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_helper operator operand result)
    (cond
      [(empty? operator) result]
      [else (do_algebra_helper (rest operator) (rest operand) (eval `(,(first operator) ,result ,(first operand))))]))
  (do_algebra_helper operator operand (first operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnzxmu104.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnzxmu104.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpnzxmu104.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (iter opers operands)
    (if (null? opers)
        (car operands)
        (iter (cdr opers) (cons (eval (list (car opers) (car operands) (car (cdr operands)))) (cdr (cdr operands))))))
  (iter operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpow5qg5s8.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpow5qg5s8.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpow5qg5s8.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else
     (let* ([min (apply min lst)]
            [lst (remove min lst)])
       (apply min lst))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp209aqj7.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp209aqj7.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp209aqj7.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp209aqj7.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp209aqj7.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp209aqj7.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (helper operator operand)
    (cond [(null? operator) (car operand)]
          [(= (length operator) 1) (eval (list (car operand) (car operator) (cadr operand)))]
          [else (eval (list (car operand) (car operator) (helper (cdr operator) (cdr operand))))]))
  (helper operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp9f0d3cd.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (4 "+" 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp9f0d3cd.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (4 "-" 5)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpp9f0d3cd.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: (3 "*" 4)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator (reverse operator)] [operand (reverse operand)])
    (if (null? operator)
        (car operand)
        (loop (cdr operator)
              (cons (eval `(,(car operator) ,(car operand) ,(cadr operand)))
                    (cddr operand))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppd6t47b5.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppd6t47b5.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("-" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppd6t47b5.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("*" 4 3)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (let loop ([operator (reverse operator)] [operand (reverse operand)])
    (if (null? operator)
        (car operand)
        (loop (cdr operator)
              (cons (eval `(,(car operator) ,(car operand) ,(cadr operand)))
                    (cddr operand))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppd6t47b5.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppd6t47b5.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("-" 5 4)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppd6t47b5.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("*" 4 3)
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let* ([first (first arr)]
            [rest (rest arr)]
            [second (first rest)])
       (cond
         [(> first second) (move_one_ball rest)]
         [else #f]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppllussi7.rkt:41:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppllussi7.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppllussi7.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmppllussi7.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond [(empty? string) count]
          [(empty? substring) count]
          [(string=? (substring string 0 (string-length substring)) substring)
           (how_many_times-iter (substring string 1) substring (+ count 1))]
          [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond [(empty? string) count]
          [(empty? substring) count]
          [(string=? (substring string 0 (string-length substring)) substring)
           (how_many_times-iter (substring string 1) substring (+ count 1))]
          [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqem0npfa.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_114_minSubArraySum --------
#lang racket

;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
;; of nums.
;; Example
;; >>> (minSubArraySum (list 2 3 4 1 2 4))
;; 1
;; >>> (minSubArraySum (list -1 -2 -3))
;; -6
(define (minSubArraySum nums)
  (define (minSubArraySum-iter nums sum min)
    (cond
      [(empty? nums) min]
      [else
       (let ([new-sum (+ sum (first nums))])
         (minSubArraySum-iter (rest nums) new-sum (min new-sum new-sum)))]))
  (minSubArraySum-iter nums 0 (first nums)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minSubArraySum))
    (check-equal? (candidate (list 2 3 4 1 2 4)) 1)
    (check-equal? (candidate (list -1 -2 -3)) -6)
    (check-equal? (candidate (list -1 -2 -3 2 -10)) -14)
    (check-equal? (candidate (list -9999999999999999)) -9999999999999999)
    (check-equal? (candidate (list 0 10 20 1000000)) 0)
    (check-equal? (candidate (list -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 100 -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 10 11 13 8 3 4)) 3)
    (check-equal? (candidate (list 100 -33 32 -1 0 -2)) -33)
    (check-equal? (candidate (list -10)) -10)
    (check-equal? (candidate (list 7)) 7)
    (check-equal? (candidate (list 1 -1)) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -9999999999999999
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpqlw3pixa.rkt:33:4

application: not a procedure;
 expected a procedure that can 
==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (max_fill_helper grid capacity)
    (cond
      [(empty? grid) 0]
      [(empty? (first grid)) (max_fill_helper (rest grid) capacity)]
      [else
       (let ([row (first grid)]
             [rest (rest grid)])
         (cond
           [(empty? row) (max_fill_helper rest capacity)]
           [(= (first row) 1)
            (let ([rest-row (rest row)])
              (if (empty? rest-row)
                  (max_fill_helper rest capacity)
                  (max_fill_helper (cons (cons 0 rest-row) rest) capacity)))]
           [else (max_fill_helper (cons (rest row) rest) capacity)]))]))
  (max_fill_helper grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6dlbcak.rkt:47:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '((0 1 0 0) (1 1 1 1))
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6dlbcak.rkt:48:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '((0 0 0 0) (1 1 1 1) (0 1 1 1))
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6dlbcak.rkt:49:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '((0 0 0))
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6dlbcak.rkt:50:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '((1 1 1 1))
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr6dlbcak.rkt:51:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '((1 1 1 1))
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let ([first (first numbers)]
           [rest (rest numbers)])
       (cond
         [(< (abs (- first (first rest))) threshold) #t]
         [else (has_close_elements rest threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let ([first (first numbers)]
           [rest (rest numbers)])
       (cond
         [(< (abs (- first (first rest))) threshold) #t]
         [else (has_close_elements rest threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let ([first (first numbers)]
           [rest (rest numbers)])
       (cond
         [(< (abs (- first (first rest))) threshold) #t]
         [else (has_close_elements rest threshold)]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpr8lyf2_i.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra-helper operator operand result)
    (if (null? operator)
        result
        (do_algebra-helper (cdr operator) (cdr operand)
                           (eval `(,(car operator) ,result ,(car operand))))))
  (do_algebra-helper operator operand (car operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprctizr7l.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprctizr7l.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprctizr7l.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra-helper operator operand result)
    (if (null? operator)
        result
        (do_algebra-helper (cdr operator) (cdr operand)
                           (eval `(,(car operator) ,result ,(car operand))))))
  (do_algebra-helper operator operand (car operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprctizr7l.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprctizr7l.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmprctizr7l.rkt:36:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (cond [(empty? string) 0]
        [(empty? substring) 0]
        [(string=? (substring string 0 (string-length substring)) substring)
         (+ 1 (how_many_times (substring string 1) substring))]
        [else (how_many_times (substring string 1) substring)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps3pk05mj.rkt:22:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps3pk05mj.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps3pk05mj.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps3pk05mj.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (substring string 1) (string (string-ref string 0)))))
  (define (find-longest-palindrome-suffix string)
    (define (find-longest-palindrome-suffix-iter string suffix)
      (if (string=? string suffix)
          suffix
          (find-longest-palindrome-suffix-iter string (string-append (string-append suffix (string (string-ref string 0))) (string (string-ref string (string-length suffix)))))))
    (find-longest-palindrome-suffix-iter string ""))
  (string-append string (reverse (substring string 0 (- (string-length string) (string-length (find-longest-palindrome-suffix string)))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8te235y.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8te235y.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8te235y.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xyx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmps8te235y.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "jerry"
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest-pair)
    (cond
      [(empty? numbers) closest-pair]
      [(empty? (rest numbers)) closest-pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [first-second-diff (abs (- first second))]
              [closest-pair-diff (abs (- (first closest-pair) (second closest-pair)))])
         (if (< first-second-diff closest-pair-diff)
             (find_closest_elements_helper (rest numbers) (list first second))
             (find_closest_elements_helper (rest numbers) closest-pair)))]))
  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpscmmhfev.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpscmmhfev.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpscmmhfev.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpscmmhfev.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpscmmhfev.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_helper numbers closest_elements)
    (cond
      [(empty? numbers) closest_elements]
      [(empty? (rest numbers)) closest_elements]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest_diff (abs (- (first closest_elements) (second closest_elements)))])
         (if (< diff closest_diff)
             (find_closest_elements_helper (rest numbers) (list first second))
             (find_closest_elements_helper (rest numbers) closest_elements)))]))
  (find_closest_elements_helper numbers (list (first numbers) (first (rest numbers)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt053vi51.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt053vi51.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt053vi51.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt053vi51.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpt053vi51.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_20_find_closest_elements --------
#lang racket

;; From a supplied list of numbers (of length at least two) select and return two that are the closest to each
;; other and return them in order (smaller number, larger number).
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.2))
;; (list 2.0 2.2)
;; >>> (find_closest_elements (list 1.0 2.0 3.0 4.0 5.0 2.0))
;; (list 2.0 2.0)
(define (find_closest_elements numbers)
  (define (find_closest_elements_iter numbers closest-pair)
    (cond
      [(empty? numbers) closest-pair]
      [(empty? (rest numbers)) closest-pair]
      [else
       (let* ([first (first numbers)]
              [second (first (rest numbers))]
              [diff (abs (- first second))]
              [closest-diff (abs (- (first closest-pair) (second closest-pair)))])
         (if (< diff closest-diff)
             (find_closest_elements_iter (rest numbers) (list first second))
             (find_closest_elements_iter (rest numbers) closest-pair)))]))
  (find_closest_elements_iter numbers (list (first numbers) (second numbers))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_closest_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptalted3v.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptalted3v.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptalted3v.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptalted3v.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmptalted3v.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_153_Strongest_Extension --------
#lang racket

;; You will be given the name of a class (a string) and a list of extensions.
;; The extensions are to be used to load additional classes to the class. The
;; strength of the extension is as follows: Let CAP be the number of the uppercase
;; letters in the extension's name, and let SM be the number of lowercase letters 
;; in the extension's name, the strength is given by the fraction CAP - SM. 
;; You should find the strongest extension and return a string in this 
;; format: ClassName.StrongestExtensionName.
;; If there are two or more extensions with the same strength, you should
;; choose the one that comes first in the list.
;; For example, if you are given "Slices" as the class and a list of the
;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
;; (its strength is -1).
;; Example:
;; >>> (Strongest_Extension "my_class" (list "AA" "Be" "CC"))
;; "my_class.AA"
(define (Strongest_Extension class_name extensions)
  (define (strength ext)
    (let ((cap 0) (sm 0))
      (for ([c (in-string ext)])
        (cond
          [(char-upper-case? c) (set! cap (+ cap 1))]
          [(char-lower-case? c) (set! sm (+ sm 1))]))
      (/ cap sm)))
  (define (strongest_extension extensions)
    (let ((strongest (car extensions))
          (strength (strength (car extensions))))
      (for ([ext (in-list (cdr extensions))])
        (let ((s (strength ext)))
          (cond
            [(> s strength) (set! strength s) (set! strongest ext)]
            [(= s strength) (set! strongest (if (< (string-length ext) (string-length strongest)) ext strongest))])))))
  (string-append class_name "." (strongest_extension extensions)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate Strongest_Extension))
    (check-equal? (candidate "Watashi" (list "tEN" "niNE" "eIGHt8OKe")) "Watashi.eIGHt8OKe")
    (check-equal? (candidate "Boku123" (list "nani" "NazeDa" "YEs.WeCaNe" "32145tggg")) "Boku123.YEs.WeCaNe")
    (check-equal? (candidate "__YESIMHERE" (list "t" "eMptY" "nothing" "zeR00" "NuLl__" "123NoooneB321")) "__YESIMHERE.NuLl__")
    (check-equal? (candidate "K" (list "Ta" "TAR" "t234An" "cosSo")) "K.TAR")
    (check-equal? (candidate "__HAHA" (list "Tab" "123" "781345" "-_-")) "__HAHA.123")
    (check-equal? (candidate "YameRore" (list "HhAas" "okIWILL123" "WorkOut" "Fails" "-_-")) "YameRore.okIWILL123")
    (check-equal? (candidate "finNNalLLly" (list "Die" "NowW" "Wow" "WoW")) "finNNalLLly.WoW")
    (check-equal? (candidate "_" (list "Bb" "91245")) "_.Bb")
    (check-equal? (candidate "Sp" (list "671235" "Bb")) "Sp.671235")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:45:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:46:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:47:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2/3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:48:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1/2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:49:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpurm3qoxg.rkt:50:4

/: division by zero
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (reverse string)
    (if (string=? string "")
        ""
        (string-append (substring string 1) (string (string-ref string 0)))))
  (define (longest-palindrome-suffix string)
    (if (string=? string "")
        ""
        (if (string=? (reverse string) string)
            string
            (longest-palindrome-suffix (substring string 1)))))
  (define (longest-palindrome-prefix string)
    (reverse (longest-palindrome-suffix (reverse string))))
  (string-append string (substring (reverse string) (string-length (longest-palindrome-prefix string)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmputz0ozsq.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmputz0ozsq.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xyz"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmputz0ozsq.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xyx"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmputz0ozsq.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "jerry"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (let loop ([i 0] [count 0])
    (cond
      [(= i (string-length string)) count]
      [(string=? (substring string i (+ i (string-length substring))) substring)
       (loop (+ i 1) (+ count 1))]
      [else (loop (+ i 1) count)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv07w6045.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv07w6045.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpv07w6045.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times_iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times_iter (substring string 1) substring (+ count 1))]
      [else (how_many_times_iter (substring string 1) substring count)]))
  (how_many_times_iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times_iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times_iter (substring string 1) substring (+ count 1))]
      [else (how_many_times_iter (substring string 1) substring count)]))
  (how_many_times_iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvc787c9u.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let* ([first (first arr)]
            [rest (rest arr)]
            [last (last arr)]
            [second-last (last (rest arr))])
       (cond
         [(< first last) (move_one_ball rest)]
         [(< first second-last) #f]
         [else (move_one_ball (append (rest rest) (list first)))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgmkkuob.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(4 5 1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgmkkuob.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(5 10 1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgmkkuob.rkt:45:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(3 1 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvgmkkuob.rkt:46:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: '(5 4 1 2)
--------------------

==========================
------- Program HumanEval_10_make_palindrome --------
#lang racket

;; Find the shortest palindrome that begins with a supplied string.
;; Algorithm idea is simple:
;; - Find the longest postfix of supplied string that is a palindrome.
;; - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
;; >>> (make_palindrome "")
;; ""
;; >>> (make_palindrome "cat")
;; "catac"
;; >>> (make_palindrome "cata")
;; "catac"
(define (make_palindrome string)
  (define (is_palindrome string)
    (define (helper left right)
      (cond ((= left right) #t)
            ((< left right) (and (char=? (string-ref string left) (string-ref string right))
                                 (helper (+ left 1) (- right 1))))))
    (helper 0 (- (string-length string) 1)))
  (define (longest_palindrome_suffix string)
    (define (helper left right)
      (cond ((= left right) (string-length string))
            ((< left right) (if (is_palindrome (substring string left right))
                                (- right left)
                                (helper (+ left 1) (- right 1))))))
    (helper 0 (- (string-length string) 1)))
  (define (longest_palindrome_prefix string)
    (define (helper left right)
      (cond ((= left right) (string-length string))
            ((< left right) (if (is_palindrome (substring string left right))
                                (- right left)
                                (helper (+ left 1) (- right 1))))))
    (helper 0 (- (string-length string) 1)))
  (define (reverse_string string)
    (define (helper left right)
      (cond ((= left right) (string-append (string (string-ref string left)) ""))
            ((< left right) (string-append (string (string-ref string right))
                                           (helper left (- right 1))))))
    (helper 0 (- (string-length string) 1)))
  (string-append string (reverse_string (substring string 0 (- (longest_palindrome_prefix string) 1)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate make_palindrome))
    (check-equal? (candidate "") "")
    (check-equal? (candidate "x") "x")
    (check-equal? (candidate "xyz") "xyzyx")
    (check-equal? (candidate "xyx") "xyx")
    (check-equal? (candidate "jerry") "jerryrrej")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvjz_q8ui.rkt:47:4

-: contract violation
  expected: number?
  given: #<void>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvjz_q8ui.rkt:48:4

string-append: contract violation
  expected: string?
  given: #<void>
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvjz_q8ui.rkt:49:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvjz_q8ui.rkt:50:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "xy"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvjz_q8ui.rkt:51:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "jerr"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (count-substring string substring)
    (cond ((string=? substring "") 1)
          ((string=? string "") 0)
          ((string-prefix? substring string) (+ (count-substring (substring string 1) substring)
                                                (count-substring (substring string 1) (substring substring 1))))
          (else (count-substring (substring string 1) substring))))
  (count-substring string substring))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvmtfa6f9.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvmtfa6f9.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvmtfa6f9.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(empty? substring) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(empty? substring) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(empty? substring) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(empty? substring) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(empty? substring) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpvpdc4q5c.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_0_has_close_elements --------
#lang racket

;; Check if in given list of numbers, are any two numbers closer to each other than
;; given threshold.
;; >>> (has_close_elements (list 1.0 2.0 3.0) 0.5)
;; #f
;; >>> (has_close_elements (list 1.0 2.8 3.0 4.0 5.0 2.0) 0.3)
;; #t
(define (has_close_elements numbers threshold)
  (cond
    [(empty? numbers) #f]
    [(empty? (rest numbers)) #f]
    [else
     (let* ([first (first numbers)]
            [rest (rest numbers)]
            [rest-first (first rest)]
            [diff (abs (- first rest-first))])
       (if (< diff threshold)
           #t
           (has_close_elements rest threshold)))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate has_close_elements))
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)
    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)
    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)
    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)
    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpw67kklg_.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1.1
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (let loop ([string string] [substring substring] [count 0])
    (cond [(empty? string) count]
          [(empty? substring) count]
          [(string=? (substring string 0 (string-length substring)) substring)
           (loop (substring string 1) substring (+ count 1))]
          [else (loop (substring string 1) substring count)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (let loop ([string string] [substring substring] [count 0])
    (cond [(empty? string) count]
          [(empty? substring) count]
          [(string=? (substring string 0 (string-length substring)) substring)
           (loop (substring string 1) substring (+ count 1))]
          [else (loop (substring string 1) substring count)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (let loop ([string string] [substring substring] [count 0])
    (cond [(empty? string) count]
          [(empty? substring) count]
          [(string=? (substring string 0 (string-length substring)) substring)
           (loop (substring string 1) substring (+ count 1))]
          [else (loop (substring string 1) substring count)])))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpwhstgapn.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter operator operand acc)
    (if (empty? operator)
        acc
        (do_algebra_iter (rest operator) (rest operand) (eval (list (first operator) acc (first operand))))))
  (do_algebra_iter operator operand (first operand)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxcw867c9.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxcw867c9.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 2)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpxcw867c9.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 7)
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(= (length lst) 1) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (apply max lst)) #f]
         [else
          (let ([lst (remove min lst)])
            (apply min lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(= (length lst) 1) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (apply max lst)) #f]
         [else
          (let ([lst (remove min lst)])
            (apply min lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy07xs_3z.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? substring (substring string 0 (string-length substring)))
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? substring (substring string 0 (string-length substring)))
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? substring (substring string 0 (string-length substring)))
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? substring (substring string 0 (string-length substring)))
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? substring (substring string 0 (string-length substring)))
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy10epbk_.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (equal? first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (equal? first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (equal? first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (equal? first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (equal? first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpy6qarcel.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_114_minSubArraySum --------
#lang racket

;; Given a list of integers nums, find the minimum sum of any non-empty sub-list
;; of nums.
;; Example
;; >>> (minSubArraySum (list 2 3 4 1 2 4))
;; 1
;; >>> (minSubArraySum (list -1 -2 -3))
;; -6
(define (minSubArraySum nums)
  (define (minSum nums sum minSum)
    (cond
      [(empty? nums) minSum]
      [(< sum (first nums)) (minSum (rest nums) (first nums) minSum)]
      [else (minSum (rest nums) (+ sum (first nums)) (min minSum sum))]))
  (minSum (rest nums) (first nums) (first nums)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate minSubArraySum))
    (check-equal? (candidate (list 2 3 4 1 2 4)) 1)
    (check-equal? (candidate (list -1 -2 -3)) -6)
    (check-equal? (candidate (list -1 -2 -3 2 -10)) -14)
    (check-equal? (candidate (list -9999999999999999)) -9999999999999999)
    (check-equal? (candidate (list 0 10 20 1000000)) 0)
    (check-equal? (candidate (list -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 100 -1 -2 -3 10 -5)) -6)
    (check-equal? (candidate (list 10 11 13 8 3 4)) 3)
    (check-equal? (candidate (list 100 -33 32 -1 0 -2)) -33)
    (check-equal? (candidate (list -10)) -10)
    (check-equal? (candidate (list 7)) 7)
    (check-equal? (candidate (list 1 -1)) -1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 10
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 100
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpybh1i6ta.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------

==========================
------- Program HumanEval_109_move_one_ball --------
#lang racket

;; We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The
;; numbers in the list will be randomly ordered. Your task is to determine if
;; it is possible to get a list sorted in non-decreasing order by performing 
;; the following operation on the given list:
;; You are allowed to perform right shift operation any number of times.
;; One right shift operation means shifting all elements of the list by one
;; position in the right direction. The last element of the list will be moved to
;; the starting position in the list i.e. 0th index. 
;; If it is possible to obtain the sorted list by performing the above operation
;; then return #t else return #f.
;; If the given list is empty then return #t.
;; Note: The given list is guaranteed to have unique elements.
;; For Example:
;; >>> (move_one_ball (list 3 4 5 1 2))
;; #t
;; Explanation: By performin 2 right shift operations, non-decreasing order can
;; be achieved for the given list.
;; >>> (move_one_ball (list 3 5 4 1 2))
;; #f
;; Explanation:It is not possible to get non-decreasing order for the given
;; list by performing any number of right shift operations.
(define (move_one_ball arr)
  (cond
    [(empty? arr) #t]
    [(= (length arr) 1) #t]
    [else
     (let ([first (first arr)]
           [rest (rest arr)])
       (cond
         [(< first (first rest))
          (move_one_ball rest)]
         [else
          (move_one_ball (append rest (list first)))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate move_one_ball))
    (check-equal? (candidate (list 3 4 5 1 2)) #t)
    (check-equal? (candidate (list 3 5 10 1 2)) #t)
    (check-equal? (candidate (list 4 3 1 2)) #f)
    (check-equal? (candidate (list 3 5 4 1 2)) #f)
    (check-equal? (candidate (list )) #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz3qlpuzx.rkt:42:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz3qlpuzx.rkt:43:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz3qlpuzx.rkt:44:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 4
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz3qlpuzx.rkt:45:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 3
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (apply max lst)) #f]
         [else
          (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz64bgm0a.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz64bgm0a.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz64bgm0a.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz64bgm0a.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (cond
    [(empty? string) 0]
    [(empty? substring) 0]
    [(string=? (substring string 0 (string-length substring)) substring)
     (+ 1 (how_many_times (substring string 1) substring))]
    [else (how_many_times (substring string 1) substring)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (cond
    [(empty? string) 0]
    [(empty? substring) 0]
    [(string=? (substring string 0 (string-length substring)) substring)
     (+ 1 (how_many_times (substring string 1) substring))]
    [else (how_many_times (substring string 1) substring)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (cond
    [(empty? string) 0]
    [(empty? substring) 0]
    [(string=? (substring string 0 (string-length substring)) substring)
     (+ 1 (how_many_times (substring string 1) substring))]
    [else (how_many_times (substring string 1) substring)]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:23:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpz91ccff0.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let* ([sorted (sort lst <)]
            [first (first sorted)]
            [second (first (rest sorted))])
       (if (= first second)
           #f
           second))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:31:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:32:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:34:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:36:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzlfywxut.rkt:37:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (how_many_times-iter string substring count)
    (cond
      [(empty? string) count]
      [(string=? (substring string 0 (string-length substring)) substring)
       (how_many_times-iter (substring string 1) substring (+ count 1))]
      [else (how_many_times-iter (substring string 1) substring count)]))
  (how_many_times-iter string substring 0))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:24:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:25:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpztzsens3.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_160_do_algebra --------
#lang racket

;; Given two lists operator, and operand. The first list has basic algebra operations, and 
;; the second list is a list of integers. Use the two given lists to build the algebric 
;; expression and return the evaluation of this expression.
;; The basic algebra operations:
;; Addition ( + ) 
;; Subtraction ( - ) 
;; Multiplication ( * ) 
;; Floor division ( // ) 
;; Exponentiation ( ** ) 
;; Example:
;; operator['+', '*', '-']
;; list = [2, 3, 4, 5]
;; result = 2 + 3 * 4 - 5
;; => result = 9
;; Note:
;; The length of operator list is equal to the length of operand list minus one.
;; Operand is a list of of non-negative integers.
;; Operator list has at least one operator, and operand list has at least two operands.
(define (do_algebra operator operand)
  (define (do_algebra_iter op lst)
    (cond [(empty? lst) (error "Empty list")]
          [(empty? (rest lst)) (first lst)]
          [else (do_algebra_iter op (cons (eval (list (first op) (first lst) (second lst))) (rest (rest lst))))]))
  (do_algebra_iter operator operand))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate do_algebra))
    (check-equal? (candidate (list "**" "*" "+") (list 2 3 4 5)) 37)
    (check-equal? (candidate (list "+" "*" "-") (list 2 3 4 5)) 9)
    (check-equal? (candidate (list "//" "*") (list 7 3 4)) 8)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzuv_ym_n.rkt:33:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("**" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzuv_ym_n.rkt:34:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("+" 2 3)
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzuv_ym_n.rkt:35:4

?: function application is not allowed;
 no #%app syntax transformer is bound
  at: ("//" 7 3)
--------------------

==========================
------- Program HumanEval_18_how_many_times --------
#lang racket

;; Find how many times a given substring can be found in the original string. Count overlaping cases.
;; >>> (how_many_times "" "a")
;; 0
;; >>> (how_many_times "aaa" "a")
;; 3
;; >>> (how_many_times "aaaa" "aa")
;; 3
(define (how_many_times string substring)
  (define (count-substring string substring)
    (define (count-substring-helper string substring count)
      (cond
        [(empty? string) count]
        [(equal? (substring string 0 (string-length substring)) substring)
         (count-substring-helper (substring string 1) substring (+ count 1))]
        [else (count-substring-helper (substring string 1) substring count)]))
    (count-substring-helper string substring 0))
  (count-substring string substring))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate how_many_times))
    (check-equal? (candidate "" "x") 0)
    (check-equal? (candidate "xyxyxyx" "x") 4)
    (check-equal? (candidate "cacacacac" "cac") 4)
    (check-equal? (candidate "john doe" "john") 1)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzyny27gf.rkt:26:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzyny27gf.rkt:27:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "x"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzyny27gf.rkt:28:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "cac"
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpzyny27gf.rkt:29:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: "john"
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (car lst)) (next_smallest (cdr lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(null? lst) #f]
    [(null? (cdr lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (car lst)) (next_smallest (cdr lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp108l6lcu.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmp6ipantoa.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (car lst)) (next_smallest (rest lst))]
         [else (apply min (filter (lambda (x) (not (= x min))) lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpbgd8rs3d.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbgd8rs3d.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbgd8rs3d.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpbgd8rs3d.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (remove min lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (remove min lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (remove min lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

==========================
------- Program HumanEval_90_next_smallest --------
#lang racket

;; You are given a list of integers.
;; Write a function next_smallest() that returns the 2nd smallest element of the list.
;; Return #f if there is no such element.
;; >>> (next_smallest (list 1 2 3 4 5))
;; 2
;; >>> (next_smallest (list 5 1 4 3 2))
;; 2
;; >>> (next_smallest (list ))
;; #f
;; >>> (next_smallest (list 1 1))
;; #f
(define (next_smallest lst)
  (cond
    [(empty? lst) #f]
    [(empty? (rest lst)) #f]
    [else
     (let ([min (apply min lst)])
       (cond
         [(= min (first lst)) (next_smallest (rest lst))]
         [else (apply min (remove min lst))]))]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate next_smallest))
    (check-equal? (candidate (list 1 2 3 4 5)) 2)
    (check-equal? (candidate (list 5 1 4 3 2)) 2)
    (check-equal? (candidate (list )) #f)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list 1 1 1 1 0)) 1)
    (check-equal? (candidate (list 1 1)) #f)
    (check-equal? (candidate (list -35 34 12 -45)) -35)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:29:4
actual:     #f
expected:   2
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:30:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 1
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:33:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 0
--------------------
--------------------
ERROR
name:       check-equal?
location:   /tmp/tmpdckeoyu_.rkt:35:4

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: -45
--------------------

