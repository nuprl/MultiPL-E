
A01_html_tag_present_in_code: 563
bad_char_const: 4
bad_match: 7
bad_syntax: 127
contract_violation: 19
default_value_exp_missing: 57
division_by_0: 2
double_sharp_lang: 7
list_index_too_large: 1
missing_double_quotes: 40
missing_else: 63
missing_or_unmatched_braces: 2004
timeout: 1044
unbound_identifier: 5814
unknown_escape_sequence: 216
value_failure: 351
unclassified 12
==========================
------- Program HumanEval_24_largest_divisor --------
#lang racket

;; For a given number n, find the largest number that divides n evenly, smaller than n
;; >>> (largest_divisor 15)
;; 5
(define (largest_divisor n)
  (define (helper n i)
    (if (= n i)
        n
        (if (= (modulo n i) 0)
            (helper n (+ i 1))
            (helper n (+ i 1)))))
  (helper n 2))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_divisor))
    (check-equal? (candidate 3) 1)
    (check-equal? (candidate 7) 1)
    (check-equal? (candidate 10) 5)
    (check-equal? (candidate 100) 50)
    (check-equal? (candidate 49) 7)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
--------------------
FAILURE

==========================
------- Program HumanEval_54_same_chars --------
#lang racket

;; Check if two words have the same characters.
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddeddabc")
;; #t
;; >>> (same_chars "abcd" "dddddddabc")
;; #t
;; >>> (same_chars "dddddddabc" "abcd")
;; #t
;; >>> (same_chars "eabcd" "dddddddabc")
;; #f
;; >>> (same_chars "abcd" "dddddddabce")
;; #f
;; >>> (same_chars "eabcdzzzz" "dddzzzzzzzddddabc")
;; #f
(define (same_chars s0 s1)
  (define (count-chars s)
    (for/fold ([counts (make-hash)])
               ([c (in-string s)])
      (hash-update counts c add1 0)))
  (define (count-chars-equal? c0 c1)
    (and (hash-equal? (equal? (hash-ref c0 _) (hash-ref c1 _))
                      (hash-keys c0)
                      (hash-keys c1))
         (hash-equal? (equal? (hash-ref c0 _) (hash-ref c1 _))
                      (hash-keys c1)
                      (hash-keys c0))))
  (count-chars-equal? (count-chars s0) (count-chars s1)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate same_chars))
    (check-equal? (candidate "eabcdzzzz" "dddzzzzzzzddeddabc") #t)
    (check-equal? (candidate "abcd" "dddddddabc") #t)
    (check-equal? (candidate "dddddddabc" "abcd") #t)
    (check-equal? (candidate "eabcd" "dddddddabc") #f)
    (check-equal? (candidate "abcd" "dddddddabcf") #f)
    (check-equal? (candidate "eabcdzzzz" "dddzzzzzzzddddabc") #f)
    (check-equal? (candidate "aabb" "aaccc") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp7uy7zi8y.rkt:22:43: _: wildcard not allowed as an expression
  in: _
  location...:
   /tmp/tmp7uy7zi8y.rkt:22:43

==========================
------- Program HumanEval_96_count_up_to --------
#lang racket

;; Implement a function that takes an non-negative integer and returns a list of the first n
;; integers that are prime numbers and less than n.
;; for example:
;; >>> (count_up_to 5)
;; (list 2 3)
;; >>> (count_up_to 11)
;; (list 2 3 5 7)
;; >>> (count_up_to 0)
;; (list )
;; >>> (count_up_to 20)
;; (list 2 3 5 7 11 13 17 19)
;; >>> (count_up_to 1)
;; (list )
;; >>> (count_up_to 18)
;; (list 2 3 5 7 11 13 17)
(define (count_up_to n)
  (cond ((= n 0) '())
        ((= n 1) '())
        ((= n 2) '(2))
        (else
         (let ((primes (list 2)))
           (for ((i 3) (< i n))
             (for ((j (in-list primes)) (not (divides? j i)))
               (void))
             (if (not (divides? j i))
                 (set! primes (cons i primes))))
           primes))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_up_to))
    (check-equal? (candidate 5) (list 2 3))
    (check-equal? (candidate 6) (list 2 3 5))
    (check-equal? (candidate 7) (list 2 3 5))
    (check-equal? (candidate 10) (list 2 3 5 7))
    (check-equal? (candidate 0) (list ))
    (check-equal? (candidate 22) (list 2 3 5 7 11 13 17 19))
    (check-equal? (candidate 1) (list ))
    (check-equal? (candidate 18) (list 2 3 5 7 11 13 17))
    (check-equal? (candidate 47) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43))
    (check-equal? (candidate 101) (list 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97))
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmp8pyy0hbq.rkt:24:23: for: bad sequence binding clause
  at: (< i n)
  in: (for ((i 3) (< i n)) (for ((j (in-list primes)) (not (divides? j i))) (void)) (if (not (divides? j i)) (set! primes (cons i primes))))
  location...:
   /tmp/tmp8pyy0hbq.rkt:24:23
  context...:
   /work/arjunguha-research-group/software/racket/collects/racket/private/for.rkt:1555:4: try-next

==========================
------- Program HumanEval_158_find_max --------
#lang racket

;; Write a function that accepts a list of strings.
;; The list contains different words. Return the word with maximum number
;; of unique characters. If multiple strings have maximum number of unique
;; characters, return the one which comes first in lexicographical order.
;; >>> (find_max (list "name" "of" "string"))
;; "string"
;; >>> (find_max (list "name" "enam" "game"))
;; "enam"
;; >>> (find_max (list "aaaaaaa" "bb" "cc"))
;; "aaaaaaa"
(define (find_max words)
  (let loop ((words words)
             (max-word (car words))
             (max-word-count (length (remove-duplicates (string->list (car words)))))
             (words (cdr words)))
    (cond ((null? words) max-word)
          ((> (length (remove-duplicates (string->list (car words)))) max-word-count)
           (loop (cdr words) (car words) (length (remove-duplicates (string->list (car words)))) (cdr words)))
          (else (loop (cdr words) max-word max-word-count (cdr words))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate find_max))
    (check-equal? (candidate (list "name" "of" "string")) "string")
    (check-equal? (candidate (list "name" "enam" "game")) "enam")
    (check-equal? (candidate (list "aaaaaaa" "bb" "cc")) "aaaaaaa")
    (check-equal? (candidate (list "abc" "cba")) "abc")
    (check-equal? (candidate (list "play" "this" "game" "of" "footbott")) "footbott")
    (check-equal? (candidate (list "we" "are" "gonna" "rock")) "gonna")
    (check-equal? (candidate (list "we" "are" "a" "mad" "nation")) "nation")
    (check-equal? (candidate (list "this" "is" "a" "prrk")) "this")
    (check-equal? (candidate (list "b")) "b")
    (check-equal? (candidate (list "play" "play" "play")) "play")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpkwyjgo6j.rkt:17:14: let: duplicate identifier
  at: words
  in: (let loop ((words words) (max-word (car words)) (max-word-count (length (remove-duplicates (string->list (car words))))) (words (cdr words))) (cond ((null? words) max-word) ((> (length (remove-duplicates (string->list (car words)))) max-word-count) (loo...
  location...:
   /tmp/tmpkwyjgo6j.rkt:17:14
  context...:
   /work/arjunguha-research-group/software/racket/collects/racket/private/qq-and-or.rkt:50:20: go

==========================
------- Program HumanEval_154_cycpattern_check --------
#lang racket

;; You are given 2 words. You need to return #t if the second word or any of its rotations is a substring in the first word
;; >>> (cycpattern_check "abcd" "abd")
;; #f
;; >>> (cycpattern_check "hello" "ell")
;; #t
;; >>> (cycpattern_check "whassup" "psus")
;; #f
;; >>> (cycpattern_check "abab" "baa")
;; #t
;; >>> (cycpattern_check "efef" "eeff")
;; #f
;; >>> (cycpattern_check "himenss" "simen")
;; #t
(define (cycpattern_check a b)
  (define (rotate s)
    (string-append (substring s 1) (string (string-ref s 0))))
  (define (rotate-n s n)
    (if (= n 0)
        s
        (rotate-n (rotate s) (- n 1))))
  (define (rotations s)
    (for/list ([i (in-range (string-length s))])
      (rotate-n s i)))
  (define (substring? s1 s2)
    (regexp-match? (regexp (string-append ".*" s2 ".*")) s1))
  (or (substring? a b)
      (any (lambda (s) (substring? a s)) (rotations b))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate cycpattern_check))
    (check-equal? (candidate "xyzw" "xyw") #f)
    (check-equal? (candidate "yello" "ell") #t)
    (check-equal? (candidate "whattup" "ptut") #f)
    (check-equal? (candidate "efef" "fee") #t)
    (check-equal? (candidate "abab" "aabb") #f)
    (check-equal? (candidate "winemtt" "tinem") #t)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmg1j48z1.rkt:29:6: any: use of 'any' outside the range of an arrow contract
  in: (any (lambda (s) (substring? a s)) (rotations b))
  location...:
   /tmp/tmpmg1j48z1.rkt:29:6

==========================
------- Program HumanEval_115_max_fill --------
#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; >>> (max_fill (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1)
;; 6
;; Example 2:
;; >>> (max_fill (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2)
;; 5
;; Example 3:
;; >>> (max_fill (list (list 0 0 0) (list 0 0 0)) 5)
;; 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid capacity)
  (define (max_fill-helper grid capacity)
    (cond
      [(empty? grid) 0]
      [(empty? (first grid)) (max_fill-helper (rest grid) capacity)]
      [else
       (let ([row (first grid)]
             [row-rest (rest grid)]
             [row-first (first row)]
             [row-rest (rest row)])
         (cond
           [(zero? row-first) (max_fill-helper (cons row-rest row-rest) capacity)]
           [(zero? capacity) (max_fill-helper (cons row-rest row-rest) capacity)]
           [else
            (let ([row-rest (cons (sub1 capacity) row-rest)])
              (+ 1 (max_fill-helper (cons row-rest row-rest) capacity)))]))]))
  (max_fill-helper grid capacity))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate (list (list 0 0 1 0) (list 0 1 0 0) (list 1 1 1 1)) 1) 6)
    (check-equal? (candidate (list (list 0 0 1 1) (list 0 0 0 0) (list 1 1 1 1) (list 0 1 1 1)) 2) 5)
    (check-equal? (candidate (list (list 0 0 0) (list 0 0 0)) 5) 0)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 2) 4)
    (check-equal? (candidate (list (list 1 1 1 1) (list 1 1 1 1)) 9) 2)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpmsm3o_wv.rkt:33:14: let: duplicate identifier
  at: row-rest
  in: (let ((row (first grid)) (row-rest (rest grid)) (row-first (first row)) (row-rest (rest row))) (cond ((zero? row-first) (max_fill-helper (cons row-rest row-rest) capacity)) ((zero? capacity) (max_fill-helper (cons row-rest row-rest) capacity)) (else (le...
  location...:
   /tmp/tmpmsm3o_wv.rkt:33:14
  context...:
   /work/arjunguha-research-group/software/racket/collects/racket/private/qq-and-or.rkt:50:20: go

==========================
------- Program HumanEval_144_simplify --------
#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns #t if x * n evaluates to a whole number and #f
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; >>> (simplify "1/5" "5/1")
;; #t
;; >>> (simplify "1/6" "2/1")
;; #f
;; >>> (simplify "7/10" "10/2")
;; #f
(define (simplify x n)
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
  (define (lcm a b)
    (if (= b 0)
        0
        (/ (* a b) (gcd a b))))
  (define (multiply x n)
    (define (multiply-helper x n)
      (define (multiply-helper-helper x n)
        (let ([x-numerator (string->number (car (string-split x "/")))])
          (let ([x-denominator (string->number (cadr (string-split x "/")))])
            (let ([n-numerator (string->number (car (string-split n "/")))])
              (let ([n-denominator (string->number (cadr (string-split n "/")))])
                (let ([lcm (lcm x-denominator n-denominator)])
                  (let ([x-numerator-new (/ (* x-numerator lcm) x-denominator)])
                    (let ([n-numerator-new (/ (* n-numerator lcm) n-denominator)])
                      (list x-numerator-new n-numerator-new))))))))))
    (let ([x-numerator (car (multiply-helper x n))])
      (let ([n-numerator (cadr (multiply-helper x n))])
        (if (= (remainder x-numerator n-numerator) 0)
            #t
            #f)))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-equal? (candidate "1/5" "5/1") #t)
    (check-equal? (candidate "1/6" "2/1") #f)
    (check-equal? (candidate "5/1" "3/1") #t)
    (check-equal? (candidate "7/10" "10/2") #f)
    (check-equal? (candidate "2/10" "50/10") #t)
    (check-equal? (candidate "7/2" "4/2") #t)
    (check-equal? (candidate "11/6" "6/1") #t)
    (check-equal? (candidate "2/3" "5/2") #f)
    (check-equal? (candidate "5/2" "3/5") #f)
    (check-equal? (candidate "2/4" "8/4") #t)
    (check-equal? (candidate "2/4" "4/2") #t)
    (check-equal? (candidate "1/5" "5/1") #t)
    (check-equal? (candidate "1/5" "1/5") #f)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpp7cljcao.rkt:14:0: begin (possibly implicit): no expression after a sequence of internal definitions
  in: (begin (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (define (lcm a b) (if (= b 0) 0 (/ (* a b) (gcd a b)))) (define (multiply x n) (define (multiply-helper x n) (define (multiply-helper-helper x n) (let ((x-numerator (string->number (car (s...
  location...:
   /tmp/tmpp7cljcao.rkt:14:0
   /tmp/tmpp7cljcao.rkt:15:2
   /tmp/tmpp7cljcao.rkt:19:2
   /tmp/tmpp7cljcao.rkt:23:2

==========================
------- Program HumanEval_67_fruit_distribution --------
#lang racket

;; In this task, you will be given a string that represents a number of apples and oranges 
;; that are distributed in a basket of fruit this basket contains 
;; apples, oranges, and mango fruits. Given the string that represents the total number of 
;; the oranges and apples and an integer that represent the total number of the fruits 
;; in the basket return the number of the mango fruits in the basket.
;; for examble:
;; >>> (fruit_distribution "5 apples and 6 oranges" 19)
;; 8
;; >>> (fruit_distribution "0 apples and 1 oranges" 3)
;; 2
;; >>> (fruit_distribution "2 apples and 3 oranges" 100)
;; 95
;; >>> (fruit_distribution "100 apples and 1 oranges" 120)
;; 19
(define (fruit_distribution s n)
  (define (split s)
    (string-split s " "))
  (define (get-num s)
    (string->number (car (cdr (split s)))))
  (define (get-fruit s)
    (car (split s)))
  (define (get-total-fruit s)
    (cond
      [(equal? (get-fruit s) "apples") (+ (get-num s) (get-num (car (cdr (split s)))))
       (else (get-num s))]))
  (- n (get-total-fruit s)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fruit_distribution))
    (check-equal? (candidate "5 apples and 6 oranges" 19) 8)
    (check-equal? (candidate "5 apples and 6 oranges" 21) 10)
    (check-equal? (candidate "0 apples and 1 oranges" 3) 2)
    (check-equal? (candidate "1 apples and 0 oranges" 3) 2)
    (check-equal? (candidate "2 apples and 3 oranges" 100) 95)
    (check-equal? (candidate "2 apples and 3 oranges" 5) 0)
    (check-equal? (candidate "1 apples and 100 oranges" 120) 19)
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmprxosmlf1.rkt:27:7: else: not allowed as an expression
  in: (else (get-num s))
  location...:
   /tmp/tmprxosmlf1.rkt:27:7

==========================
------- Program HumanEval_119_match_parens --------
#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; >>> (match_parens (list "()(" ")"))
;; "Yes"
;; >>> (match_parens (list ")" ")"))
;; "No"
(define (match_parens lst)
  (let ((s1 (car lst))
        (s2 (cadr lst)))
    (cond ((and (string=? s1 "") (string=? s2 "")) "Yes")
          ((and (string=? s1 "") (not (string=? s2 ""))) "No")
          ((and (not (string=? s1 "")) (string=? s2 "")) "No")
          ((and (not (string=? s1 "")) (not (string=? s2 "")))
           (let ((c1 (string-ref s1 0))
                 (c2 (string-ref s2 0)))
             (cond ((and (char=? c1 #\() (char=? c2 #\()))
                    (match_parens (list (substring s1 1) (substring s2 1))))
                   ((and (char=? c1 #\() (char=? c2 #\)))
                    (match_parens (list (substring s1 1) (substring s2 1))))
                   ((and (char=? c1 #\)) (char=? c2 #\()))
                   ((and (char=? c1 #\)) (char=? c2 #\)))
                   (else "No")))))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)
------- Status: Exception --------
-------- stderr -------
/tmp/tmpzmp1oamg.rkt:31:19: else: not allowed as an expression
  in: (else "No")
  location...:
   /tmp/tmpzmp1oamg.rkt:31:19

==========================
------- Program HumanEval_140_fix_spaces --------
#lang racket

;; Given a string text, replace all spaces in it with underscores, 
;; and if a string has more than 2 consecutive spaces, 
;; then replace all consecutive spaces with - 
;; >>> (fix_spaces " Example")
;; "Example"
;; >>> (fix_spaces " Example 1")
;; "Example_1"
;; >>> (fix_spaces " Example 2")
;; "_Example_2"
;; >>> (fix_spaces " Example 3")
;; "_Example-3"
(define (fix_spaces text)
  (define (replace-all text from to)
    (regexp-replace* #rx from text to))
  (define (replace-spaces text)
    (replace-all text #rx " " "_"))
  (define (replace-consecutive-spaces text)
    (replace-all text #rx " +" "-"))
  (replace-consecutive-spaces (replace-spaces text)))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate fix_spaces))
    (check-equal? (candidate "Example") "Example")
    (check-equal? (candidate "Mudasir Hanif ") "Mudasir_Hanif_")
    (check-equal? (candidate "Yellow Yellow  Dirty  Fellow") "Yellow_Yellow__Dirty__Fellow")
    (check-equal? (candidate "Exa   mple") "Exa-mple")
    (check-equal? (candidate "   Exa 1 2 2 mple") "-Exa_1_2_2_mple")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmp10598i8e.rkt:16:21: read-syntax: expected `"` or `#` after `#rx`
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_124_valid_date --------
#lang racket

;; You have to write a function which validates a given date string and
;; returns #t if the date is valid otherwise #f.
;; The date is valid if all of the following rules are satisfied:
;; 1. The date string is not empty.
;; 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
;; 3. The months should not be less than 1 or higher than 12.
;; 4. The date should be in the format: mm-dd-yyyy
;; >>> (valid_date "03-11-2000")
;; #t
;; >>> (valid_date "15-01-2012")
;; #f
;; >>> (valid_date "04-0-2040")
;; #f
;; >>> (valid_date "06-04-2020")
;; #t
;; >>> (valid_date "06/04/2020")
;; #f
(define (valid_date date)
  (define (valid-month month)
    (and (>= month 1) (<= month 12)))
  (define (valid-day month day)
    (cond
      [(= month 1) (and (>= day 1) (<= day 31))]
      [(= month 3) (and (>= day 1) (<= day 31))]
      [(= month 5) (and (>= day 1) (<= day 31))]
      [(= month 7) (and (>= day 1) (<= day 31))]
      [(= month 8) (and (>= day 1) (<= day 31))]
      [(= month 10) (and (>= day 1) (<= day 31))]
      [(= month 12) (and (>= day 1) (<= day 31))]
      [(= month 4) (and (>= day 1) (<= day 30))]
      [(= month 6) (and (>= day 1) (<= day 30))]
      [(= month 9) (and (>= day 1) (<= day 30))]
      [(= month 11) (and (>= day 1) (<= day 30))]
      [(= month 2) (and (>= day 1) (<= day 29))]))
  (define (valid-year year)
    (and (>= year 0) (<= year 9999)))
  (define (valid-format date)
    (regexp-match? #rx"^[0-9]{2}-[0-9]{2}-[0-9]{4}$" date))
  (and (not (string=? date ""))
       (valid-format date)
       (valid-month (string->number (regexp-replace #rx"^[0-9]{2}-" date "")))
       (valid-day (string->number (regexp-replace #rx"^[0-9]{2}-" date ""))
                  (string->number (regexp-replace #rx"^[0-9]{2}-[0-9]{2}-" date "")))
       (valid-year (string->number (regexp-replace #rx"^[0-9]{2}-[0-9]{2
(require rackunit)

(define (test-humaneval) 

  (let (( candidate valid_date))
    (check-equal? (candidate "03-11-2000") #t)
    (check-equal? (candidate "15-01-2012") #f)
    (check-equal? (candidate "04-0-2040") #f)
    (check-equal? (candidate "06-04-2020") #t)
    (check-equal? (candidate "01-01-2007") #t)
    (check-equal? (candidate "03-32-2011") #f)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "04-31-3000") #f)
    (check-equal? (candidate "06-06-2005") #t)
    (check-equal? (candidate "21-31-2000") #f)
    (check-equal? (candidate "04-12-2003") #t)
    (check-equal? (candidate "04122003") #f)
    (check-equal? (candidate "20030412") #f)
    (check-equal? (candidate "2003-04") #f)
    (check-equal? (candidate "2003-04-12") #f)
    (check-equal? (candidate "04-2003") #f)
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpa7i2waty.rkt:46:51: read-syntax: expected a closing `)`
  pattern: "^[0-9]{2}-[0-9]{2\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_date))\n    (check-equal? (candidate "
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

==========================
------- Program HumanEval_65_circular_shift --------
#lang racket

;; Circular shift the digits of the integer x, shift the digits right by shift
;; and return the result as a string.
;; If shift > number of digits, return digits reversed.
;; >>> (circular_shift 12 1)
;; "21"
;; >>> (circular_shift 12 2)
;; "12"
(define (circular_shift x shift)
  (define (shift-helper x shift)
    (if (= shift 0)
        (number->string x)
        (let* ([x-str (number->string x)]
               [x-len (string-length x-str)]
               [x-last (substring x-str (- x-len 1) x-len)]
               [x-rest (substring x-str 0 (- x-len 1))])
          (shift-helper (string->number (string-append x-last x-rest)) (- shift 1)))))
  (shift-helper x (modulo shift (number->string x |> string-length))))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate circular_shift))
    (check-equal? (candidate 100 2) "001")
    (check-equal? (candidate 12 2) "12")
    (check-equal? (candidate 97 8) "79")
    (check-equal? (candidate 12 1) "21")
    (check-equal? (candidate 11 101) "11")
))

(test-humaneval)
------- Status: SyntaxError --------
-------- stderr -------
/tmp/tmpvi2xtxj4.rkt:19:50: read-syntax: end-of-file following `|` in symbol
  context...:
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:186:17: body
   /work/arjunguha-research-group/software/racket/collects/syntax/module-reader.rkt:183:2: wrap-internal
   /work/arjunguha-research-group/software/racket/collects/racket/../syntax/module-reader.rkt:67:9: wrap-internal/wrapper

None
