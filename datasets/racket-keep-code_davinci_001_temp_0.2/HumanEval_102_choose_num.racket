#lang racket

;; This function takes two positive numbers x and y and returns the
;; biggest even integer number that is in the range [x, y] inclusive. If 
;; there's no such number, then the function should return -1.
;; For example:
;; choose_num(12, 15) = 14
;; choose_num(13, 12) = -1
(define (choose_num x y)
  (cond [(and (>= x y) (= (remainder x 2) 0)) x]
        [(and (>= x y) (= (remainder y 2) 0)) y]
        [(and (>= x y) (> (remainder x 2) 0) (> (remainder y 2) 0)) -1]
        [(and (>= x y) (> (remainder x 2) 0) (= (remainder y 2) 0)) y]
        [(and (>= x y) (= (remainder x 2) 0) (> (remainder y 2) 0)) x]
        [(and (>= x y) (> (remainder x 2) 0) (> (remainder y 2) 0)) -1]
        [(and (>= x y) (= (remainder x 2) 0) (> (remainder y 2) 0)) y]
        [(and (>= x y) (= (remainder x 2) 0) (= (remainder y 2) 0)) x]
        [(and (>= x y) (> (remainder x 2) 0) (= (remainder y 2) 0)) y]
        [(and (>= x y) (= (remainder x 2) 0) (= (remainder y 2) 0)) x]
        [(and (>= x y) (> (remainder x 2) 0) (> (remainder y 2) 0)) -1]
        [(and (>= x y) (> (remainder x 2) 0) (= (remainder y 2) 0)) y]
        [(and (>= x y) (= (remainder x 2) 0) (> (remainder y 2) 0)) x]
        [(and (>= x y) (= (remainder x 2) 0) (= (remainder y 2) 0)) x]
        [(and (>= x y) (> (remainder x 2) 0) (= (remainder y 2) 0)) y]
        [(and (>= x y) (= (remainder x 2) 0) (= (remainder y 2) 0)) x]
        [(and (>= x y) (> (remainder x 2) 0)

(require rackunit)

(define (test-humaneval) 

  (let (( candidate choose_num))
    (check-equal? (candidate 12 15) 14)
    (check-equal? (candidate 13 12) -1)
    (check-equal? (candidate 33 12354) 12354)
    (check-equal? (candidate 5234 5233) -1)
    (check-equal? (candidate 6 29) 28)
    (check-equal? (candidate 27 10) -1)
    (check-equal? (candidate 7 7) -1)
    (check-equal? (candidate 546 546) 546)
))

(test-humaneval)