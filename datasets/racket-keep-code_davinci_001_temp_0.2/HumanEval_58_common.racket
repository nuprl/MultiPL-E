#lang racket

;; Return sorted unique common elements for two lists.
;; >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
;; [1, 5, 653]
;; >>> common([5, 3, 2, 8], [3, 2])
;; [2, 3]
(define (common l1, l2)
  (let ([s1 (sort l1)])
    (let ([s2 (sort l2)])
      (let ([i1 0])
        (let ([i2 0])
          (let ([result '()])
            (while (and (< i1 (length s1)) (< i2 (length s2)))
              (let ([c1 (car s1)])
                (let ([c2 (car s2)])
                  (cond
                    [(= c1 c2)
                     (set! result (append result (list c1)))
                     (set! s1 (cdr s1))
                     (set! s2 (cdr s2))
                     (set! i1 (+ i1 1))
                     (set! i2 (+ i2 1))]
                    [(< c1 c2)
                     (set! s1 (cdr s1))
                     (set! i1 (+ i1 1))]
                    [(> c1 c2)
                     (set! s2 (cdr s2))
                     (set! i2 (+ i2 1))])))
                (set! result (sort result #<)))))
            result)))))))


(require rackunit)

(define (test-humaneval) 

  (let (( candidate common))
    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121)) (list 1 5 653))
    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list 2 3))
    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))
    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))
))

(test-humaneval)