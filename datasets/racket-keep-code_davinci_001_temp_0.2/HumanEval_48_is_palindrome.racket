#lang racket

;; Checks if given string is a palindrome
;; >>> is_palindrome('')
;; True
;; >>> is_palindrome('aba')
;; True
;; >>> is_palindrome('aaaaa')
;; True
;; >>> is_palindrome('zbcd')
;; False
(define (is_palindrome text)
  (define (is_palindrome_recur text)
    (if (empty? text)
        True
        (if (empty? (rest text))
            True
            (if (equal? (first text) (first (rest text)))
                (is_palindrome_recur (rest text))
                False))))
  (is_palindrome_recur text))

# Racket
# 
# ```racket
# (require racket/math)
# (require racket/string)
# (require racket/list)
# 
# (define (is_palindrome text)
# (equal? text (reverse text)))
# ```

# Python
# 
# ```python
# def is_palindrome(text):
# return text == text[::-1]
# ```

# JavaScript
# 
# ```javascript
# function is_palindrome(text) {
# return text == text.split('').reverse().join('');
# }
# ```

# Ruby
# 
# ```ruby
# def is_palindrome(text)
# text == text.reverse
# end
# ```

# Java
# 
# ```java
# public boolean is_palindrome(String text) {
# return text.equals(new StringBuilder(text).reverse().toString());
# }
# ```

# Haskell
# 
# ```haskell
# isPalindrome :: String -> Bool
# isPalindrome text = text == reverse text
# ```

# Elm
# 
# ```elm
# isPalindrome : String -> Bool
# isPalindrome = String.equals
# ```

# Scala
# 
# ```scala
# def is_palindrome(text: String): Boolean =
# text == text.reverse
# ```

# Clojure
# 
# ```clojure
# (defn is-palindrome [text]
# (apply == (concat text) text))
# ```

# Scheme
# 


(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_palindrome))
    (check-equal? (candidate "") #t)
    (check-equal? (candidate "aba") #t)
    (check-equal? (candidate "aaaaa") #t)
    (check-equal? (candidate "zbcd") #f)
    (check-equal? (candidate "xywyx") #t)
    (check-equal? (candidate "xywyz") #f)
    (check-equal? (candidate "xywzx") #f)
))

(test-humaneval)