name: HumanEval_21_rescale_to_unit
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers (of\
  \ at least two elements), apply a linear transform to that list,\n// such that the\
  \ smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0,\
  \ 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nstd::vector<float> rescale_to_unit(std::vector<float>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
  \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
  \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
  \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
  \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
  \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
  }\n"
completions: ["    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number);\n        rescaled_numbers.push_back(number);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number);\n        rescaled_numbers.push_back(number);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.back());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> result;\n    float\
    \ min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        result.push_back(number * (max - min) / numbers.size() + min);\n    }\n\
    \    return result;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float min_number = numbers[0];\n    float\
    \ max_number = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n\
    \        min_number = std::min(min_number, numbers[i]);\n        max_number =\
    \ std::max(max_number, numbers[i]);\n    }\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        rescaled_numbers[i] = numbers[i] - min_number;\n        rescaled_numbers[i]\
    \ /= (max_number - min_number);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number);\n        rescaled_numbers.push_back(number);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number / numbers.size());\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled;\n   \
    \ rescaled.reserve(numbers.size());\n    for (float number : numbers) {\n    \
    \    rescaled.push_back(number / numbers.size());\n    }\n    return rescaled;",
  "    std::vector<float> rescaled_numbers(numbers.size());\n    float min_number\
    \ = std::numeric_limits<float>::max();\n    float max_number = std::numeric_limits<float>::min();\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        min_number = std::min(min_number,\
    \ numbers[i]);\n        max_number = std::max(max_number, numbers[i]);\n     \
    \   rescaled_numbers[i] = numbers[i] - min_number;\n    }\n    for (size_t i =\
    \ 0; i < numbers.size(); i++) {\n        rescaled_numbers[i] = rescaled_numbers[i]\
    \ / max_number - min_number;\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ result;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = (max - min);\n    for (float number : numbers) {\n        result.push_back(number\
    \ - min);\n    }\n    for (float number : result) {\n        assert(number >=\
    \ 0.0);\n        assert(number <= 1.0);\n    }\n    for (float number : result)\
    \ {\n        assert(number >= 0.0);\n        assert(number <= 1.0);\n    }\n \
    \   return result;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number);\n \
    \   }\n    for (auto number : numbers) {\n        new_numbers.push_back(number);\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = std::numeric_limits<float>::min();\n    float max_number = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (max_number - min_number) / (numbers.back() - numbers.front()));\n       \
    \ min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    return rescaled_numbers;", "    assert(numbers.size() >\
    \ 1);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 1;\
    \ i < numbers.size(); ++i) {\n        smallest_number = std::min(smallest_number,\
    \ numbers[i]);\n        largest_number = std::max(largest_number, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled_numbers[i]\
    \ = numbers[i] - smallest_number / largest_number;\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = 1.0f / (max - min);\n    for (float number : numbers) {\n \
    \       number *= scale;\n    }\n    return numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * (range / numbers.back()));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number - smallest);\n\
    \        smallest = std::min(smallest, number);\n        largest = std::max(largest,\
    \ number);\n    }\n    rescaled_numbers.push_back(1.0f - largest);\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = 1.0f / (max - min);\n    for (float number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * scale);\n    }\n \
    \   return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(smallest_number + (number\
    \ - smallest_number) * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result(numbers.begin(), numbers.end());\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = 1.0f / (max - min);\n    for (auto number\
    \ : numbers) {\n        result[numbers.find(number) - numbers.begin()] = scale\
    \ * number;\n    }\n    return result;", "    assert(numbers.size() >= 2);\n \
    \   std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> result(numbers.size());\n\
    \    float min = std::numeric_limits<float>::min();\n    float max = std::numeric_limits<float>::max();\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] = result[i] / (max - min);\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = 1.0f / (max - min);\n    for (float number : numbers) {\n \
    \       rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        rescaled_numbers[i] = numbers[i] / numbers[0];\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        new_numbers.push_back(number);\n\
    \    }\n    for (float number : numbers) {\n        new_numbers.push_back(number\
    \ / new_numbers.size());\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        min = std::min(min,\
    \ number);\n        max = std::max(max, number);\n    }\n    for (auto number\
    \ : numbers) {\n        result.push_back(number - min) / (max - min);\n    }\n\
    \    return result;", "    std::vector<float> result;\n    float min = std::numeric_limits<float>::max();\n\
    \    float max = std::numeric_limits<float>::min();\n    for (float number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (float number : numbers) {\n        result.push_back(number -\
    \ min) / (max - min);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ result;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for (float number :\
    \ numbers) {\n        result.push_back(number * scale);\n    }\n    return result;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = std::numeric_limits<float>::min();\n    float max = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number);\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number);\n    }\n  \
    \  float smallest_number = *std::min_element(rescaled_numbers.begin(), rescaled_numbers.end());\n\
    \    float largest_number = *std::max_element(rescaled_numbers.begin(), rescaled_numbers.end());\n\
    \    float scale = largest_number - smallest_number;\n    for (float number :\
    \ rescaled_numbers) {\n        rescaled_numbers[rescaled_numbers.size() - 1 -\
    \ rescaled_numbers.find(number)] = number / scale;\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> new_numbers(numbers.size());\n    for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n        new_numbers[i] = numbers[i] / numbers[0];\n\
    \    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result;\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (auto n : numbers) {\n        if (n < min) min = n;\n        if (n >\
    \ max) max = n;\n    }\n    for (auto n : numbers) {\n        result.push_back((n\
    \ - min) / (max - min));\n    }\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::max();\n    float max_number\
    \ = std::numeric_limits<float>::min();\n    for (float number : numbers) {\n \
    \       min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n        rescaled_numbers.push_back(number - min_number);\n    }\n\
    \    for (float number : rescaled_numbers) {\n        rescaled_numbers.push_back(number\
    \ / max_number);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        new_numbers.push_back(number);\n\
    \    }\n    float min = new_numbers[0];\n    float max = new_numbers[0];\n   \
    \ for (float number : new_numbers) {\n        min = std::min(min, number);\n \
    \       max = std::max(max, number);\n    }\n    for (float number : new_numbers)\
    \ {\n        number -= min;\n        number /= (max - min);\n        number +=\
    \ 0.5;\n    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for (float number :\
    \ numbers) {\n        result.push_back(number * scale);\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> result(numbers.size());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float scale = 1.0f / range;\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result(numbers.size());\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n\
    \        min = std::min(min, numbers[i]);\n        max = std::max(max, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result[i] =\
    \ numbers[i] - min;\n        result[i] /= (max - min);\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = 1.0f / (max - min);\n    std::vector<float> res(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        res[i] = numbers[i]\
    \ * scale;\n    }\n    return res;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ new_numbers(numbers.size());\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n        smallest\
    \ = std::min(smallest, numbers[i]);\n        largest = std::max(largest, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        new_numbers[i]\
    \ = numbers[i] - smallest;\n        new_numbers[i] /= (largest - smallest);\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = 1.0f / (max - min);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        rescaled_numbers[i] = numbers[i] * scale;\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        new_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ ++i) {\n        smallest_number = std::min(smallest_number, numbers[i]);\n \
    \       largest_number = std::max(largest_number, numbers[i]);\n    }\n    float\
    \ scale = 1.0f / (largest_number - smallest_number);\n    for (size_t i = 0; i\
    \ < numbers.size(); ++i) {\n        rescaled_numbers[i] = numbers[i] * scale;\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float smallest = numbers[0];\n    float\
    \ largest = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n \
    \       smallest = std::min(smallest, numbers[i]);\n        largest = std::max(largest,\
    \ numbers[i]);\n    }\n    float scale = largest / smallest;\n    for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i] = numbers[i]\
    \ * scale;\n    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ n : numbers) {\n        if (n < min) min = n;\n        if (n > max) max = n;\n\
    \    }\n    for (auto n : numbers) {\n        result.push_back((n - min) / (max\
    \ - min));\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result(numbers.size());\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n\
    \        if (numbers[i] < min) {\n            min = numbers[i];\n        } else\
    \ if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n \
    \   for (size_t i = 0; i < numbers.size(); ++i) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] /= (max - min);\n    }\n    return result;", "   \
    \ assert(numbers.size() >= 2);\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled;", "    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled.push_back(number);\n    \
    \    rescaled.push_back(number);\n    }\n    return rescaled;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto n : numbers) {\n        if (n < min) min =\
    \ n;\n        if (n > max) max = n;\n    }\n    for (auto n : numbers) {\n   \
    \     result.push_back((n - min) / (max - min));\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> result;\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = max - min;\n    for (float number : numbers)\
    \ {\n        result.push_back(number * scale);\n    }\n    return result;", " \
    \   std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        smallest_number =\
    \ std::min(smallest_number, numbers[i]);\n        largest_number = std::max(largest_number,\
    \ numbers[i]);\n    }\n    float scale = 1.0f / (largest_number - smallest_number);\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] * scale;\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result;\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    for (float\
    \ number : numbers) {\n        result.push_back(number * scale);\n    }\n    return\
    \ result;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n \
    \   }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * 2.0f - 1.0f);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * scale);\n    }\n \
    \   return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        new_numbers.push_back(number / numbers.size());\n\
    \    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result(numbers.size());\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n        }\n        if (numbers[i] < min) {\n\
    \            min = numbers[i];\n        }\n    }\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        result[i] = numbers[i] - min;\n        result[i] *= (max - min)\
    \ / (numbers.size() - 1);\n    }\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = max - min;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> result;\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = max - min;\n    for (float number : numbers)\
    \ {\n        result.push_back(number * scale);\n    }\n    return result;", " \
    \   assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); ++i) {\n        smallest_number =\
    \ std::min(smallest_number, numbers[i]);\n        largest_number = std::max(largest_number,\
    \ numbers[i]);\n    }\n    float scale = 1.0f / (largest_number - smallest_number);\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled_numbers[i]\
    \ = numbers[i] * scale;\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ result;\n    float min = std::numeric_limits<float>::max();\n    float max =\
    \ std::numeric_limits<float>::min();\n    for (float number : numbers) {\n   \
    \     min = std::min(min, number);\n        max = std::max(max, number);\n   \
    \ }\n    for (float number : numbers) {\n        result.push_back(number * (max\
    \ - min) / numbers.size());\n    }\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        min = std::min(min, numbers[i]);\n        max = std::max(max,\
    \ numbers[i]);\n    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n   \
    \     rescaled_numbers[i] = numbers[i] - min;\n        rescaled_numbers[i] /=\
    \ (max - min);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result(numbers.size());\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n\
    \        min = std::min(min, numbers[i]);\n        max = std::max(max, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result[i] =\
    \ numbers[i] - min;\n        result[i] = result[i] / (max - min);\n    }\n   \
    \ return result;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float\
    \ max_number = std::max(numbers);\n    float min_number = std::min(numbers);\n\
    \    float range = max_number - min_number;\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        rescaled_numbers[i] = numbers[i] - min_number;\n        rescaled_numbers[i]\
    \ /= range;\n    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ result;\n    float min = std::numeric_limits<float>::max();\n    float max =\
    \ std::numeric_limits<float>::min();\n    for (float number : numbers) {\n   \
    \     min = std::min(min, number);\n        max = std::max(max, number);\n   \
    \ }\n    for (float number : numbers) {\n        result.push_back(number * (max\
    \ - min) / (max - min));\n    }\n    return result;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n    for\
    \ (float number : numbers) {\n        rescaled.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] / smallest_number;\n        smallest_number = std::min(smallest_number,\
    \ numbers[i]);\n        largest_number = std::max(largest_number, numbers[i]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers(numbers.size());\n    float min_number =\
    \ numbers[0];\n    float max_number = numbers[0];\n    for (size_t i = 1; i <\
    \ numbers.size(); i++) {\n        if (numbers[i] < min_number) {\n           \
    \ min_number = numbers[i];\n        }\n        if (numbers[i] > max_number) {\n\
    \            max_number = numbers[i];\n        }\n    }\n    for (size_t i = 0;\
    \ i < numbers.size(); i++) {\n        rescaled_numbers[i] = numbers[i] - min_number;\n\
    \        rescaled_numbers[i] /= (max_number - min_number);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = std::numeric_limits<float>::min();\n    float max = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = (max - min) / (numbers.back() - numbers.front());\n    for\
    \ (float number : numbers) {\n        result.push_back(number * scale);\n    }\n\
    \    return result;", "    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled.push_back(number / numbers.back());\n\
    \    }\n    return rescaled;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled;\n    rescaled.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled.push_back(number);\n        rescaled.push_back(number);\n\
    \    }\n    return rescaled;", "    assert(numbers.size() >= 2);\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = max - min;\n    std::vector<float> rescaled_numbers;\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale + min);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> result;\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    for (float number : numbers)\
    \ {\n        float rescaled = number - min;\n        rescaled = rescaled / range;\n\
    \        result.push_back(rescaled);\n    }\n    return result;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] / numbers[0];\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float min\
    \ = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] - min;\n        min = std::min(min, numbers[i]);\n        max =\
    \ std::max(max, numbers[i]);\n    }\n    float scale = 1.0f / (max - min);\n \
    \   for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ *= scale;\n    }\n    return rescaled_numbers;", "    std::vector<float> result;\n\
    \    float min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        result.push_back(number * (max - min) / (max - min));\n    }\n    return\
    \ result;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result(numbers.size());\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n\
    \        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max)\
    \ max = numbers[i];\n    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n\
    \        result[i] = numbers[i] - min;\n        result[i] /= (max - min);\n  \
    \  }\n    return result;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> result;\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = 1.0f / (max - min);\n    for (float number\
    \ : numbers) {\n        result.push_back(number * scale);\n    }\n    return result;",
  "    std::vector<float> rescaled_numbers(numbers.begin(), numbers.end());\n    float\
    \ min_number = std::numeric_limits<float>::min();\n    float max_number = std::numeric_limits<float>::max();\n\
    \    for (float number : rescaled_numbers) {\n        rescaled_numbers = std::map<float,\
    \ float>::\n            map(rescaled_numbers, [](float number) {\n           \
    \     return (number - min_number) / (max_number - min_number);\n            });\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> result;\n    float\
    \ min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        result.push_back(number - min) / (max - min);\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> result;\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (auto number : numbers)\
    \ {\n        if (number < min) min = number;\n        if (number > max) max =\
    \ number;\n    }\n    for (auto number : numbers) {\n        result.push_back(number\
    \ - min) / (max - min);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ ++i) {\n        smallest_number = std::min(smallest_number, numbers[i]);\n \
    \       largest_number = std::max(largest_number, numbers[i]);\n    }\n    for\
    \ (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled_numbers[i] = numbers[i]\
    \ - smallest_number;\n        rescaled_numbers[i] /= (largest_number - smallest_number);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled;\n   \
    \ rescaled.reserve(numbers.size());\n    for (auto number : numbers) {\n     \
    \   rescaled.push_back(number / numbers.back());\n    }\n    return rescaled;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * 2.0 - 1.0);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.back());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled;\n    rescaled.reserve(numbers.size());\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (float number : numbers) {\n        min\
    \ = std::min(min, number);\n        max = std::max(max, number);\n    }\n    float\
    \ scale = 1.0f / (max - min);\n    for (float number : numbers) {\n        rescaled.push_back(number\
    \ * scale);\n    }\n    return rescaled;", "    assert(numbers.size() >= 2);\n\
    \    std::vector<float> rescaled_numbers(numbers.size());\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 1;\
    \ i < numbers.size(); ++i) {\n        smallest_number = std::min(smallest_number,\
    \ numbers[i]);\n        largest_number = std::max(largest_number, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled_numbers[i]\
    \ = numbers[i] - smallest_number;\n        rescaled_numbers[i] /= (largest_number\
    \ - smallest_number);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n     \
    \   rescaled_numbers.push_back(smallest_number / largest_number);\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end());\n    std::transform(rescaled_numbers.begin(), rescaled_numbers.end(),\
    \ rescaled_numbers.begin(), [](float x) -> float {\n        return std::min(std::max(x,\
    \ 0.0f), 1.0f);\n    });\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result(numbers.size());\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        result[i] = numbers[i] / numbers[0];\n    }\n    return result;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end());\n    float min_number = std::numeric_limits<float>::min();\n\
    \    float max_number = std::numeric_limits<float>::max();\n    float min_rescaled_number\
    \ = std::numeric_limits<float>::min();\n    float max_rescaled_number = std::numeric_limits<float>::max();\n\
    \    for (size_t i = 0; i < rescaled_numbers.size(); ++i) {\n        rescaled_numbers[i]\
    \ = numbers[i] - min_number;\n        min_rescaled_number = std::min(min_rescaled_number,\
    \ rescaled_numbers[i]);\n        max_rescaled_number = std::max(max_rescaled_number,\
    \ rescaled_numbers[i]);\n    }\n    rescaled_numbers[0] = min_rescaled_number;\n\
    \    rescaled_numbers[rescaled_numbers.size() - 1] = max_rescaled_number;\n  \
    \  return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] - smallest_number;\n        smallest_number = std::min(smallest_number,\
    \ numbers[i]);\n        largest_number = std::max(largest_number, numbers[i]);\n\
    \    }\n    float scale = 1.0f / (largest_number - smallest_number);\n    for\
    \ (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i] *= scale;\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ result;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ scale = 1.0f / (max - min);\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0f), 1.0f));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled;\n    rescaled.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled.push_back(number / numbers.size());\n    }\n    return rescaled;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number);\n        rescaled_numbers.push_back(number);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> result;\n    float\
    \ min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        result.push_back(number * (max - min) / numbers.size());\n    }\n   \
    \ return result;", "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end());\n    float min_number = std::numeric_limits<float>::min();\n\
    \    float max_number = std::numeric_limits<float>::max();\n    float min_rescaled_number\
    \ = std::numeric_limits<float>::min();\n    float max_rescaled_number = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        min_rescaled_number = std::min(min_rescaled_number,\
    \ number);\n        max_rescaled_number = std::max(max_rescaled_number, number);\n\
    \    }\n    for (float number : numbers) {\n        rescaled_numbers[numbers.find(number)]\
    \ *= (max_rescaled_number - min_rescaled_number) / (max_number - min_number);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float min_number = numbers[0];\n    float\
    \ max_number = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n\
    \        min_number = std::min(min_number, numbers[i]);\n        max_number =\
    \ std::max(max_number, numbers[i]);\n    }\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        rescaled_numbers[i] = numbers[i] - min_number;\n        rescaled_numbers[i]\
    \ /= (max_number - min_number);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> result;\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = 1.0f / (max - min);\n    for (float number : numbers) {\n \
    \       result.push_back(number * scale);\n    }\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (size_t i = 1; i < numbers.size(); i++) {\n        smallest_number = std::min(smallest_number,\
    \ numbers[i]);\n        largest_number = std::max(largest_number, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] - smallest_number;\n        rescaled_numbers[i] /= (largest_number\
    \ - smallest_number);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.size());\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number);\n        rescaled_numbers.push_back(number);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float min_number = std::numeric_limits<float>::max();\n\
    \    float max_number = std::numeric_limits<float>::min();\n    for (size_t i\
    \ = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i] = numbers[i] -\
    \ min_number;\n        min_number = std::min(min_number, numbers[i]);\n      \
    \  max_number = std::max(max_number, numbers[i]);\n    }\n    float scale = 1.0f\
    \ / (max_number - min_number);\n    for (size_t i = 0; i < numbers.size(); i++)\
    \ {\n        rescaled_numbers[i] *= scale;\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = max - min;\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale + min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float min_number\
    \ = numbers[0];\n    float max_number = numbers[0];\n    for (size_t i = 1; i\
    \ < numbers.size(); i++) {\n        min_number = std::min(min_number, numbers[i]);\n\
    \        max_number = std::max(max_number, numbers[i]);\n    }\n    for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i] = numbers[i]\
    \ - min_number;\n        rescaled_numbers[i] /= (max_number - min_number);\n \
    \   }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number);\n    }\n  \
    \  float smallest_number = rescaled_numbers[0];\n    float largest_number = rescaled_numbers[0];\n\
    \    for (float number : rescaled_numbers) {\n        if (number < smallest_number)\
    \ {\n            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    float scale =\
    \ 1.0f / (largest_number - smallest_number);\n    for (float number : rescaled_numbers)\
    \ {\n        rescaled_number *= scale;\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float min_number = numbers[0];\n    float max_number = numbers[0];\n    for\
    \ (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] < min_number)\
    \ {\n            min_number = numbers[i];\n        }\n        if (numbers[i] >\
    \ max_number) {\n            max_number = numbers[i];\n        }\n    }\n    float\
    \ scale = max_number - min_number;\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        rescaled_numbers[i] = numbers[i] - min_number;\n        rescaled_numbers[i]\
    \ *= scale;\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ scale = 1.0f / (max - min);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result(numbers.size());\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = max - min;\n    for (size_t i = 0; i < numbers.size(); ++i)\
    \ {\n        result[i] = numbers[i] - min;\n        result[i] *= 1.0 / scale;\n\
    \    }\n    return result;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ ++i) {\n        smallest_number = std::min(smallest_number, numbers[i]);\n \
    \       largest_number = std::max(largest_number, numbers[i]);\n    }\n    float\
    \ scale = 1.0f / (largest_number - smallest_number);\n    for (size_t i = 0; i\
    \ < numbers.size(); ++i) {\n        rescaled_numbers[i] = numbers[i] * scale;\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;"]
stop_tokens:
- "\n}"
