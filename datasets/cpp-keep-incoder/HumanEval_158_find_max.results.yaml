name: HumanEval_158_find_max
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max;\n    int maxCount = 0;\n  \
    \  for (auto &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > maxCount) {\n            max = word;\n          \
    \  maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpgx1u69nq: /tmp/tmpgx1u69nq.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word: words) {\n        std::unordered_map<char, int> charCount;\n\
    \        for (auto &c: word) {\n            charCount[c]++;\n        }\n     \
    \   for (auto &c: charCount) {\n            if (c.second > maxCount) {\n     \
    \           max = word;\n                maxCount = c.second;\n            }\n\
    \        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp6rjjltod: /tmp/tmp6rjjltod.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &w : words)\
    \ {\n        auto count = std::count(w.begin(), w.end(), 'a');\n        if (count\
    \ > max_count) {\n            max = w;\n            max_count = count;\n     \
    \   }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpdonk9t8x: /tmp/tmpdonk9t8x.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count_if(word.begin(), word.end(),\
    \ [](char c) {\n            return std::isalpha(c);\n        });\n        if (count\
    \ > max_count) {\n            max_count = count;\n            max = word;\n  \
    \      }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprv7x6d5d: /tmp/tmprv7x6d5d.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpjxh2oe7s: /tmp/tmpjxh2oe7s.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &i : words) {\n        int count = 0;\n       \
    \ for (auto &j : words) {\n            if (i == j) {\n                continue;\n\
    \            }\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = i;\n            maxCount = count;\n        }\n    }\n \
    \   return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp9pou2wct: /tmp/tmp9pou2wct.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpsq1ppbg4: /tmp/tmpsq1ppbg4.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max = word;\n         \
    \   max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpu7t9810t: /tmp/tmpu7t9810t.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word: words) {\n        std::unordered_set<char>\
    \ chars;\n        for (auto &c: word) {\n            chars.insert(c);\n      \
    \  }\n        if (chars.size() > maxCount) {\n            max = word;\n      \
    \      maxCount = chars.size();\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp__sbao1c: /tmp/tmp__sbao1c.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n            max\
    \ = word;\n            maxCount = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp4kjo59vo: /tmp/tmp4kjo59vo.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(word.begin(), word.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpgec_so3x: /tmp/tmpgec_so3x.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ word : words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp9rgelj02: /tmp/tmp9rgelj02.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(max.begin(), max.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpi7kl46ct: /tmp/tmpi7kl46ct.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp7cfq631u: /tmp/tmp7cfq631u.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0, max_index = 0;\n    for (size_t i = 0; i <\
    \ words.size(); i++) {\n        int count = 0;\n        for (size_t j = 0; j <\
    \ words[i].size(); j++) {\n            count += words[i][j].size();\n        }\n\
    \        if (count > max_count) {\n            max_count = count;\n          \
    \  max_index = i;\n        }\n    }\n    return words[max_index];\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyl4j2l49.cpp: In function \u2018std::string find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpyl4j2l49.cpp:15:34: error: request for member \u2018size\u2019\
    \ in \u2018(& words.std::vector<std::__cxx11::basic_string<char> >::operator[](i))->std::__cxx11::basic_string<char>::operator[](j)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   15 |             count +=\
    \ words[i][j].size();\n      |                                  ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ count = 0;\n    for (auto &word : words) {\n        count += word.length();\n\
    \        if (count > word.length()) {\n            max = word;\n            count\
    \ = word.length();\n        }\n    }\n    return max;\n}\nint main() {\n    auto\
    \ candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpmv4f20i0: /tmp/tmpmv4f20i0.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max;\n    int maxCount = 0;\n  \
    \  for (auto &word : words) {\n        int count = 0;\n        for (auto &c :\
    \ word) {\n            count += (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u');\n        }\n        if (count > maxCount) {\n            max =\
    \ word;\n            maxCount = count;\n        }\n    }\n    return max;\n}\n\
    int main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp0xhmq1_v: /tmp/tmp0xhmq1_v.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ max_count = 0;\n    for (auto &w : words) {\n        std::set<char> s;\n   \
    \     for (auto &c : w) {\n            s.insert(c);\n        }\n        if (s.size()\
    \ > max_count) {\n            max_count = s.size();\n            max = w;\n  \
    \      }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpadbu4rlv: /tmp/tmpadbu4rlv.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp1s1fma3v: /tmp/tmp1s1fma3v.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > maxCount) {\n            max = word;\n          \
    \  maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp19cqawqg: /tmp/tmp19cqawqg.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpd5l9aeuj: /tmp/tmpd5l9aeuj.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max = 0;\n    std::string maxWord = \"\";\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max) {\n            max = count;\n\
    \            maxWord = word;\n        }\n    }\n    return maxWord;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpxwgsed1e: /tmp/tmpxwgsed1e.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &i : words) {\n        int count = 0;\n       \
    \ for (auto &j : words) {\n            if (i == j) {\n                continue;\n\
    \            }\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = i;\n            maxCount = count;\n        }\n    }\n \
    \   return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpulvyan4e: /tmp/tmpulvyan4e.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for(auto &word: words){\n        int count = 0;\n       \
    \ for(auto &c: word){\n            if(c == max){\n                count++;\n \
    \           }\n        }\n        if(count > maxCount){\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa715bdbr.cpp: In function \u2018std::string find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpa715bdbr.cpp:17:18: error: no match for \u2018operator==\u2019\
    \ (operand types are \u2018char\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   17 |             if(c == max){\n\
    \      |                ~ ^~ ~~~\n      |                |    |\n      |     \
    \           char std::string {aka std::__cxx11::basic_string<char>}\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018char\u2019\n   17 |             if(c\
    \ == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   17\
    \ |             if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   17\
    \ |             if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n        \
    \         from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:64,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and\
    \ \u2018char\u2019\n   17 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/c++/9/string:41,\n            \
    \     from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018\
    char\u2019\n   17 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/string:55,\n        \
    \         from /usr/include/c++/9/bits/locale_classes.h:40,\n                \
    \ from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/string:55,\n        \
    \         from /usr/include/c++/9/bits/locale_classes.h:40,\n                \
    \ from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:297:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_condition&)\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:297:32: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  311 |   operator==(const error_condition& __lhs,\n\
    \      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included from /usr/include/c++/9/bits/locale_facets.h:48,\n\
    \                 from /usr/include/c++/9/bits/basic_ios.h:37,\n             \
    \    from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n     \
    \            from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/complex:463:5: note:\
    \ candidate: \u2018template<class _Tp> constexpr bool std::operator==(const std::complex<_Tp>&,\
    \ const std::complex<_Tp>&)\u2019\n  463 |     operator==(const complex<_Tp>&\
    \ __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   17 |           \
    \  if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018\
    char\u2019\n   17 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::array<_Tp,\
    \ _Nm>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n      |\
    \                     ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched\
    \ types \u2018const std::tuple<_Tps ...>\u2019 and \u2018char\u2019\n   17 | \
    \            if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/functional:59,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n   \
    \              from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  17 |             if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_conv.h:41,\n                 from /usr/include/c++/9/locale:43,\n\
    \                 from /usr/include/c++/9/iomanip:43,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note: \
    \  mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/locale_conv.h:41,\n                 from\
    \ /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   17 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   17 |   \
    \          if(c == max){\n      |                     ^~~\nIn file included from\
    \ /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n     \
    \ |                     ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and\
    \ \u2018char\u2019\n   17 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/c++/9/map:61,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n              \
    \   from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc>\
    \ bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key,\
    \ _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const map<_Key, _Tp,\
    \ _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/map:62,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n          \
    \       from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and\
    \ \u2018char\u2019\n   17 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n \
    \                from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   17 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   17 | \
    \            if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/memory:81,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n       \
    \          from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   17 |        \
    \     if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note: \
    \  mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::queue<_Tp,\
    \ _Seq>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n      |\
    \                     ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/set:62,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n          \
    \       from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/stack:61,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n        \
    \         from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::stack<_Tp,\
    \ _Seq>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n      |\
    \                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   17 |            \
    \ if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   17 |            \
    \ if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   17 |            \
    \ if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   17 |             if(c == max){\n     \
    \ |                     ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::valarray<_Tp>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   17 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n      \
    \           from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   17 |          \
    \   if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/forward_list:40,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpa715bdbr.cpp:17:21: note:   mismatched types \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018char\u2019 to \u2018std::thread::id\u2019\n  276 |   operator==(thread::id\
    \ __x, thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file\
    \ included from /usr/include/c++/9/random:51,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note: \
    \  mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018char\u2019\n   17 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note: \
    \  mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n\
    \      |                     ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const std::unordered_multiset<_Value, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n\
    \      |                     ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::allocator<char>&\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n   17 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>\u2019 and \u2018char\u2019\n   17 |             if(c == max){\n\
    \      |                     ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa715bdbr.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpa715bdbr.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::new_allocator<_Tp>\u2019\n   17 |\
    \             if(c == max){\n      |                     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max;\n    int maxCount = 0;\n  \
    \  for (auto &word : words) {\n        int count = 0;\n        for (auto &c :\
    \ word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n  \
    \              count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp0oq118ol: /tmp/tmp0oq118ol.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp339bifx1: /tmp/tmp339bifx1.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmplsi9as15: /tmp/tmplsi9as15.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           if (std::count(max.begin(), max.end(), c) > 0) {\n               \
    \ count++;\n            }\n        }\n        if (count > max_count) {\n     \
    \       max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp1hkf374t: /tmp/tmp1hkf374t.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int maxCount = 0;\n    for (auto &word :\
    \ words) {\n        std::set<char> chars;\n        for (char c : word) {\n   \
    \         chars.insert(c);\n        }\n        if (chars.size() > maxCount) {\n\
    \            max = word;\n            maxCount = chars.size();\n        }\n  \
    \  }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp79xue31w: /tmp/tmp79xue31w.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(max.begin(), max.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp0zkkiixh: /tmp/tmp0zkkiixh.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpt07gt8w_: /tmp/tmpt07gt8w_.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0, max_index = 0;\n    for (size_t i = 0; i <\
    \ words.size(); i++) {\n        int count = 0;\n        for (size_t j = 0; j <\
    \ words[i].size(); j++) {\n            count += words[i][j].size();\n        }\n\
    \        if (count > max_count) {\n            max_count = count;\n          \
    \  max_index = i;\n        }\n    }\n    return words[max_index];\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpshd0qjtw.cpp: In function \u2018std::string find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpshd0qjtw.cpp:15:34: error: request for member \u2018size\u2019\
    \ in \u2018(& words.std::vector<std::__cxx11::basic_string<char> >::operator[](i))->std::__cxx11::basic_string<char>::operator[](j)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   15 |             count +=\
    \ words[i][j].size();\n      |                                  ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0;\n    std::string max_word = \"\";\n    for\
    \ (auto &word : words) {\n        int count = 0;\n        for (auto &c : word)\
    \ {\n            count += 1;\n        }\n        if (count > max_count) {\n  \
    \          max_count = count;\n            max_word = word;\n        }\n    }\n\
    \    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp1nex5cp_: /tmp/tmp1nex5cp_.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpduqaz4zc: /tmp/tmpduqaz4zc.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max\
    \ = word;\n            max_count = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpnd4xc8wo: /tmp/tmpnd4xc8wo.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    std::string temp;\n\
    \    int count = 0;\n    for (auto &i : words) {\n        temp = i;\n        std::sort(temp.begin(),\
    \ temp.end());\n        std::unique_copy(temp.begin(), temp.end(), std::back_inserter(max));\n\
    \        count += 1;\n    }\n    if (count > 1) {\n        return max;\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp483h24f6: /tmp/tmp483h24f6.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n            max\
    \ = word;\n            maxCount = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpvr0_p5zd: /tmp/tmpvr0_p5zd.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int n = words.size();\n    int max_count = 0;\n    std::string\
    \ max_word = \"\";\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n\
    \        for (int j = 0; j < n; j++) {\n            if (words[i] == words[j])\
    \ {\n                count++;\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = words[i];\n      \
    \  }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp3a7e9tih: /tmp/tmp3a7e9tih.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > maxCount) {\n        \
    \    max = word;\n            maxCount = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp6z4_9c5k: /tmp/tmp6z4_9c5k.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max;\n    std::string max2;\n  \
    \  int maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            if (std::count(word.begin(), word.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            maxCount = count;\n            max = word;\n    \
    \    }\n        if (count > maxCount) {\n            max2 = word;\n        }\n\
    \    }\n    if (maxCount == 0) {\n        return \"\";\n    }\n    if (maxCount\
    \ == 1) {\n        return max2;\n    }\n    return max;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp6ewmlrh4: /tmp/tmp6ewmlrh4.cpp:41: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpwkgnk5pt: /tmp/tmpwkgnk5pt.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        auto count = std::count(w.begin(), w.end(), 'a');\n \
    \       if (count > max_count) {\n            max = w;\n            max_count\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp4bi436kj: /tmp/tmp4bi436kj.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        auto count = std::count(w.begin(), w.end(), 'a');\n \
    \       if (count > max_count) {\n            max_count = count;\n           \
    \ max = w;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpuyxr2gr9: /tmp/tmpuyxr2gr9.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max_count\
    \ = count;\n            max = word;\n        }\n    }\n    return max;\n}\nint\
    \ main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpfkaa5f4v: /tmp/tmpfkaa5f4v.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max_count = count;\n  \
    \          max = word;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpf_ru_zqn: /tmp/tmpf_ru_zqn.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int maxCount = 0;\n    for (auto word :\
    \ words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n \
    \       if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp9d3zz86e: /tmp/tmp9d3zz86e.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmppaiza8h2: /tmp/tmppaiza8h2.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpaua8tugr: /tmp/tmpaua8tugr.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max\
    \ = word;\n            max_count = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp106vje7o: /tmp/tmp106vje7o.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ word : words) {\n        auto count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp5ozc2o1o: /tmp/tmp5ozc2o1o.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0;\n    std::string max_word = \"\";\n    for\
    \ (auto &word : words) {\n        int count = 0;\n        for (auto &c : word)\
    \ {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n        \
    \        count++;\n            }\n        }\n        if (count > max_count) {\n\
    \            max_count = count;\n            max_word = word;\n        }\n   \
    \ }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n \
    \   assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"})))\
    \ == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmplxfawstt: /tmp/tmplxfawstt.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            count += 1;\n        }\n        if\
    \ (count > maxCount) {\n            maxCount = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpbqqb9ba2: /tmp/tmpbqqb9ba2.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0, max_index = -1;\n    for (size_t i = 0; i <\
    \ words.size(); i++) {\n        int count = 0;\n        for (size_t j = 0; j <\
    \ words[i].size(); j++) {\n            count += words[i][j].size();\n        }\n\
    \        if (count > max_count) {\n            max_count = count;\n          \
    \  max_index = i;\n        }\n    }\n    return words[max_index];\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsrb0b3y5.cpp: In function \u2018std::string find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpsrb0b3y5.cpp:15:34: error: request for member \u2018size\u2019\
    \ in \u2018(& words.std::vector<std::__cxx11::basic_string<char> >::operator[](i))->std::__cxx11::basic_string<char>::operator[](j)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   15 |             count +=\
    \ words[i][j].size();\n      |                                  ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        std::unordered_set<char> unique_chars;\n        for (auto\
    \ &c : word) {\n            unique_chars.insert(c);\n        }\n        if (unique_chars.size()\
    \ > max_count) {\n            max = word;\n            max_count = unique_chars.size();\n\
    \        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp07c09_wo: /tmp/tmp07c09_wo.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0;\n    std::string max_word = \"\";\n    for\
    \ (auto &word : words) {\n        int count = 0;\n        for (auto &c : word)\
    \ {\n            count += 1;\n        }\n        if (count > max_count) {\n  \
    \          max_count = count;\n            max_word = word;\n        }\n    }\n\
    \    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpnutv0v42: /tmp/tmpnutv0v42.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        int count = 0;\n        for (auto\
    \ c : word) {\n            count += (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n            max\
    \ = word;\n            maxCount = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp731c6l43: /tmp/tmp731c6l43.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max\
    \ = word;\n            max_count = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpy9daxrau: /tmp/tmpy9daxrau.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0;\n    std::string max_word = \"\";\n    for\
    \ (auto &word : words) {\n        int count = 0;\n        for (auto &c : word)\
    \ {\n            count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u');\n        }\n        if (count > max_count) {\n            max_count =\
    \ count;\n            max_word = word;\n        }\n    }\n    return max_word;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpp49t5vkn: /tmp/tmpp49t5vkn.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int n = words.size();\n    int max_count = 0, max_index = -1;\n\
    \    for (int i = 0; i < n; ++i) {\n        int count = 0;\n        for (int j\
    \ = 0; j < n; ++j) {\n            if (i != j && words[j].size() > words[i].size())\
    \ {\n                count += 1;\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            max_index = i;\n\
    \        }\n    }\n    if (max_count == 0) {\n        return \"\";\n    }\n  \
    \  return words[max_index];\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpbb_pz29s: /tmp/tmpbb_pz29s.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto &word: words) {\n        std::unordered_map<char, int> charCount;\n\
    \        for (char c: word) {\n            charCount[c]++;\n        }\n      \
    \  int count = charCount.size();\n        if (count > maxCount) {\n          \
    \  max = word;\n            maxCount = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpk2o_j7oh: /tmp/tmpk2o_j7oh.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max = \"\";\n    int maxCount =\
    \ 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpl09kemc6: /tmp/tmpl09kemc6.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        auto count = std::count(w.begin(), w.end(), 'a');\n \
    \       if (count > max_count) {\n            max_count = count;\n           \
    \ max = w;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpsag4lt_u: /tmp/tmpsag4lt_u.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for(auto &word: words){\n        int count = 0;\n        for(auto\
    \ &c: word){\n            if(c == 'a'){\n                count++;\n          \
    \  }\n        }\n        if(count > maxCount){\n            max = word;\n    \
    \        maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprz8f_mdp: /tmp/tmprz8f_mdp.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpnjl3iozy: /tmp/tmpnjl3iozy.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp40m8hzjv: /tmp/tmp40m8hzjv.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto word : words) {\n        int count = 0;\n        for (auto c :\
    \ word) {\n            count += 1;\n        }\n        if (count > maxCount) {\n\
    \            max = word;\n            maxCount = count;\n        }\n    }\n  \
    \  return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpljldq_kt: /tmp/tmpljldq_kt.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp_e6gx6x9: /tmp/tmp_e6gx6x9.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0, max_index = 0;\n    for (size_t i = 0; i <\
    \ words.size(); i++) {\n        int count = 0;\n        for (size_t j = 0; j <\
    \ words[i].size(); j++) {\n            if (words[i][j] == words[i][max_index])\
    \ {\n                count++;\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_index = i;\n        }\n \
    \   }\n    return words[max_index];\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprohmxhha: /tmp/tmprohmxhha.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        auto count = std::count_if(word.begin(),\
    \ word.end(), [&](char c) {\n            return std::tolower(c) == std::tolower(max);\n\
    \        });\n        if (count > maxCount) {\n            max = word;\n     \
    \       maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0bpmq5pp.cpp: In lambda function:\n/tmp/tmp0bpmq5pp.cpp:16:55:\
    \ error: no matching function for call to \u2018tolower(std::string&)\u2019\n\
    \   16 |             return std::tolower(c) == std::tolower(max);\n      |   \
    \                                                    ^\nIn file included from\
    \ /usr/include/c++/9/cctype:42,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmp0bpmq5pp.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0bpmq5pp.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0bpmq5pp.cpp:16:55: note:   candidate expects 2 arguments,\
    \ 1 provided\n   16 |             return std::tolower(c) == std::tolower(max);\n\
    \      |                                                       ^\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0bpmq5pp.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h: In instantiation\
    \ of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = find_max(std::vector<std::__cxx11::basic_string<char> >)::<lambda(char)>]\u2019\
    :\n/usr/include/c++/9/bits/stl_algo.h:3194:12:   required from \u2018typename\
    \ std::iterator_traits<_Iterator>::difference_type std::__count_if(_InputIterator,\
    \ _InputIterator, _Predicate) [with _InputIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _Predicate = __gnu_cxx::__ops::_Iter_pred<find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)::<lambda(char)> >; typename std::iterator_traits<_Iterator>::difference_type\
    \ = long int]\u2019\n/usr/include/c++/9/bits/stl_algo.h:4144:29:   required from\
    \ \u2018typename std::iterator_traits<_Iterator>::difference_type std::count_if(_IIter,\
    \ _IIter, _Predicate) [with _IIter = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = find_max(std::vector<std::__cxx11::basic_string<char> >)::<lambda(char)>;\
    \ typename std::iterator_traits<_Iterator>::difference_type = long int]\u2019\n\
    /tmp/tmp0bpmq5pp.cpp:17:10:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:283:11:\
    \ error: void value not ignored as it ought to be\n  283 |  { return bool(_M_pred(*__it));\
    \ }\n      |           ^~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpbo66tya9: /tmp/tmpbo66tya9.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp7qovj4i_: /tmp/tmp7qovj4i_.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for(auto &word : words) {\n        std::sort(word.begin(),\
    \ word.end());\n        std::set<char> chars;\n        for(auto &c : word) {\n\
    \            chars.insert(c);\n        }\n        auto count = chars.size();\n\
    \        if(count > maxCount) {\n            maxCount = count;\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmplvn8_ael: /tmp/tmplvn8_ael.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpg41wvf51: /tmp/tmpg41wvf51.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpjbwpuxba: /tmp/tmpjbwpuxba.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for(auto &word: words){\n        int count = 0;\n        for(auto\
    \ &c: word){\n            if(c == 'a'){\n                count++;\n          \
    \  }\n        }\n        if(count > maxCount){\n            max = word;\n    \
    \        maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpyblx_cse: /tmp/tmpyblx_cse.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp5gxqlzs8: /tmp/tmp5gxqlzs8.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max\
    \ = word;\n            max_count = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpwdcnylox: /tmp/tmpwdcnylox.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(max.begin(), max.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp8fj10cu9: /tmp/tmp8fj10cu9.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            count += 1;\n        }\n        if\
    \ (count > maxCount) {\n            maxCount = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpz0srxery: /tmp/tmpz0srxery.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpz3lq2fd8: /tmp/tmpz3lq2fd8.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpitjiozw0: /tmp/tmpitjiozw0.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max;\n    int maxCount = 0;\n  \
    \  for (auto &word : words) {\n        int count = 0;\n        for (auto &c :\
    \ word) {\n            count += 1;\n        }\n        if (count > maxCount) {\n\
    \            max = word;\n            maxCount = count;\n        }\n    }\n  \
    \  return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpp2pcrqm3: /tmp/tmpp2pcrqm3.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int n = words.size();\n    int max_count = 0;\n    std::string\
    \ max_word = \"\";\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n\
    \        for (int j = 0; j < n; j++) {\n            if (words[j] == words[i])\
    \ {\n                count++;\n            }\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = words[i];\n      \
    \  }\n    }\n    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmplzkg4vjs: /tmp/tmplzkg4vjs.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpins0lqjw: /tmp/tmpins0lqjw.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ word : words) {\n        int count = 0;\n        for (auto c : word) {\n   \
    \         count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > maxCount) {\n            max = word;\n       \
    \     maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmppwz169ps: /tmp/tmppwz169ps.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int maxCount = 0;\n    for (auto &word :\
    \ words) {\n        int count = 0;\n        for (auto &c : word) {\n         \
    \   count += 1;\n        }\n        if (count > maxCount) {\n            max =\
    \ word;\n            maxCount = count;\n        }\n    }\n    return max;\n}\n\
    int main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpvhcybleo: /tmp/tmpvhcybleo.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max_count = count;\n  \
    \          max = word;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp0jkr_4i1: /tmp/tmp0jkr_4i1.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max = word;\n         \
    \   max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpxpkfn8n6: /tmp/tmpxpkfn8n6.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &w : words) {\n        int count = 0;\n        for (auto\
    \ &c : w) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = w;\n            maxCount = count;\n        }\n    }\n \
    \   return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpsqn5rgk2: /tmp/tmpsqn5rgk2.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max = 0;\n    std::string maxWord = \"\";\n    for (auto &word\
    \ : words) {\n        auto count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > max) {\n            max = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpn4wyycy7: /tmp/tmpn4wyycy7.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for(auto &word: words) {\n        int count = 0;\n        for(auto\
    \ &c: word) {\n            count += 1;\n        }\n        if(count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpw21ttpkj: /tmp/tmpw21ttpkj.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpetfje6up: /tmp/tmpetfje6up.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp45owhldm: /tmp/tmp45owhldm.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp7pl3ena_: /tmp/tmp7pl3ena_.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp8bip9zd7: /tmp/tmp8bip9zd7.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > maxCount) {\n            max = word;\n       \
    \     maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpcizk6nbi: /tmp/tmpcizk6nbi.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpq2pewk0f: /tmp/tmpq2pewk0f.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           if (std::count(max.begin(), max.end(), c) > 0) {\n               \
    \ count++;\n            }\n        }\n        if (count > max_count) {\n     \
    \       max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp69ccjun7: /tmp/tmp69ccjun7.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &w : words) {\n        int count = 0;\n        for (auto\
    \ &c : w) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = w;\n            maxCount = count;\n        }\n    }\n \
    \   return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp_fostceh: /tmp/tmp_fostceh.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        auto count = std::count(w.begin(), w.end(), 'a');\n \
    \       if (count > max_count) {\n            max = w;\n            max_count\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp9u6l_y4o: /tmp/tmp9u6l_y4o.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp_qunnl8x: /tmp/tmp_qunnl8x.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &w : words) {\n        int count = 0;\n        for (auto &c : w)\
    \ {\n            if (std::count(w.begin(), w.end(), c) > 0) {\n              \
    \  count++;\n            }\n        }\n        if (count > maxCount) {\n     \
    \       max = w;\n            maxCount = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpcl9j96kd: /tmp/tmpcl9j96kd.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           if (std::count(max.begin(), max.end(), c) > 0) {\n               \
    \ count++;\n            }\n        }\n        if (count > max_count) {\n     \
    \       max_count = count;\n            max = word;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpcv_2qfqa: /tmp/tmpcv_2qfqa.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            count += 1;\n        }\n        if\
    \ (count > maxCount) {\n            maxCount = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmptqz90dab: /tmp/tmptqz90dab.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(word.begin(), word.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp62rnw0jo: /tmp/tmp62rnw0jo.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(max.begin(), max.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpad084shs: /tmp/tmpad084shs.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int max_count\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max = word;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp56hb_mwb: /tmp/tmp56hb_mwb.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max = 0;\n    std::string maxWord = \"\";\n    for (auto &word\
    \ : words) {\n        int uniqueChar = std::count(word.begin(), word.end(), 'a');\n\
    \        if (uniqueChar > max) {\n            max = uniqueChar;\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpjyofqfqv: /tmp/tmpjyofqfqv.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        int count = 0;\n        for (auto &c : w) {\n       \
    \     count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n \
    \       }\n        if (count > max_count) {\n            max = w;\n          \
    \  max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n  \
    \  auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp71_5os8l: /tmp/tmp71_5os8l.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max\
    \ = word;\n            max_count = count;\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp3u4t4g77: /tmp/tmp3u4t4g77.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpg23qym4y: /tmp/tmpg23qym4y.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpxynl5a4k: /tmp/tmpxynl5a4k.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp9rflgsut: /tmp/tmp9rflgsut.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for (auto word : words) {\n        int count = 0;\n \
    \       for (auto c : word) {\n            count += (c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n\
    \            maxCount = count;\n            maxWord = word;\n        }\n    }\n\
    \    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpmztgduqw: /tmp/tmpmztgduqw.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string maxWord = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > maxCount) {\n            maxCount = count;\n \
    \           maxWord = word;\n        }\n    }\n    return maxWord;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpglqy6i6e: /tmp/tmpglqy6i6e.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string maxWord = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        int count = 0;\n        for (auto\
    \ c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp_7h2_65q: /tmp/tmp_7h2_65q.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        int count = 0;\n        for (auto &c : w) {\n       \
    \     if (std::count(w.begin(), w.end(), c) > count) {\n                count\
    \ = std::count(w.begin(), w.end(), c);\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            max = w;\n     \
    \   }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp1vjfsl68: /tmp/tmp1vjfsl68.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto word : words) {\n        int count = 0;\n     \
    \   for (auto c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpqgudlbw3: /tmp/tmpqgudlbw3.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpncyamx9d: /tmp/tmpncyamx9d.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string maxWord = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        int count = 0;\n        for (auto\
    \ c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp7uzrjdu6: /tmp/tmp7uzrjdu6.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpdwyyr9hh: /tmp/tmpdwyyr9hh.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        auto count = std::count(word.begin(),\
    \ word.end(), 'a');\n        if (count > maxCount) {\n            max = word;\n\
    \            maxCount = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp0xnlnncl: /tmp/tmp0xnlnncl.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        auto count = std::count_if(words.begin(),\
    \ words.end(), [&](std::string s) {\n            return s.find(word) != std::string::npos;\n\
    \        });\n        if (count > maxCount) {\n            max = word;\n     \
    \       maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpm_x0fevr: /tmp/tmpm_x0fevr.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max = word;\n         \
    \   max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpvu1tdyon: /tmp/tmpvu1tdyon.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ word : words) {\n        int count = 0;\n        for (auto c : word) {\n   \
    \         if (std::count(max.begin(), max.end(), c) > 0) {\n                count++;\n\
    \            }\n        }\n        if (count > maxCount) {\n            max =\
    \ word;\n            maxCount = count;\n        }\n    }\n    return max;\n}\n\
    int main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprfktcak8: /tmp/tmprfktcak8.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string maxWord = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpxiu4tqhi: /tmp/tmpxiu4tqhi.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0;\n    std::string max_word = \"\";\n    for\
    \ (auto &word : words) {\n        int count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max_count = count;\n  \
    \          max_word = word;\n        }\n    }\n    return max_word;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpzu1euelw: /tmp/tmpzu1euelw.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ max_count = 0;\n    for (auto &i : words) {\n        int count = 0;\n      \
    \  for (auto &j : words) {\n            if (i == j) {\n                continue;\n\
    \            }\n            count += 1;\n        }\n        if (count > max_count)\
    \ {\n            max = i;\n            max_count = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp8frjjr5w: /tmp/tmp8frjjr5w.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(max.begin(), max.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp5dtfhs25: /tmp/tmp5dtfhs25.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp88qs6yl5: /tmp/tmp88qs6yl5.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp11lg8amx: /tmp/tmp11lg8amx.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpj8jxdwj3: /tmp/tmpj8jxdwj3.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpymtt3dp8: /tmp/tmpymtt3dp8.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for(auto &word: words){\n        for(auto &c: word){\n           \
    \ if(c == max){\n                maxCount++;\n            }\n        }\n     \
    \   if(maxCount > 0){\n            max = word;\n            maxCount = 1;\n  \
    \      }\n        else{\n            maxCount = 0;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdkdbwsh9.cpp: In function \u2018std::string find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpdkdbwsh9.cpp:16:18: error: no match for \u2018operator==\u2019\
    \ (operand types are \u2018char\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   16 |             if(c == max){\n\
    \      |                ~ ^~ ~~~\n      |                |    |\n      |     \
    \           char std::string {aka std::__cxx11::basic_string<char>}\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018char\u2019\n   16 |             if(c\
    \ == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |             if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |             if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n        \
    \         from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:64,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and\
    \ \u2018char\u2019\n   16 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/c++/9/string:41,\n            \
    \     from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018\
    char\u2019\n   16 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/string:55,\n        \
    \         from /usr/include/c++/9/bits/locale_classes.h:40,\n                \
    \ from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/string:55,\n        \
    \         from /usr/include/c++/9/bits/locale_classes.h:40,\n                \
    \ from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:297:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_condition&)\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:297:32: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  311 |   operator==(const error_condition& __lhs,\n\
    \      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included from /usr/include/c++/9/bits/locale_facets.h:48,\n\
    \                 from /usr/include/c++/9/bits/basic_ios.h:37,\n             \
    \    from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n     \
    \            from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/complex:463:5: note:\
    \ candidate: \u2018template<class _Tp> constexpr bool std::operator==(const std::complex<_Tp>&,\
    \ const std::complex<_Tp>&)\u2019\n  463 |     operator==(const complex<_Tp>&\
    \ __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   16 |           \
    \  if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018\
    char\u2019\n   16 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::array<_Tp,\
    \ _Nm>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n      |\
    \                     ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched\
    \ types \u2018const std::tuple<_Tps ...>\u2019 and \u2018char\u2019\n   16 | \
    \            if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/functional:59,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n   \
    \              from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  16 |             if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_conv.h:41,\n                 from /usr/include/c++/9/locale:43,\n\
    \                 from /usr/include/c++/9/iomanip:43,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note: \
    \  mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/locale_conv.h:41,\n                 from\
    \ /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   16 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   16 |   \
    \          if(c == max){\n      |                     ^~~\nIn file included from\
    \ /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n     \
    \ |                     ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and\
    \ \u2018char\u2019\n   16 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/c++/9/map:61,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n              \
    \   from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc>\
    \ bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key,\
    \ _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const map<_Key, _Tp,\
    \ _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/map:62,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n          \
    \       from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and\
    \ \u2018char\u2019\n   16 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n \
    \                from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   16 |             if(c == max){\n      |                     ^~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   16 | \
    \            if(c == max){\n      |                     ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/memory:81,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n       \
    \          from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   16 |        \
    \     if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note: \
    \  mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::queue<_Tp,\
    \ _Seq>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n      |\
    \                     ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/set:62,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n          \
    \       from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/stack:61,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n        \
    \         from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::stack<_Tp,\
    \ _Seq>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n      |\
    \                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   16 |            \
    \ if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   16 |            \
    \ if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   16 |            \
    \ if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   16 |             if(c == max){\n     \
    \ |                     ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::valarray<_Tp>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   16 |             if(c == max){\n      |                     ^~~\nIn file\
    \ included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n      \
    \           from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   16 |          \
    \   if(c == max){\n      |                     ^~~\nIn file included from /usr/include/c++/9/forward_list:40,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note:   mismatched types \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018char\u2019 to \u2018std::thread::id\u2019\n  276 |   operator==(thread::id\
    \ __x, thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file\
    \ included from /usr/include/c++/9/random:51,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note: \
    \  mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018char\u2019\n   16 |             if(c == max){\n      |               \
    \      ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note: \
    \  mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n\
    \      |                     ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n    \
    \  |                     ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const std::unordered_multiset<_Value, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n\
    \      |                     ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::allocator<char>&\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n   16 |             if(c == max){\n      |           \
    \          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>\u2019 and \u2018char\u2019\n   16 |             if(c == max){\n\
    \      |                     ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdkdbwsh9.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdkdbwsh9.cpp:16:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::new_allocator<_Tp>\u2019\n   16 |\
    \             if(c == max){\n      |                     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string maxWord = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        int count = 0;\n        for (auto\
    \ c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpyvlibyyb: /tmp/tmpyvlibyyb.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &i : words) {\n        int count = 0;\n        for (auto\
    \ &j : words) {\n            if (i == j) {\n                continue;\n      \
    \      }\n            count += 1;\n        }\n        if (count > maxCount) {\n\
    \            max = i;\n            maxCount = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmplw0q0ee4: /tmp/tmplw0q0ee4.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ word : words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp5trz7wvw: /tmp/tmp5trz7wvw.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        int count = 0;\n        for (auto &c : w) {\n       \
    \     if (std::count(w.begin(), w.end(), c) > count) {\n                count\
    \ = std::count(w.begin(), w.end(), c);\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            max = w;\n     \
    \   }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp7h2_ea38: /tmp/tmp7h2_ea38.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ max_count = 0;\n    for (auto &x : words) {\n        auto count = std::count(x.begin(),\
    \ x.end(), 'a');\n        if (count > max_count) {\n            max = x;\n   \
    \         max_count = count;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpw70d193l: /tmp/tmpw70d193l.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp933g8j_n: /tmp/tmp933g8j_n.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp2nszhchi: /tmp/tmp2nszhchi.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpkha78ixl: /tmp/tmpkha78ixl.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // code here\n    std::string max = \"\";\n    int max_count =\
    \ 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > max_count)\
    \ {\n            max = word;\n            max_count = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprfolgir6: /tmp/tmprfolgir6.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpqwyt8rlk: /tmp/tmpqwyt8rlk.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word: words) {\n        int count = 0;\n        for (auto &c:\
    \ word) {\n            count += 1;\n        }\n        if (count > maxCount) {\n\
    \            max = word;\n            maxCount = count;\n        }\n    }\n  \
    \  return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp4jx_f4_j: /tmp/tmp4jx_f4_j.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max_count = count;\n  \
    \          max = word;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp9kofdtq2: /tmp/tmp9kofdtq2.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > max_count) {\n            max = word;\n         \
    \   max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n \
    \   auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpj4mbe_bn: /tmp/tmpj4mbe_bn.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(max.begin(), max.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprka6j6rq: /tmp/tmprka6j6rq.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    std::string\
    \ temp;\n    int count = 0;\n    for (auto &word : words) {\n        std::sort(word.begin(),\
    \ word.end());\n        temp = word;\n        for (auto &c : word) {\n       \
    \     if (std::count(temp.begin(), temp.end(), c) > count) {\n               \
    \ max = temp;\n                count = std::count(temp.begin(), temp.end(), c);\n\
    \            }\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmprcd4vb65: /tmp/tmprcd4vb65.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(word.begin(), word.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpz_ltpvu3: /tmp/tmpz_ltpvu3.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpw8vnn6fa: /tmp/tmpw8vnn6fa.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto &w : words) {\n        int count = 0;\n        for (auto\
    \ &c : w) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = w;\n            maxCount = count;\n        }\n    }\n \
    \   return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpiioccwzy: /tmp/tmpiioccwzy.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n\
    \            max = word;\n            maxCount = count;\n        }\n    }\n  \
    \  return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp1czl3waa: /tmp/tmp1czl3waa.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count_if(word.begin(), word.end(),\
    \ [&](char c) {\n            return std::tolower(c) != 'a';\n        });\n   \
    \     if (count > max_count) {\n            max = word;\n            max_count\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpn8t9n27c: /tmp/tmpn8t9n27c.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int n = words.size();\n    int max = 0;\n    std::string maxWord\
    \ = \"\";\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n       \
    \ for (int j = 0; j < n; j++) {\n            if (words[j] == words[i]) {\n   \
    \             count++;\n            }\n        }\n        if (count > max) {\n\
    \            max = count;\n            maxWord = words[i];\n        }\n    }\n\
    \    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpfm2342fs: /tmp/tmpfm2342fs.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > max_count) {\n            max_count = count;\n\
    \            max = word;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp7kszbuq8: /tmp/tmp7kszbuq8.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp022hljh9: /tmp/tmp022hljh9.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto word : words) {\n        int count = 0;\n     \
    \   for (auto c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp29uskcw0: /tmp/tmp29uskcw0.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpkil5rt3r: /tmp/tmpkil5rt3r.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max;\n    int max_count = 0;\n    for (auto &word\
    \ : words) {\n        int count = 0;\n        for (auto &c : word) {\n       \
    \     if (std::count(word.begin(), word.end(), c) > 0) {\n                count++;\n\
    \            }\n        }\n        if (count > max_count) {\n            max =\
    \ word;\n            max_count = count;\n        }\n    }\n    return max;\n}\n\
    int main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmptlbusw8k: /tmp/tmptlbusw8k.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpxydsd9tc: /tmp/tmpxydsd9tc.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp91071dy6: /tmp/tmp91071dy6.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ count = 0;\n    for (auto &i : words) {\n        count += i.size();\n      \
    \  if (i.size() > max.size()) {\n            max = i;\n        }\n    }\n    if\
    \ (count > words.size()) {\n        return \"\";\n    }\n    return max;\n}\n\
    int main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpdsv4ubv0: /tmp/tmpdsv4ubv0.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max_count = 0;\n    std::string max_word = \"\";\n    for\
    \ (auto &word : words) {\n        int count = 0;\n        for (auto &c : word)\
    \ {\n            count += 1;\n        }\n        if (count > max_count) {\n  \
    \          max_count = count;\n            max_word = word;\n        }\n    }\n\
    \    return max_word;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpng0509g4: /tmp/tmpng0509g4.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for(auto &word : words) {\n        std::unordered_map<char,\
    \ int> charCount;\n        for(auto &c : word) {\n            charCount[c]++;\n\
    \        }\n        if(charCount.size() > maxCount) {\n            maxCount =\
    \ charCount.size();\n            maxWord = word;\n        }\n    }\n    return\
    \ maxWord;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpkxr9lnq5: /tmp/tmpkxr9lnq5.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &i : words) {\n        auto it = std::find(i.begin(), i.end(),\
    \ max);\n        if (it != i.end()) {\n            maxCount = std::count(i.begin(),\
    \ it, max);\n            max = *it;\n        }\n    }\n    if (maxCount > 1) {\n\
    \        return max;\n    }\n    return words[0];\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n    \
    \             from /usr/include/c++/9/bits/char_traits.h:39,\n               \
    \  from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h: In instantiation\
    \ of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Value = const std::__cxx11::basic_string<char>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:3194:12:\
    \   required from \u2018typename std::iterator_traits<_Iterator>::difference_type\
    \ std::__count_if(_InputIterator, _InputIterator, _Predicate) [with _InputIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >; typename std::iterator_traits<_Iterator>::difference_type = long int]\u2019\
    \n/usr/include/c++/9/bits/stl_algo.h:4121:29:   required from \u2018typename std::iterator_traits<_Iterator>::difference_type\
    \ std::count(_IIter, _IIter, const _Tp&) [with _IIter = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _Tp = std::__cxx11::basic_string<char>;\
    \ typename std::iterator_traits<_Iterator>::difference_type = long int]\u2019\n\
    /tmp/tmpwvx5pdbt.cpp:17:53:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:241:17:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018char\u2019\
    \ and \u2018const std::__cxx11::basic_string<char>\u2019)\n  241 |  { return *__it\
    \ == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>\u2019 and \u2018char\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:55,\n   \
    \              from /usr/include/c++/9/bits/locale_classes.h:40,\n           \
    \      from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  241 | \
    \ { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:297:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_condition&)\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:297:32: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  311 |   operator==(const error_condition& __lhs,\n\
    \      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included from /usr/include/c++/9/bits/locale_facets.h:48,\n\
    \                 from /usr/include/c++/9/bits/basic_ios.h:37,\n             \
    \    from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\n\
    \  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\n\
    \  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n  241 |  { return *__it == _M_value; }\n      |\
    \           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n   \
    \              from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n   \
    \              from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::array<_Tp, _Nm>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/tuple:1419:5: note: candidate: \u2018\
    template<class ... _TElements, class ... _UElements> constexpr bool std::operator==(const\
    \ std::tuple<_Tps ...>&, const std::tuple<_Elements ...>&)\u2019\n 1419 |    \
    \ operator==(const tuple<_TElements...>& __t,\n      |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::tuple<_Tps ...>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/functional:59,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5: note:\
    \ candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n  241 |  { return *__it == _M_value; }\n\
    \      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/list:63,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/map:62,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n     \
    \            from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n  241 |  { return *__it == _M_value; }\n   \
    \   |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::queue<_Tp, _Seq>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/set:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/stack:61,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n   \
    \              from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::stack<_Tp, _Seq>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\n  241 |  { return *__it\
    \ == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\n  241 |  { return *__it\
    \ == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n  241 |  { return *__it == _M_value; }\n     \
    \ |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/forward_list:40,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::forward_list<_Tp, _Alloc>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018char\u2019 to \u2018std::thread::id\u2019\n  276 |   operator==(thread::id\
    \ __x, thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file\
    \ included from /usr/include/c++/9/random:51,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n\
    \      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n\
    \      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::allocator<char>&\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwvx5pdbt.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::new_allocator<_Tp>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmphebdzz9n: /tmp/tmphebdzz9n.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           if (std::count(max.begin(), max.end(), c) > 0) {\n               \
    \ count++;\n            }\n        }\n        if (count > max_count) {\n     \
    \       max_count = count;\n            max = word;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpnbkv2v52: /tmp/tmpnbkv2v52.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(max.begin(), max.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpmmzgdbru: /tmp/tmpmmzgdbru.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string maxWord = \"\";\n    int maxCount\
    \ = 0;\n    for (auto word : words) {\n        int count = 0;\n        for (auto\
    \ c : word) {\n            count += (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n            maxCount\
    \ = count;\n            maxWord = word;\n        }\n    }\n    return maxWord;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpa6ep9pxw: /tmp/tmpa6ep9pxw.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    std::string max2;\n\
    \    std::string max3;\n    std::string max4;\n    std::string max5;\n    std::string\
    \ max6;\n    std::string max7;\n    std::string max8;\n    std::string max9;\n\
    \    std::string max10;\n    std::string max11;\n    std::string max12;\n    std::string\
    \ max13;\n    std::string max14;\n    std::string max15;\n    std::string max16;\n\
    \    std::string max17;\n    std::string max18;\n    std::string max19;\n    std::string\
    \ max20;\n    std::string max21;\n    std::string max22;\n    std::string max23;\n\
    \    std::string max24;\n    std::string max25;\n    std::string max26;\n    std::string\
    \ max27;\n    std::string max28;\n    std::string max29;\n    std::string max30;\n\
    \    std::string max31;\n    std::string max32;\n    std::string max33;\n    std::string\
    \ max34;\n    std::string max35;\n    std::string max36;\n    std::string max37;\n\
    \    std::string max38;\n    std::string max39;\n    std::string max40;\n    std::string\
    \ max41;\n    std::string max42;\n    std::string max43;\n    std::string max44;\n\
    \    std::string max45;\n    std::string max46;\n    std::string max47;\n    std::string\
    \ max48;\n    std::string max49;\n    std::string max50;\n    std::string max51;\n\
    \    std::string max52;\n    std::string max53;\n    std::string max54;\n    std::string\
    \ max55;\n    std::string max56;\n    std::string max57;\n    std::string max58;\n\
    \    std::string max59;\n    std::string max60;\n    std::string max61;\n    std::string\
    \ max62;\n    std::string max63;\n    std::string max64;\n    std::string max65;\n\
    \    std::string max66;\n    std::string max67;\n    std::string max68;\n    std::string\
    \ max69;\n    std::string max70;\n    std::string max71;\n    std::string max72;\n\
    \    std::string max73;\n    std::string max74;\n    std::string max75;\n    std::string\
    \ max76;\n    std::string max77;\n    std::string max78;\n    std::string max79;\n\
    \    std::string max80;\n    std::string max81;\n    std::string max82;\n    std::string\
    \ max83;\n    std::string max84;\n    std::string max85;\n    std::string max86;\n\
    \    std::string max87;\n    std::string max88;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpfaxfq_0k: /tmp/tmpfaxfq_0k.cpp:103: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpv723uqxp: /tmp/tmpv723uqxp.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > max_count) {\n            max = word;\n      \
    \      max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpcnfr9eio: /tmp/tmpcnfr9eio.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > max_count) {\n            max = word;\n      \
    \      max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpua7fgzin: /tmp/tmpua7fgzin.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        auto count = std::count(w.begin(), w.end(), 'a');\n \
    \       if (count > max_count) {\n            max = w;\n            max_count\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp4bk0zdkz: /tmp/tmp4bk0zdkz.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > maxCount) {\n            max = word;\n          \
    \  maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpbvc6xjek: /tmp/tmpbvc6xjek.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n\
    \        }\n        if (count > max_count) {\n            max = word;\n      \
    \      max_count = count;\n        }\n    }\n    return max;\n}\nint main() {\n\
    \    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmphxadka01: /tmp/tmphxadka01.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string maxWord = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            maxCount = count;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpusr2el24: /tmp/tmpusr2el24.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n\
    \        for (auto &c : word) {\n            count += 1;\n        }\n        if\
    \ (count > maxCount) {\n            maxCount = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp561mqrq0: /tmp/tmp561mqrq0.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int maxCount = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp8fiy34pd: /tmp/tmp8fiy34pd.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    int max = 0;\n    std::string maxWord = \"\";\n    for (auto &word\
    \ : words) {\n        auto unique = std::count(word.begin(), word.end(), 0);\n\
    \        if (unique > max) {\n            max = unique;\n            maxWord =\
    \ word;\n        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpba11uwiz: /tmp/tmpba11uwiz.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for(auto &word: words){\n        std::unordered_map<char,int>\
    \ charCount;\n        for(auto &char: word){\n            charCount[char]++;\n\
    \        }\n        if(charCount.size() > maxCount){\n            max = word;\n\
    \            maxCount = charCount.size();\n        }\n    }\n    return max;\n\
    }\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnxw_ofq2.cpp: In function \u2018std::string find_max(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpnxw_ofq2.cpp:16:19: error: expected unqualified-id before\
    \ \u2018char\u2019\n   16 |         for(auto &char: word){\n      |          \
    \         ^~~~\n/tmp/tmpnxw_ofq2.cpp:16:19: error: expected \u2018;\u2019 before\
    \ \u2018char\u2019\n   16 |         for(auto &char: word){\n      |          \
    \         ^~~~\n      |                   ;\n/tmp/tmpnxw_ofq2.cpp:16:23: error:\
    \ expected unqualified-id before \u2018:\u2019 token\n   16 |         for(auto\
    \ &char: word){\n      |                       ^\n/tmp/tmpnxw_ofq2.cpp:16:29:\
    \ error: expected \u2018;\u2019 before \u2018)\u2019 token\n   16 |         for(auto\
    \ &char: word){\n      |                             ^\n      |              \
    \               ;\n/tmp/tmpnxw_ofq2.cpp:17:23: error: expected primary-expression\
    \ before \u2018char\u2019\n   17 |             charCount[char]++;\n      |   \
    \                    ^~~~\n/tmp/tmpnxw_ofq2.cpp:17:23: error: expected \u2018\
    ]\u2019 before \u2018char\u2019\n   17 |             charCount[char]++;\n    \
    \  |                       ^~~~\n      |                       ]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmplw5kmui5: /tmp/tmplw5kmui5.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int max_count\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > max_count)\
    \ {\n            max = word;\n            max_count = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp2_8dejx4: /tmp/tmp2_8dejx4.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int count\
    \ = 0;\n    for (auto &i : words) {\n        count += i.size();\n        if (count\
    \ > max.size()) {\n            max = i;\n        }\n    }\n    return max;\n}\n\
    int main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpb97y942z: /tmp/tmpb97y942z.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max;\n    int max_count = 0;\n\
    \    for (auto &word : words) {\n        int count = 0;\n        for (auto &c\
    \ : word) {\n            count += 1;\n        }\n        if (count > max_count)\
    \ {\n            max = word;\n            max_count = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpacvt7hnl: /tmp/tmpacvt7hnl.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpekkucse8: /tmp/tmpekkucse8.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code goes here\n    std::string maxWord = \"\";\n    int\
    \ maxCount = 0;\n    for (auto word : words) {\n        int count = 0;\n     \
    \   for (auto c : word) {\n            count += (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u');\n        }\n        if (count > maxCount) {\n\
    \            maxCount = count;\n            maxWord = word;\n        }\n    }\n\
    \    return maxWord;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpiug_1a87: /tmp/tmpiug_1a87.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            count += 1;\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp66ixzoo3: /tmp/tmp66ixzoo3.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           count += 1;\n        }\n        if (count > max_count) {\n       \
    \     max_count = count;\n            max = word;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpiye_2qbw: /tmp/tmpiye_2qbw.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            if (std::count(max.begin(), max.end(),\
    \ c) > 0) {\n                count++;\n            }\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpch9ta3ba: /tmp/tmpch9ta3ba.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        int count = std::count(word.begin(), word.end(), 'a');\n\
    \        if (count > maxCount) {\n            max = word;\n            maxCount\
    \ = count;\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate\
    \ = find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp02wiu4ok: /tmp/tmp02wiu4ok.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int maxCount = 0;\n    for (auto\
    \ &word : words) {\n        auto count = std::count(word.begin(), word.end(),\
    \ 'a');\n        if (count > maxCount) {\n            max = word;\n          \
    \  maxCount = count;\n        }\n    }\n    return max;\n}\nint main() {\n   \
    \ auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp4di34txx: /tmp/tmp4di34txx.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max;\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpnz3iyrbd: /tmp/tmpnz3iyrbd.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &word : words) {\n        int count = 0;\n    \
    \    for (auto &c : word) {\n            count += 1;\n        }\n        if (count\
    \ > maxCount) {\n            max = word;\n            maxCount = count;\n    \
    \    }\n    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n\
    \    assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"\
    }))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpr8vquchg: /tmp/tmpr8vquchg.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string maxWord = \"\";\n   \
    \ int maxCount = 0;\n    for (auto word : words) {\n        int count = 0;\n \
    \       for (auto c : word) {\n            count += 1;\n        }\n        if\
    \ (count > maxCount) {\n            maxCount = count;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\nint main() {\n    auto candidate =\
    \ find_max;\n    assert(candidate((std::vector<std::string>({\"name\", \"of\"\
    , \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpwzvl4ktw: /tmp/tmpwzvl4ktw.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Your code here\n    std::string max = \"\";\n    int maxCount\
    \ = 0;\n    for (auto &word : words) {\n        int count = 0;\n        for (auto\
    \ &c : word) {\n            if (std::count(word.begin(), word.end(), c) > 0) {\n\
    \                count++;\n            }\n        }\n        if (count > maxCount)\
    \ {\n            max = word;\n            maxCount = count;\n        }\n    }\n\
    \    return max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmped1tk3w_: /tmp/tmped1tk3w_.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    // Write your code here\n    std::string max = \"\";\n    int\
    \ maxCount = 0;\n    for (auto &i : words) {\n        int count = 0;\n       \
    \ for (auto &j : i) {\n            count += 1;\n        }\n        if (count >\
    \ maxCount) {\n            max = i;\n            maxCount = count;\n        }\n\
    \    }\n    return max;\n}\nint main() {\n    auto candidate = find_max;\n   \
    \ assert(candidate((std::vector<std::string>({\"name\", \"of\", \"string\"})))\
    \ == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"name\"\
    , \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp98gh2o67: /tmp/tmp98gh2o67.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &w : words) {\n        int count = 0;\n        for (auto &c : w) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max_count\
    \ = count;\n            max = w;\n        }\n    }\n    return max;\n}\nint main()\
    \ {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmpdccmuuy9: /tmp/tmpdccmuuy9.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ accepts a list of strings.\n// The list contains different words. Return the\
    \ word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\
    \n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string>\
    \ words) {\n    std::string max = \"\";\n    int max_count = 0;\n    for (auto\
    \ &word : words) {\n        int count = 0;\n        for (auto &c : word) {\n \
    \           if (std::count(max.begin(), max.end(), c) > 0) {\n               \
    \ count++;\n            }\n        }\n        if (count > max_count) {\n     \
    \       max = word;\n            max_count = count;\n        }\n    }\n    return\
    \ max;\n}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
    name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
    aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
    abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n   \
    \ assert(candidate((std::vector<std::string>({\"we\", \"are\", \"gonna\", \"rock\"\
    }))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"we\"\
    , \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
    this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
    b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\"\
    , \"play\", \"play\"}))) == (\"play\"));\n}\n"
  stdout: ''
  stderr: "tmp0ddouueu: /tmp/tmp0ddouueu.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    name\", \"of\", \"string\"}))) == (\"string\")' failed.\n"
  exit_code: -6
  status: Exception
