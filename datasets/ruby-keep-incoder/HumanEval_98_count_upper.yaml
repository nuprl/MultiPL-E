name: HumanEval_98_count_upper
language: ruby
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# count_upper('aBCdEf') returns 1\n# count_upper('abcdefg') returns\
  \ 0\n# count_upper('dBBE') returns 0\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["  s.each_char.with_index.with_object(0) do |c, i|\n    next if i.even?\n\
    \    next if c.upcase == 'A'\n    i += 1\n  end\nend", "  s.gsub(/[aeiou]/).with_index\
    \ { |c, i| i % 2 == 0 ? c.size : 0 }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase == char\n  end\nend", " \
    \ s.each_char.with_index.with_object(0) do |c,i|\n    next if i.even?\n    c =~\
    \ /[AEIOU]/\n    i += 1 if $~\n  end\nend", "  s.gsub(/[AEIOU]/,'').length\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + (index&1\
    \ == 0 ? 0 : char.upcase)\n  end\nend", "  s.chars.each_with_index.inject(0) {|sum,\
    \ (letter, index)| sum + 1 if index % 2 == 0 && letter == 'A' || letter == 'a';\
    \ sum}\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n \
    \   sum + 1 if index&1 == 0 && char.upcase == 'A'\n  end\nend", "  s.each_char.with_index.inject(0)\
    \ { |sum, (_, i)| sum + i.upcase if i.odd? }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n  \
    \  next if c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if\
    \ c == 'u' || c == 'U'\n    next if c == 'y' || c == 'Y'\n    next\n  end\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby,string |>\n<code>", "  s.each_char.with_index.inject(0)\
    \ do |sum, (_, i)|\n    sum + 1 if i.even?\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase == c }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |(char, index), count|\n    count += 1 if char.upcase == char\n  end\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are multiple\
    \ uppercase letters in the same index. For example, `count_upper(\"aBcDeF\")`\
    \ returns `2` instead of `1`.\n<|/ c |>\n<| c |>\n: Good catch. Fixed.\n<|/ c\
    \ |>\n<| a |>\n<code>", "  s.each_char.with_index.with_object(0) do |c,i|\n  \
    \  next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (char, i)| sum + 1 if char.upcase == char && i % 2 == 0 }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |(char, index), count|\n    count += 1 if char.upcase == char\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution, although it does require\
    \ a little more code than I like.\n<|/ c |>\n<| c |>\nI like it too, but I find\
    \ it a bit too complicated for my taste. I'd rather write `s.each_char.with_index.with_object(0)\
    \ do |(char, index), count| count += 1 if char.upcase == char end`\n<|/ c |>\n\
    <| c |>\nI agree, that's why I added the comment to the answer.\n<|/ c |>\n<|\
    \ c |>\nI like it too, but I find it a bit too complicated for my taste. I'd rather\
    \ write `s.each_char.with_index.with_object(0) do |(char, index), count| count\
    \ += 1 if char.upcase == char end`\n<|/ c |>\n<| c |>\nI like it too, but I find\
    \ it a bit too complicated for my taste. I'd rather write `s.each_char.with_index.with_object(0)\
    \ do |(char, index), count| count += 1 if char.upcase == char end`\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  s.each_char.with_index.with_object(0) do |c,i|\n\
    \    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`each_char.with_index.with_object({})\
    \ { |(char, index), h| h[char] = index if index % 2 == 0 }.size` - no need for\
    \ inject, just `each_char.with_index.with_object({}) { |(char, index), h| h[char]\
    \ = index if index % 2 == 0 }.size`\n<|/ c |>\n<| c |>\nThanks, I didn't know\
    \ about `each_char.with_index.with_object`\n<|/ c |>\n<| c |>\n`each_char.with_index.with_object({})\
    \ { |(char, index), h| h[char] = index if index % 2 == 0 }.size` - no need for\
    \ inject, just `each_char.with_index.with_object({}) { |(char, index), h| h[char]\
    \ = index if index % 2 == 0 }.size`\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Can you please explain the code a bit? I am new to Ruby and trying to understand\
    \ it.\n<|/ c |>\n<| c |>\n`each_char.with_index.with_object({}) { |(char, index),\
    \ h| h[char] = index if index % 2 == 0 }.size` - no need for inject, just `each_char.with_index.with_object({})\
    \ { |(char, index), h| h[char] = index if index % 2 == 0 }.size`\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if char == 'A' || char == 'a' && index%2 == 0\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for your answer. Your solution\
    \ works but I am looking for something more efficient. I am looking for a solution\
    \ which does not require me to iterate over the string twice.\n<|/ c |>\n<| c\
    \ |>\n: I added a more efficient solution.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Your solution works but I am looking for something more efficient. I\
    \ am looking for a solution which does not require me to iterate over the string\
    \ twice.\n<|/ c |>\n<| c |>\n: I added a more efficient solution.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + 1 if char.upcase\
    \ && index%2 == 0\n  end\nend", "  s.chars.each_with_index.inject(0) {|sum, (_,\
    \ i)| sum + i.odd? ? 1 : 0}\nend", "  s.chars.each_with_index.inject(0) {|sum,\
    \ (_, i)| sum + i.odd? ? 1 : 0}\nend", "  s.chars.each_with_index.inject(0) do\
    \ |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |char, index|\n    if\
    \ index%2 == 0 && char.upcase == 'A'\n      char.upcase = 'a'\n      char.downcase\
    \ = 'A'\n    end\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    next if c.upcase == 'A'\n    i += 1\n  end\n\
    end", "  s.chars.each_with_index.inject(0) {|sum, (_, i)| sum + 1 if i.even? &&\
    \ i.upcase == true }\nend", "  s.chars.each_with_index.inject(0) { |sum, (c, i)|\
    \ sum + 1 if i % 2 == 0 && c.upcase == c }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |(char, index), count|\n    if index%2 == 0 && char.upcase == 'A'\n     \
    \ count += 1\n    end\n  end\nend", "  s.chars.each_with_index.inject(0) { |sum,\
    \ (c, i)| sum + 1 if i % 2 == 0 && c.upcase == c }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.inject(0) do |sum, (_, i)|\n    sum +\
    \ 1 if i.even?\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n  end\nend", " \
    \ s.downcase!\n  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase\
    \ == char\n      i += 1\n    end\n  end\n  s.count('a'..'z').to_i\nend", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (c,i)| sum + 1 if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U' }\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum\
    \ + 1 if char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase == char\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + 1 if index%2\
    \ == 0 && char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (letter, index)| sum + 1 if index % 2 == 0 && letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\n\
    end", "  s.each_char.with_index.inject(0) { |sum, (_, i)| sum + i.upcase if i.odd?\
    \ }\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum +\
    \ 1 if i % 2 == 0 && char.upcase == char\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like your solution, however it fails for strings like `'aBcD'`\n\
    <|/ c |>\n<| c |>\n: I added a version that works with strings like `'aBcD'`.\n\
    <|/ c |>\n<| c |>\nI like your solution, however it fails for strings like `'aBcD'`\n\
    <|/ c |>\n<| c |>\n: I added a version that works with strings like `'aBcD'`.\n\
    <|/ c |>\n<| a |>\n<code>", "  s.downcase!\n  s.each_char.with_index do |char,\
    \ i|\n    next if i % 2 == 0\n    next if char.upcase == char\n    next if char.upcase\
    \ == 'A'\n    next if char.upcase == 'a'\n    next if char.upcase == 'E'\n   \
    \ next if char.upcase == 'e'\n    next if char.upcase == 'I'\n    next if char.upcase\
    \ == 'i'\n    next if char.upcase == 'O'\n    next if char.upcase == 'o'\n   \
    \ next if char.upcase == 'U'\n    next if char.upcase == 'u'\n    next if char.upcase\
    \ == 'Y'\n    next if char.upcase == 'y'\n    next if char.upcase == 'a'\n   \
    \ next if char.upcase == 'A'\n    next if char.upcase == 'a'\n    next if char.upcase\
    \ == 'E'\n    next if char.upcase == 'e'\n    next if char.upcase == 'I'\n   \
    \ next if char.upcase == 'i'\n    next if char.upcase == 'O'\n    next if char.upcase\
    \ == 'o'\n    next if char.upcase == 'U'\n    next if char.upcase == 'u'\n   \
    \ next if char.upcase == 'Y'\n    next if char.upcase == 'y'\n    next if char.upcase\
    \ == 'a'\n    next if char.upcase == 'A'\n    next if char.upcase == 'a'\n   \
    \ next if char.upcase == 'E'\n    next if char.upcase == 'e'\n    next if char.upcase\
    \ == 'I'\n    next if char.upcase == 'i'\n    next if char.upcase == 'O'\n   \
    \ next if char.upcase == 'o'\n    next if char.upcase == 'U'\n    next if char.upcase\
    \ == 'u'\n    next if char.upcase == 'Y'\n    next if char.upcase == 'y'\n   \
    \ next if char.upcase == 'a'\n    next if char.upcase == 'A'\n    next if char.upcase\
    \ == 'a'\n    next if char.upcase == 'E'\n    next if char.upcase == 'e'\n   \
    \ next if char.upcase == 'I'\n    next if char.upcase == 'i'\n    next ", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (c,ix)| sum + 1 if c == 'A' && ix % 2 == 0 }\nend", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (letter, index)| sum + 1 if index % 2 == 0 && letter == 'A' || letter\
    \ == 'a'}\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n\
    \    sum + ((index % 2 == 0) ? char.upcase : 0)\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase == char\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + 1 if char.upcase\
    \ == char\n  end\nend", "  s.gsub(/[aeiou]/).inject(0) { |sum, char| sum + 1 if\
    \ char.upcase }\nend", "  s.each_char.with_index.with_object(0) do |c,i|\n   \
    \ next if i.even?\n    next if c.upcase == c\n    i += 1\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby |>\n<code>", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    if c == 'A' || c == 'a' then\n      i += 1 if i % 2 == 0\n   \
    \ end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n\
    \  s.each_char.with_index do |c,i|\n    if i % 2 == 0 && c.upcase == c\n     \
    \ i += 1\n    end\n  end\n  s.size - s.chars.count { |c| c.upcase == c }\nend",
  "  s.downcase!\n  s.each_char.with_index do |c,i|\n    if i % 2 == 0 && c.upcase\
    \ == c\n      yield i\n    end\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n\
    \      i += 1 if i % 2 == 0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a tags=ruby |>\n<code>", "  s.each_char.with_index.with_object(0) do |c,i|\n\
    \    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`each_char` would be\
    \ more idiomatic than `each_with_index`.\n<|/ c |>\n<| c |>\n`each_char` would\
    \ be more idiomatic than `each_with_index` but `each_char` would not work if you\
    \ wanted to count the vowels in each character of the string. `each_char` would\
    \ return an enumerator that would yield each character of the string one at a\
    \ time. `each_with_index` would return an enumerator that would yield each character\
    \ of the string along with its index. `each_char` would not work if you wanted\
    \ to count the vowels in each character of the string and return the count as\
    \ an array. `each_with_index` would not work if you wanted to count the vowels\
    \ in each character of the string and return the count as an array.\n<|/ c |>\n\
    <| c |>\n`each_char` would not work if you wanted to count the vowels in each\
    \ character of the string and return the count as an array. `each_with_index`\
    \ would not work if you wanted to count the vowels in each character of the string\
    \ and return the count as an array.\n<|/ c |>\n<| c |>\n`each_char` would not\
    \ work if you wanted to count the vowels in each character of the string and return\
    \ the count as an array. `each_with_index` would not work if you wanted to count\
    \ the vowels in each character of the string and return the count as an array.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.gsub(/[AEIOU]/,'').length\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum +\
    \ 1 if index % 2 == 0 && char.upcase == char\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without using inject and each_with_index?\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't use inject and each_with_index.\n<|/ c |>\n<| c |>\nThanks so much!\
    \ I appreciate it!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + (index%2 == 0 && char.upcase == 'A')\n  end\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum +\
    \ (char == 'A' || char == 'a' ? 0 : 1)\n  end\nend", "  s.gsub(/[AEIOU]/, '').length\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum +\
    \ 1 if index % 2 == 0 && char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    if i % 2 == 0 && c.upcase == c\n      i += 1\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder why\
    \ you use `each_char` instead of `each_char.with_index`? The latter seems more\
    \ readable to me.\n<|/ c |>\n<| c |>\nI used `each_char` because I wanted to keep\
    \ the same return type as in the question. `each_char.with_index` would return\
    \ an enumerator that yields pairs of characters and integers, whereas `each_char`\
    \ would yield characters and integers. I wanted to keep the same return type as\
    \ in the question, but I wanted to be able to use `with_index` on the enumerator\
    \ returned by `each_char`.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.each_char.with_index.inject(0)\
    \ do |sum, (c, i)|\n    sum + 1 if i % 2 == 0 && c.upcase == c\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) { |sum, (letter, i)| sum + 1 if i % 2 == 0\
    \ && letter == 'A' || letter == 'a' } \nend", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'a' || c ==\
    \ 'A'\n    next if c == 'e' || c == 'E'\n    next if c == 'i' || c == 'I'\n  \
    \  next if c == 'o' || c == 'O'\n    next if c == 'u' || c == 'U'\n    next\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n \
    \   sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend", "  s.gsub(/[aeiou]/i).inject(0)\
    \ {|sum, char| sum + 1 if char.upcase == char }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |char, index|\n    index.even?\
    \ ? char.upcase : char\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum,\
    \ (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n  end\n\
    end", "  s.each_char.with_index.inject(0) do |sum, (_, i)|\n    sum + 1 if i.even?\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |c,i|\n    next if i.even?\n\
    \    next if c == 'Z'\n    next if c == 'z'\n    next if c == 'A'\n    next if\
    \ c == 'a'\n    next if c == 'B'\n    next if c == 'b'\n    next if c == 'C'\n\
    \    next if c == 'c'\n    next if c == 'D'\n    next if c == 'd'\n    next if\
    \ c == 'E'\n    next if c == 'e'\n    next if c == 'F'\n    next if c == 'f'\n\
    \    next if c == 'G'\n    next if c == 'g'\n    next if c == 'H'\n    next if\
    \ c == 'h'\n    next if c == 'I'\n    next if c == 'i'\n    next if c == 'J'\n\
    \    next if c == 'j'\n    next if c == 'K'\n    next if c == 'k'\n    next if\
    \ c == 'L'\n    next if c == 'l'\n    next if c == 'M'\n    next if c == 'm'\n\
    \    next if c == 'N'\n    next if c == 'n'\n    next if c == 'O'\n    next if\
    \ c == 'o'\n    next if c == 'P'\n    next if c == 'p'\n    next if c == 'Q'\n\
    \    next if c == 'q'\n    next if c == 'R'\n    next if c == 'r'\n    next if\
    \ c == 'S'\n    next if c == 's'\n    next if c == 'T'\n    next if c == 't'\n\
    \    next if c == 'U'\n    next if c == 'u'\n    next if c == 'V'\n    next if\
    \ c == 'v'\n    next if c == 'W'\n    next if c == 'w'\n    next if c == 'X'\n\
    \    next if c == 'x'\n    next if c == 'Y'\n    next if c == 'y'\n    next if\
    \ c == 'Z'\n    next if c == 'z'\n    next if c == 'a'\n    next if c == 'b'\n\
    \    next if c == 'c'\n    next if c == 'd'\n    next if c == 'e'\n    next if\
    \ c == 'f'\n    next if c == 'g'\n    next if c == 'h'\n    next if c == 'i'\n\
    \    next if c == '", "  s.each_char.with_index.with_object(0) do |c, i|\n   \
    \ next if i.even?\n    next if c.upcase == c\n    yield(c) ? yield(c) + 1 : yield(c)\
    \ + 1\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like this solution,\
    \ although I wonder if there is a way to avoid the use of yield.\n<|/ c |>\n<|\
    \ c |>\nI added a version without `yield`.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.each_char.with_index.with_object(0) do |c,i|\n    next if i.even?\n\
    \    c =~ /[AEIOU]/\n    i += 1 if c == 'A'\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    if c == 'A' || c == 'a'\n      i += 1 if i % 2 == 0\n    end\n\
    \  end\nend", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |c, i|\n    if c ==\
    \ 'A' || c == 'a' || (c == 'B' || c == 'b') || (c == 'C' || c == 'c') || (c ==\
    \ 'D' || c == 'd') || (c == 'E' || c == 'e') || (c == 'F' || c == 'f') || (c ==\
    \ 'G' || c == 'g')\n      i += 1 if i % 2 == 0\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nI like your solution. One thing though, `each_char`\
    \ will iterate over the string twice (once to count the characters, once to iterate\
    \ over them).\n<|/ c |>\n<| c |>\n: Yes, that's true. I was trying to avoid that\
    \ by using the `with_index` method on the enumerator, but I guess that's not possible.\
    \ I'll edit my answer to show that.\n<|/ c |>\n<| c |>\nI like your solution.\
    \ One thing though, `each_char` will iterate over the string twice (once to count\
    \ the characters, once to iterate over them).\n<|/ c |>\n<| c |>\n: Yes, that's\
    \ true. I was trying to avoid that by using the `with_index` method on the enumerator,\
    \ but I guess that's not possible. I'll edit my answer to show that.\n<|/ c |>\n\
    <| c |>\nI like your solution. One thing though, `each_char` will iterate over\
    \ the string twice (once to count the characters, once to iterate over them).\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum +\
    \ 1 if index % 2 == 0 && char.upcase == char\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for your answer. Could you please explain the code a little\
    \ bit? I understand that each_with_index will iterate through the string and add\
    \ each character to the sum, but what is the purpose of inject? What does it do?\n\
    <|/ c |>\n<| c |>\n`inject` will iterate through the string and add each character\
    \ to the sum. `inject` will return the sum of the iterations. `inject` will return\
    \ the sum of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will return the sum of the iterations. `inject` will return the sum of the iterations.\
    \ `inject` will return the sum of the iterations. `inject` will return the sum\
    \ of the iterations. `inject` will return the sum of the iterations. `inject`\
    \ will ", "  s.each_char.with_index.with_object(0) do |(char, index), count|\n\
    \    count += 1 if char.upcase == char\n  end\nend", "  s.gsub(/[aeiou]/).inject(0)\
    \ {|sum, char| sum + 1 if char.upcase == char }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (_, i)|\n    sum + 1 if i.even?\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work if there are multiple uppercase letters in a\
    \ row. For example, `count_upper(\"abBcCdEf\")` returns `2`, when it should be\
    \ `1`.\n<|/ c |>\n<| c |>\n: It does work, try it out. `count_upper(\"abBcCdEf\"\
    )` returns `1`.\n<|/ c |>\n<| c |>\nOh, sorry, I missed the fact that `each_with_index`\
    \ returns two elements. I thought it returned a pair. My bad.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  s.downcase!\n  s.each_char.with_index do |c,i|\n    if i % 2\
    \ == 0 && c.upcase == c\n      count += 1\n    end\n  end\n  count\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  s.gsub(/[AEIOU]/, '').length\n\
    end", "  s.each_char.with_index.with_object(0) do |c, i|\n    if i % 2 == 0 &&\
    \ c.upcase == c\n      i += 1\n    end\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (c, i)|\n    sum + (c == 'A' || c == 'a' ? 0 : 1)\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) {|sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase\
    \ == c}\nend", "  s.each_char.with_index.with_object(0) do |c,i|\n    next if\
    \ i.even?\n    c =~ /[AEIOU]/\n    i += 1 if c == 'A'\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,regex |>\n<| c |>\nThanks for the answer. I'm still trying to understand\
    \ how this works. Can you please explain how it works?\n<|/ c |>\n<| c |>\nI added\
    \ some comments to the code. Let me know if that helps.\n<|/ c |>\n<| c |>\nThanks\
    \ for the explanation. I'm still trying to understand how this works. Can you\
    \ please explain how it works?\n<|/ c |>\n<| c |>\nI added some comments to the\
    \ code. Let me know if that helps.\n<|/ c |>\n<| c |>\nThanks for the explanation.\
    \ I'm still trying to understand how this works. Can you please explain how it\
    \ works?\n<|/ c |>\n<| a tags=ruby,regex |>\n<code>", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    i += 1 if c == 'A' || c == 'a'\n    i += 1 if c == 'E' || c ==\
    \ 'e'\n    i += 1 if c == 'I' || c == 'i'\n    i += 1 if c == 'O' || c == 'o'\n\
    \    i += 1 if c == 'U' || c == 'u'\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (c,i)| sum + 1 if c == 'A' && i % 2 == 0 }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |char, index|\n    if index%2 == 0 && char.upcase == char\n      index\n\
    \    end\n  end\nend", "  s.downcase!\n  s.each_char.with_index do |c, i|\n  \
    \  if i % 2 == 0 && c.upcase == c\n      yield i + 1\n    end\n  end\nend", " \
    \ s.each_char.with_index.inject(0) { |sum, (_, i)| sum + i.odd? ? 1 : 0 }\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + 1 if i % 2 ==\
    \ 0 && char.upcase == char\n  end\nend", "  s.gsub(/[aeiou]/i).inject(0) {|sum,\
    \ char| sum + 1 if char.upcase == char }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    if c == 'A' || c == 'a' || (c == 'B' || c == 'b') || (c == 'C'\
    \ || c == 'c') || (c == 'D' || c == 'd') || (c == 'E' || c == 'e') || (c == 'F'\
    \ || c == 'f')\n      i += 1 if i % 2 == 0\n    end\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |(char, i), count|\n\
    \    count += 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\n\
    end", "  s.each_char.with_index.with_object(0) do |c,i|\n    next if i.even?\n\
    \    next if c.upcase == 'A'\n    next if c.upcase == 'a'\n    next if c.upcase\
    \ == 'E'\n    next if c.upcase == 'e'\n    next if c.upcase == 'I'\n    next if\
    \ c.upcase == 'i'\n    next if c.upcase == 'O'\n    next if c.upcase == 'o'\n\
    \    next if c.upcase == 'U'\n    next if c.upcase == 'u'\n    next if c.upcase\
    \ == 'Y'\n    next if c.upcase == 'y'\n    next if c.upcase == 'a'\n    next if\
    \ c.upcase == 'e'\n    next if c.upcase == 'i'\n    next if c.upcase == 'o'\n\
    \    next if c.upcase == 'u'\n    next if c.upcase == 'y'\n    next if c.upcase\
    \ == 'A'\n    next if c.upcase == 'a'\n    next if c.upcase == 'E'\n    next if\
    \ c.upcase == 'e'\n    next if c.upcase == 'I'\n    next if c.upcase == 'i'\n\
    \    next if c.upcase == 'O'\n    next if c.upcase == 'o'\n    next if c.upcase\
    \ == 'U'\n    next if c.upcase == 'u'\n    next if c.upcase == 'Y'\n    next if\
    \ c.upcase == 'y'\n    next if c.upcase == 'a'\n    next if c.upcase == 'e'\n\
    \    next if c.upcase == 'i'\n    next if c.upcase == 'o'\n    next if c.upcase\
    \ == 'u'\n    next if c.upcase == 'y'\n    next if c.upcase == 'A'\n    next if\
    \ c.upcase == 'a'\n    next if c.upcase == 'E'\n    next if c.upcase == 'e'\n\
    \    next if c.upcase == 'I'\n    next if c.upcase == 'i'\n    next if c.upcase\
    \ == 'O'\n    next if c.upcase == 'o'\n    next if c.upcase == 'U'\n    next if\
    \ c.upcase == 'u'\n    next if c.upcase == 'Y'\n    next if c.upcase == 'y'\n\
    \    next if c.upcase == 'a'\n    next if c.upcase == 'e'\n    next if c.upcase\
    \ == 'i'\n    next if c.", "  s.each_char.with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    i = i % 2\n    next if i == 0\n    next if c.upcase == c\n  \
    \  next\n  end\nend", "  s.downcase!\n  s.each_char.with_index do |char, i|\n\
    \    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n  end\n  s.size\
    \ - s.chars.count { |c| c.upcase == c }\nend", "  s.each_char.with_index do |char,\
    \ i|\n    return 0 if i % 2 == 0 && char.upcase == char\n  end\n  0\nend", " \
    \ s.each_char.with_index.with_object(0) do |c,i|\n    i += 1 if c == 'A'\n   \
    \ i += 1 if c == 'E'\n    i += 1 if c == 'I'\n    i += 1 if c == 'O'\n    i +=\
    \ 1 if c == 'U'\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this\
    \ solution, but I wonder if it can be made more concise. For example, `s.each_char.with_index.with_object(0)\
    \ do |c,i| i += 1 if c == 'A'; i += 1 if c == 'E'; i += 1 if c == 'I'; i += 1\
    \ if c == 'O'; i += 1 if c == 'U'; end` could be written `s.each_char.with_index.with_object(0)\
    \ do |c,i| i += 1 if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\
    \ end`.\n<|/ c |>\n<| c |>\nI agree, that is a nice improvement. I'll add it to\
    \ the answer.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (c,ix)| sum + 1 if c == 'A' && ix % 2 == 0 }\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c, i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n  \
    \  next if c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if\
    \ c == 'u' || c == 'U'\n    next if c == 'y' || c == 'Y'\n    next\n  end\nend",
  "  s.each_char.with_index do |c,i|\n    if i % 2 == 0 && c.upcase == c\n      puts\
    \ i\n    end\n  end\nend", "  s.each_char.with_index.with_object(0) do |c, i|\n\
    \    if c == 'A' || c == 'a' || (i % 2 == 0 && c == 'B' || c == 'b')\n      i\
    \ += 1 if c == 'B' || c == 'b'\n    end\n  end\nend", "  s.gsub(/[aeiou]/i) {\
    \ |c| c.upcase }.count(\"A\") + s.count(\"a\")\nend", "  s.each_char.with_index\
    \ do |c, i|\n    if i % 2 == 0 && c.upcase == c\n      i += 1\n    end\n  end\n\
    end", "  s.each_char.with_index.with_object(0) do |c,i|\n    if c == 'A' || c\
    \ == 'E' || c == 'I' || c == 'O' || c == 'U'\n      i += 1 if i % 2 == 0\n   \
    \ end\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n\
    \    sum + ((index / 2).zero? ? char.upcase : char.downcase)\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\n`each_with_index` can be replaced with `each_char`\n\
    <|/ c |>\n<| c |>\n: Yes, but that would require an extra `inject` call, which\
    \ would make the code more complicated. `each_char` would also require an extra\
    \ `sum` variable, which would make the code more complicated. `each_with_index`\
    \ would require an extra `char` variable, which would make the code more complicated.\
    \ `each_char` would also require an extra `index` variable, which would make the\
    \ code more complicated. `each_with_index` would require an extra `char` variable,\
    \ which would make the code more complicated. `each_char` would also require an\
    \ extra `index` variable, which would make the code more complicated. `each_with_index`\
    \ would require an extra `char` variable, which would make the code more complicated.\
    \ `each_char` would also require an extra `index` variable, which would make the\
    \ code more complicated. `each_with_index` would require an extra `char` variable,\
    \ which would make the code more complicated. `each_char` would also require an\
    \ extra `index` variable, which would make the code more complicated. `each_with_index`\
    \ would require an extra `char` variable, which would make the code more complicated.\
    \ `each_char` would also require an extra `index` variable, which would make the\
    \ code more complicated. `each_with_index` would require an extra `char` variable,\
    \ which would make the code more complicated. `each_char` would also require an\
    \ extra `index` variable, which would make the code more complicated. `each_with_index`\
    \ would require an extra `char` variable, which would make the code more complicated.\
    \ `each_char` would also require an extra `index` variable, which would make the\
    \ code more complicated. `each_with_index` would require an extra `char` variable,\
    \ which would make the code more complicated. `each_char` would also require an\
    \ extra `index` variable, which would make the code more complicated. `each_with_index`\
    \ would require an extra `char` variable, which would make the code more complicated.\
    \ `each_char` would also require an extra `index` variable, which would make the\
    \ code more complicated. `each_with_index` would require an extra `char", "  s.each_char.with_index.with_object(0)\
    \ do |(char, index), count|\n    count += 1 if char.upcase == char\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, but I believe it can\
    \ be simplified to `s.each_char.with_index.with_object(0) do |(char, index), count|\
    \ count += 1 if char.upcase == char end`\n<|/ c |>\n<| c |>\nI agree with you.\
    \ I've edited my answer to include your suggestion.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I believe it can be simplified to `s.each_char.with_index.with_object(0)\
    \ do |(char, index), count| count += 1 if char.upcase == char end`\n<|/ c |>\n\
    <| c |>\nI like your solution, but I believe it can be simplified to `s.each_char.with_index.with_object(0)\
    \ do |(char, index), count| count += 1 if char.upcase == char end`\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  s.chars.each_with_index.inject(0) {|sum, (c, i)|\
    \ sum + 1 if i.even? && c == 'A'}\nend", "  s.each_char.with_index.inject(0) {\
    \ |sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase == c }\nend", "  s.downcase!\n\
    \  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase != char\n\
    \      0\n    elsif char.upcase == char\n      1\n    end\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, however I believe that `each_char` will\
    \ iterate over the string twice (once to count the characters and once to iterate\
    \ over the characters). Also, I think `each_char` will iterate over the string\
    \ twice (once to count the characters and once to iterate over the characters).\
    \ Also, `each_char` will iterate over the string twice (once to count the characters\
    \ and once to iterate over the characters). Also, `each_char` will iterate over\
    \ the string twice (once to count the characters and once to iterate over the\
    \ characters). Also, `each_char` will iterate over the string twice (once to count\
    \ the characters and once to iterate over the characters). Also, `each_char` will\
    \ iterate over the string twice (once to count the characters and once to iterate\
    \ over the characters). Also, `each_char` will iterate over the string twice (once\
    \ to count the characters and once to iterate over the characters). Also, `each_char`\
    \ will iterate over the string twice (once to count the characters and once to\
    \ iterate over the characters). Also, `each_char` will iterate over the string\
    \ twice (once to count the characters and once to iterate over the characters).\
    \ Also, `each_char` will iterate over the string twice (once to count the characters\
    \ and once to iterate over the characters). Also, `each_char` will iterate over\
    \ the string twice (once to count the characters and once to iterate over the\
    \ characters). Also, `each_char` will iterate over the string twice (once to count\
    \ the characters and once to iterate over the characters). Also, `each_char` will\
    \ iterate over the string twice (once to count the characters and once to iterate\
    \ over the characters). Also, `each_char` will iterate over the string twice (once\
    \ to count the characters and once to iterate over the characters). Also, `each_char`\
    \ will iterate over the string twice (once to count the characters and once to\
    \ iterate over the characters). Also, `each_char` will iterate over the string\
    \ twice (once to count the characters and once to iterate over the characters).\
    \ Also, `each_char` will iterate over the string twice (once to count the characters\
    \ and once to iterate over the characters). Also, `each_char` will iterate over\
    \ the string twice (once ", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend",
  "  s.each_char.with_index.inject(0) {|sum, (c, i)| sum + if i % 2 == 0 then c.upcase\
    \ else c end}\nend", "  s.chars.each_with_index.inject(0) {|sum, (_, i)| sum +\
    \ i.odd? ? 1 : 0}\nend", "  s.chars.each_with_index.inject(0) {|sum, (c, i)| sum\
    \ + 1 if i % 2 == 0 && c.upcase == c}\nend", "  s.each_char.with_index.with_object(0)\
    \ do |(char, index), count|\n    count += 1 if char.upcase == char\n  end\nend",
  "  s.each_char.with_index.inject(0) { |sum, (_, i)| sum + (i.odd? ? 1 : 0) }\nend",
  "  s.each_char.with_index.with_object(0) do |(char, index), count|\n    count +=\
    \ 1 if char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\n\
    end", "  s.chars.each_with_index.inject(0) {|sum, (c, i)| sum + 1 if i % 2 ==\
    \ 0 && c.upcase == c}\nend", "  s.chars.each_with_index.inject(0) do |sum, (char,\
    \ index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n    sum + 1 if index%2\
    \ == 0 && char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (letter, i)| sum + 1 if i % 2 == 0 && letter == 'A' || letter == 'a'\
    \ } \nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n   \
    \ sum + (char == 'A' || char == 'E' || char == 'I' || char == 'O' || char == 'U'\
    \ ? 1 : 0)\n  end\nend", "  s.chars.each_with_index.inject(0) { |sum, (c,ix)|\
    \ sum + 1 if c == 'A' && ix % 2 == 0 }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\n\
    end", "  s.each_char.with_index.with_object(0) do |c,i|\n    if i % 2 == 0 &&\
    \ c.upcase == c\n      i += 1 # increment the counter\n    end\n  end\nend", " \
    \ s.chars.each_with_index.inject(0) do |sum, (_, i)|\n    sum + 1 if i.even?\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) {|sum, (c,i)| sum + 1 if c\
    \ == 'A' && i % 2 == 0 }\nend", "  s.each_char.with_index.with_object(0) do |c,\
    \ i|\n    if c == 'A' || c == 'a' || (c == 'B' || c == 'b') || (c == 'C' || c\
    \ == 'c') || (c == 'D' || c == 'd') || (c == 'E' || c == 'e') || (c == 'F' ||\
    \ c == 'f')\n      i += 1 if i % 2 == 0\n    end\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, although I wonder\
    \ if it would be more efficient to count the vowels first and then count the uppercase\
    \ letters. I suspect that would be more efficient than looping through the string\
    \ twice.\n<|/ c |>\n<| c |>\nYes, that would be more efficient. I'll add it to\
    \ the answer.\n<|/ c |>\n<| c |>\nI added a solution that counts the vowels first,\
    \ then counts the uppercase letters.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ s.chars.each_with_index.inject(0) {|sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase\
    \ == c}\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work. `'aBCdEf'.chars.each_with_index.inject(0)\
    \ {|sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase == c}` returns `0`, not `1`.\n\
    <|/ c |>\n<| c |>\n: Yes, I missed the fact that `i` is an index. Fixed.\n<|/\
    \ c |>\n<| c |>\nI like your use of inject to count the vowels. I didn't know\
    \ about that method.\n<|/ c |>\n<| c |>\n: I like it too. `inject` has its uses.\
    \ I use it all the time for counting things.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  s.each_char.with_index.with_object(0) do |(char, i), count|\n    count += 1 if\
    \ char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0) do |sum,\
    \ (char, index)|\n    sum + 1 if index%2 == 0 && char.upcase == char\n  end\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like this solution, but I\
    \ wonder why you use `each_with_index` instead of `each_char`?\n<|/ c |>\n<| c\
    \ |>\n: I didn't know about `each_char`. I thought `each_with_index` was the way\
    \ to go. Thanks for pointing that out.\n<|/ c |>\n<| c |>\n`each_char` would work\
    \ just as well. `each_with_index` is more idiomatic for Ruby programmers.\n<|/\
    \ c |>\n<| c |>\nI like your solution, but I wonder why you use `each_char` instead\
    \ of `each_with_index`?\n<|/ c |>\n<| c |>\n: I didn't know about `each_char`.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  s.each_char.with_index.inject(0)\
    \ do |sum, (_, i)|\n    sum + (i % 2 == 0 ? 0 : 1)\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\n`each_char.with_index.inject(0)` can be written `each_char.with_index.inject(:+)`\n\
    <|/ c |>\n<| c |>\n: Yes, but that doesn't make it any more readable. `each_char.with_index.inject(:+)`\
    \ is just as readable as `each_char.with_index.inject(0)`.\n<|/ c |>\n<| c |>\n\
    I agree that `each_char.with_index.inject(:+)` is more readable, but I disagree\
    \ that it is more readable. `each_char.with_index.inject(0)` reads better than\
    \ `each_char.with_index.inject(:+)`\n<|/ c |>\n<| c |>\n: I agree that `each_char.with_index.inject(0)`\
    \ is more readable, but I disagree that it is more readable. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than `each_char.with_index.inject(0)`. `each_char.with_index.inject(:+)`\
    \ reads better than ", "  s.each_char.with_index.with_object(0) do |c, i|\n  \
    \  next if i.even?\n    next if c == 'A' || c == 'a'\n    next if c == 'E' ||\
    \ c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O' || c == 'o'\n\
    \    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c == 'y'\n    next\
    \ if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n    next if c ==\
    \ 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if c == 'u' || c\
    \ == 'U'\n    next if c == 'y' || c == 'Y'\n    next if c == 'y' || c == 'Y'\n\
    \    next if c == 'Y' || c == 'y'\n    next if c == 'Y' || c == 'Y'\n    next\
    \ if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c ==\
    \ 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c\
    \ == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n\
    \    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next\
    \ if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c ==\
    \ 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c\
    \ == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n\
    \    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next\
    \ if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c ==\
    \ 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c\
    \ == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n\
    \    next if c == 'Y' || c == 'Y'\n    next if ", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'a' || c ==\
    \ 'A'\n    next if c == 'e' || c == 'E'\n    next if c == 'i' || c == 'I'\n  \
    \  next if c == 'o' || c == 'O'\n    next if c == 'u' || c == 'U'\n    next if\
    \ c == 'A' || c == 'a'\n    next if c == 'E' || c == 'e'\n    next if c == 'I'\
    \ || c == 'i'\n    next if c == 'O' || c == 'o'\n    next if c == 'U' || c ==\
    \ 'u'\n    next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n  \
    \  next if c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if\
    \ c == 'u' || c == 'U'\n    next if c == 'A' || c == 'a'\n    next if c == 'E'\
    \ || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O' || c ==\
    \ 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'a' || c == 'A'\n  \
    \  next if c == 'e' || c == 'E'\n    next if c == 'i' || c == 'I'\n    next if\
    \ c == 'o' || c == 'O'\n    next if c == 'u' || c == 'U'\n    next if c == 'A'\
    \ || c == 'a'\n    next if c == 'E' || c == 'e'\n    next if c == 'I' || c ==\
    \ 'i'\n    next if c == 'O' || c == 'o'\n    next if c == 'U' || c == 'u'\n  \
    \  next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n    next if\
    \ c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if c == 'u'\
    \ || c == 'U'\n    next if c == 'A' || c == 'a'\n    next if c == 'E' || c ==\
    \ 'e'\n    next ", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n\
    \    sum + 1 if index%2 == 0 && char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (char, index)| sum + 1 if index % 2 == 0 && char.upcase == char }\nend",
  "  s.each_char.with_index do |c,i|\n    if i % 2 == 0 && c.upcase == c\n      puts\
    \ \"#{c} occurs #{i+1} times\"\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ `each_char`?\n<|/ c |>\n<| c |>\nI added a solution without `each_char`.\n<|/\
    \ c |>\n<| c |>\nI added a solution without `each_char`.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n\
    \    sum + 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n  \
    \  next if c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if\
    \ c == 'u' || c == 'U'\n    next if c == 'y' || c == 'Y'\n    next if c == 'A'\
    \ || c == 'a'\n    next if c == 'E' || c == 'e'\n    next if c == 'I' || c ==\
    \ 'i'\n    next if c == 'O' || c == 'o'\n    next if c == 'U' || c == 'u'\n  \
    \  next if c == 'Y' || c == 'y'\n    next if c == 'a' || c == 'A'\n    next if\
    \ c == 'e' || c == 'E'\n    next if c == 'i' || c == 'I'\n    next if c == 'o'\
    \ || c == 'O'\n    next if c == 'u' || c == 'U'\n    next if c == 'y' || c ==\
    \ 'Y'\n    next if c == 'A' || c == 'a'\n    next if c == 'E' || c == 'e'\n  \
    \  next if c == 'I' || c == 'i'\n    next if c == 'O' || c == 'o'\n    next if\
    \ c == 'U' || c == 'u'\n    next if c == 'Y' || c == 'y'\n    next if c == 'a'\
    \ || c == 'A'\n    next if c == 'e' || c == 'E'\n    next if c == 'i' || c ==\
    \ 'I'\n    next if c == 'o' || c == 'O'\n    next if c == 'u' || c == 'U'\n  \
    \  next if c == 'y' || c == 'Y'\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c", "  s.each_char.with_index.with_object(0) do |c,i|\n   \
    \ next if i.even?\n    next if c.upcase == 'A'\n    i += 1\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (_, i)|\n    sum + 1 if i % 2 == 0 && s[i].upcase == s[i].downcase\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n \
    \   sum + 1 if char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n  \
    \  next if c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if\
    \ c == 'u' || c == 'U'\n    next if c == 'y' || c == 'Y'\n    next if c == 'A'\
    \ || c == 'a'\n    next if c == 'E' || c == 'e'\n    next if c == 'I' || c ==\
    \ 'i'\n    next if c == 'O' || c == 'o'\n    next if c == 'U' || c == 'u'\n  \
    \  next if c == 'Y' || c == 'y'\n    next if c == 'a' || c == 'A'\n    next if\
    \ c == 'e' || c == 'E'\n    next if c == 'i' || c == 'I'\n    next if c == 'o'\
    \ || c == 'O'\n    next if c == 'u' || c == 'U'\n    next if c == 'y' || c ==\
    \ 'Y'\n    next if c == 'A' || c == 'a'\n    next if c == 'E' || c == 'e'\n  \
    \  next if c == 'I' || c == 'i'\n    next if c == 'O' || c == 'o'\n    next if\
    \ c == 'U' || c == 'u'\n    next if c == 'Y' || c == 'y'\n    next if c == 'a'\
    \ || c == 'A'\n    next if c == 'e' || c == 'E'\n    next if c == 'i' || c ==\
    \ 'I'\n    next if c == 'o' || c == 'O'\n    next if c == 'u' || c == 'U'\n  \
    \  next if c == 'y' || c == 'Y'\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c", "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n\
    \    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\nend", "  s.each_char.with_index.with_object(0)\
    \ do |c,i|\n    next if i.even?\n    next if c == 'A' || c == 'a'\n    next if\
    \ c == 'E' || c == 'e'\n    next if c == 'I' || c == 'i'\n    next if c == 'O'\
    \ || c == 'o'\n    next if c == 'U' || c == 'u'\n    next if c == 'Y' || c ==\
    \ 'y'\n    next if c == 'a' || c == 'A'\n    next if c == 'e' || c == 'E'\n  \
    \  next if c == 'i' || c == 'I'\n    next if c == 'o' || c == 'O'\n    next if\
    \ c == 'u' || c == 'U'\n    next if c == 'y' || c == 'Y'\n    next if c == 'y'\
    \ || c == 'Y'\n    next if c == 'Y' || c == 'y'\n    next if c == 'Y' || c ==\
    \ 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n  \
    \  next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if\
    \ c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y'\
    \ || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c ==\
    \ 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n  \
    \  next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if\
    \ c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y'\
    \ || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c ==\
    \ 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n  \
    \  next if c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if\
    \ c == 'Y' || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if c == 'Y'\
    \ || c == 'Y'\n    next if c == 'Y' || c == 'Y'\n    next if ", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index&1 == 0 && char.upcase == 'A'\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |(char, index), count|\n\
    \    count += 1 if char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (letter, i)| sum + 1 if i % 2 == 0 && letter == 'A' || letter == 'a'\
    \ } \nend", "  s.gsub(/[AEIOU]/).with_index { |s, i| i % 2 == 0 ? s.size : 0 }\n\
    end", "  s.each_char.with_index.with_object(0) do |c,i|\n    i += 1 if c == 'A'\
    \ || c == 'a'\n    i += 1 if c == 'E' || c == 'e'\n    i += 1 if c == 'I' || c\
    \ == 'i'\n    i += 1 if c == 'O' || c == 'o'\n    i += 1 if c == 'U' || c == 'u'\n\
    \    i += 1 if c == 'Y' || c == 'y'\n  end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like your solution, but I find it a bit too complicated for my taste.\
    \ :)\n<|/ c |>\n<| c |>\nI agree with you, it's too complicated for my taste.\
    \ :)\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (letter, index)| sum + 1 if index % 2 == 0 && letter == 'A' || letter\
    \ == 'a' } \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer!\
    \ I appreciate it. I tried your solution and it works perfectly. Thanks again!\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each_with_index.inject(0) do\
    \ |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.inject(0) do |sum, (_, i)|\n    sum +\
    \ 1 if i % 2 == 0 && s[i].upcase == s[i].downcase\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nI like your solution, however it only works with strings\
    \ that consist of only lowercase letters. If you try it with \"aBcDeFg\" it will\
    \ return 0 instead of 1.\n<|/ c |>\n<| c |>\nI added a solution that will work\
    \ with strings with any characters. Thanks for pointing that out.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  s.chars.each_with_index.inject(0) { |sum, (_, i)|\
    \ sum + i.odd? ? 1 : 0 }\nend", "  s.chars.each_with_index.inject(0) {|sum, (c,i)|\
    \ sum + 1 if c == 'A' && i % 2 == 0 }\nend", "  s.chars.each_with_index.inject(0)\
    \ {|sum, (c, i)| sum + 1 if i % 2 == 0 && c.upcase == c}\nend", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (char, index)| sum + 1 if index % 2 == 0 && char.upcase == char }\n\
    end", "  s.each_char.with_index.with_object(0) do |c,i|\n    i += 1 if c == 'A'\
    \ || c == 'a'\n    i += 1 if c == 'E' || c == 'e'\n    i += 1 if c == 'I' || c\
    \ == 'i'\n    i += 1 if c == 'O' || c == 'o'\n    i += 1 if c == 'U' || c == 'u'\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n \
    \   sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend", "  s.each_char.with_index.inject(0)\
    \ do |sum, (c, i)|\n    sum + 1 if i % 2 == 0 && c.upcase == c\n  end\nend", " \
    \ s.each_char.with_index.with_object(0) do |c,i|\n    next if i.even?\n    c =~\
    \ /[AEIOU]/\n    i += 1 if $~\n  end\nend", "  s.each_char.with_index.inject(0)\
    \ { |sum, (_, i)| sum + 1 if i.even? && i.upcase }\nend", "  s.gsub(/[aeiou]/,\
    \ '').length\nend", "  s.each_char.with_index.with_object(0) do |c, i|\n    if\
    \ i % 2 == 0 && c.upcase == c\n      i += 1 # increment the counter\n    end\n\
    \  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but I\
    \ wonder if there is a way to do it without using each_char.\n<|/ c |>\n<| c |>\n\
    I added a solution without each_char.\n<|/ c |>\n<| c |>\nI like the second solution,\
    \ but I wonder if there is a way to do it without using each_char.\n<|/ c |>\n\
    <| c |>\nI added a solution without each_char.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  s.each_char.with_index.with_object(0) do |c,i|\n    if c == 'A' ||\
    \ c == 'a'\n      i += 1 if i % 2 == 0\n    end\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.each_char.with_index.with_object(0) do |(char, index), count|\n\
    \    count += 1 if char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n \
    \   sum + 1 if index%2 == 0 && char.upcase == char\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.gsub(/[AEIOU]/, '').length\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase == char\n  end\nend", " \
    \ s.downcase!\n  s.each_char.with_index do |char, i|\n    next if i % 2 == 0\n\
    \    next if char.upcase == char\n    next if char.upcase == 'A'\n    next if\
    \ char.upcase == 'a'\n    next if char.upcase == 'E'\n    next if char.upcase\
    \ == 'e'\n    next if char.upcase == 'I'\n    next if char.upcase == 'i'\n   \
    \ next if char.upcase == 'O'\n    next if char.upcase == 'o'\n    next if char.upcase\
    \ == 'U'\n    next if char.upcase == 'u'\n    next if char.upcase == 'Y'\n   \
    \ next if char.upcase == 'y'\n    next if char.upcase == 'a'\n    next if char.upcase\
    \ == 'e'\n    next if char.upcase == 'i'\n    next if char.upcase == 'o'\n   \
    \ next if char.upcase == 'u'\n    next if char.upcase == 'y'\n    next if char.upcase\
    \ == 'A'\n    next if char.upcase == 'a'\n    next if char.upcase == 'E'\n   \
    \ next if char.upcase == 'e'\n    next if char.upcase == 'I'\n    next if char.upcase\
    \ == 'i'\n    next if char.upcase == 'O'\n    next if char.upcase == 'o'\n   \
    \ next if char.upcase == 'U'\n    next if char.upcase == 'u'\n    next if char.upcase\
    \ == 'Y'\n    next if char.upcase == 'y'\n    next if char.upcase == 'a'\n   \
    \ next if char.upcase == 'e'\n    next if char.upcase == 'i'\n    next if char.upcase\
    \ == 'o'\n    next if char.upcase == 'u'\n    next if char.upcase == 'y'\n   \
    \ next if char.upcase == 'A'\n    next if char.upcase == 'a'\n    next if char.upcase\
    \ == 'E'\n    next if char.upcase == 'e'\n    next if char.upcase == 'I'\n   \
    \ next if char.upcase == 'i'\n    next if char.upcase == 'O'\n    next if char.upcase\
    \ == 'o'\n    next if char.upcase == 'U'\n    next ", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.chars.each_with_index.inject(0) do |sum, (char, index)|\n \
    \   sum + 1 if index % 2 == 0 && char.upcase == char\n  end\nend", "  s.each_char.with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + (char.upcase && (index % 2 == 0))\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  s.chars.each_with_index.inject(0)\
    \ { |sum, (c,i) | c =~ /[AEIOU]/i ? sum + 1 : sum }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.each_char.with_index.with_object(0)\
    \ do |(char, index), count|\n    if index % 2 == 0 && char.upcase == 'A'\n   \
    \   count += 1\n    end\n  end\nend", "  s.each_char.with_index.inject(0) { |sum,\
    \ (_, i)| sum + i.odd? ? 1 : 0 }\nend", "  s.gsub(/[aeiou]/).count('AEIOU')\n\
    end", "  s.each_char.with_index.with_object(0) do |c,i|\n    next if i.even?\n\
    \    c =~ /[AEIOU]/\n    i += 1 if $~\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nI like your use of each_char and with_index. Very clever.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  s.each_char.with_index.inject(0) do |sum, (c, i)|\n\
    \    sum + 1 if i % 2 == 0 && c.upcase == c\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  s.each_char.with_index.inject(0)\
    \ { |sum, (_, i)| sum + 1 if i.odd? && i.upcase }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
