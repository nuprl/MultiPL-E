name: HumanEval_68_pluck
language: ruby
results:
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.sort!\n    even.first\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp_b9ys5u3\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp_b9ys5u3.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004350902 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n229.84 tests/s, 229.84 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpw0b8purt\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `smallest_value' for #<TestHumanEval:0x0000558ba452eb28>\\n/tmp/tmpw0b8purt.rb:33:in\
    \ `pluck'\\n/tmp/tmpw0b8purt.rb:39:in `call'\\n/tmp/tmpw0b8purt.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.042670145 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n23.44 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpkpz9lhmz\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `smallest_value' for #<TestHumanEval:0x00005650fff66d90>\\n/tmp/tmpkpz9lhmz.rb:33:in\
    \ `pluck'\\n/tmp/tmpkpz9lhmz.rb:39:in `call'\\n/tmp/tmpkpz9lhmz.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.024674868 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n40.53 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp4jfiek81\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp4jfiek81.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.015030562 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n66.53 tests/s, 66.53 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.empty?\
    \ ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpodz6rowp\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpodz6rowp.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.007438177 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n134.44 tests/s, 134.44 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp_412qh75\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp_412qh75.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.033782774 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n29.60 tests/s, 29.60 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? even.min : even.min.even? ?\
    \ even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpp9860gv0.rb:30: syntax error, unexpected string literal, expecting\
    \ `do' or '{' or '('\\nrequire 'test/unit'\\n        ^\\n/tmp/tmpp9860gv0.rb:31:\
    \ class definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\\
    n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpp9860gv0.rb:43: syntax error, unexpected end-of-input,\
    \ expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp707d6zws\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp707d6zws.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.033111282 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n30.20 tests/s, 30.20 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpm3fqcctp\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpm3fqcctp.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00449947 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n222.25 tests/s, 222.25 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpg15h1p5v\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpg15h1p5v.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010110701 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n98.91 tests/s, 98.91 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.sort!\n    even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp7krbb0qa\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp7krbb0qa.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.006289217 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n159.00 tests/s, 159.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min\n  end\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpmyaaxdf4\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpmyaaxdf4.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005176054 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n193.20 tests/s, 193.20 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp6rw06xwf\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp6rw06xwf.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.02148433 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n46.55 tests/s, 46.55 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.empty?\
    \ ? [] : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp4rpynpq8.rb:30: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp4rpynpq8.rb:42: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpb0hpk51z\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval):\\n  NoMethodError: undefined method `even'\
    \ for 2:Integer\\n  Did you mean?  even?\\n/tmp/tmpb0hpk51z.rb:29:in `pluck'\\\
    n/tmp/tmpb0hpk51z.rb:35:in `call'\\n/tmp/tmpb0hpk51z.rb:35:in `test_pluck'\\n\
    \     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002254841 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n443.49 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp5cnxmfm6\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp5cnxmfm6.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004998839 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n200.05 tests/s, 200.05 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpfrtx7wak\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpfrtx7wak.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.0059721 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n167.45 tests/s, 167.45 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp8mxohkfa.rb:34: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp8mxohkfa.rb:46: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpe5ex6v1y\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpe5ex6v1y.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004793363 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n208.62 tests/s, 208.62 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp6xbevbms\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp6xbevbms.rb:41:in `test_pluck'\\\
    n     38: class TestHumanEval < Test::Unit::TestCase\\n     39:   def test_pluck\\\
    n     40:     candidate = method(:pluck)\\n  => 41:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     42:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   43:     assert_equal([], candidate.call([]))\\n     44:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00808885 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n123.63 tests/s, 123.63 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpstwglllc\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpstwglllc.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004659872 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n214.60 tests/s, 214.60 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.each_with_index do |x, i|\n    if x==even[0]\n \
    \     return [x, i]\n    end\n  end\n  return []\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpui4q5b08\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpui4q5b08.rb:41:in `test_pluck'\\\
    n     38: class TestHumanEval < Test::Unit::TestCase\\n     39:   def test_pluck\\\
    n     40:     candidate = method(:pluck)\\n  => 41:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     42:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   43:     assert_equal([], candidate.call([]))\\n     44:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005078178 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n196.92 tests/s, 196.92 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3vto35mb\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp3vto35mb.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.008964818 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n111.55 tests/s, 111.55 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpl7slgfes\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpl7slgfes.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.006183036 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n161.73 tests/s, 161.73 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    next if n.even?\n    arr[i] = n\n  end\n  arr.uniq.sort!\n  arr.first\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpo4cuooml\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpo4cuooml.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.013217575 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n75.66 tests/s, 75.66 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? even.min : [even.min]\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpyfgi9p7c\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpyfgi9p7c.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004390986 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n227.74 tests/s, 227.74 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp97t8fqs0\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp97t8fqs0.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00428663 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n233.28 tests/s, 233.28 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpsrkqznmv\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpsrkqznmv.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.021069849 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n47.46 tests/s, 47.46 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpkzzhp49l.rb:31: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpkzzhp49l.rb:43: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.each do |x|\n    arr.delete_at(x)\n  end\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmptp2tq0a6.rb:113: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmptp2tq0a6.rb:125: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpjhl328ly\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpjhl328ly.rb:45:in `test_pluck'\\\
    n     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005460066 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n183.15 tests/s, 183.15 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpud16lvlp\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpud16lvlp.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.01786403 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n55.98 tests/s, 55.98 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp8ywkgqqh\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp8ywkgqqh.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.01316204 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n75.98 tests/s, 75.98 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\n  []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp8w5zp_z6\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp8w5zp_z6.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.004845461 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n206.38 tests/s, 206.38 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpkrvd9gac\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpkrvd9gac.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.008052511 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n124.18 tests/s, 124.18 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpouwsj9wb\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpouwsj9wb.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00502077 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n199.17 tests/s, 199.17 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.index, even.min.even] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index, even.min.even]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index,\
    \ even.min.even] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.index, even.min.even] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index, even.min.even]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index,\
    \ even.min.even] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.index, even.min.even] : even.min.even?\
    \ ? [even.min.even, even.\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpfd9uvgh8.rb:30: syntax error, unexpected string literal, expecting\
    \ ']'\\nrequire 'test/unit'\\n        ^\\n/tmp/tmpfd9uvgh8.rb:31: class definition\
    \ in method body\\nclass TestHumanEval < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\\
    n/tmp/tmpfd9uvgh8.rb:43: syntax error, unexpected end-of-input, expecting `end'\\\
    n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ [even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpn6efaj7r.rb:33: syntax error, unexpected local variable or method,\
    \ expecting ']'\\nrequire 'test/unit'\\n^~~~~~~\\n/tmp/tmpn6efaj7r.rb:34: class\
    \ definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\\
    n/tmp/tmpn6efaj7r.rb:46: syntax error, unexpected end-of-input, expecting `end'\\\
    n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp5wvecg7n\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp5wvecg7n.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004545316 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n220.01 tests/s, 220.01 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.each do |x|\n        arr.delete_at(x)\n    end\n    arr.delete_at(arr.index(even.min))\n\
    \    arr\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpkl_audu8.rb:35: syntax error, unexpected '<', expecting end-of-input\\\
    n</code>\\n^\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp2ej06wua\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp2ej06wua.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.012894807 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n77.55 tests/s, 77.55 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpc4wfpyc_\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpc4wfpyc_.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.023321113 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n42.88 tests/s, 42.88 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.sort!\n\
    \  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp4mk454tt\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp4mk454tt.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004894974 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n204.29 tests/s, 204.29 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n, i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp_tw9lwsy\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp_tw9lwsy.rb:45:in `test_pluck'\\\
    n     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.025716937 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n38.88 tests/s, 38.88 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\n  []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpyk3ubvhq\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpyk3ubvhq.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.010011154 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n99.89 tests/s, 99.89 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp5vbjdcav\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp5vbjdcav.rb:38:in `test_pluck'\\\
    n     35: class TestHumanEval < Test::Unit::TestCase\\n     36:   def test_pluck\\\
    n     37:     candidate = method(:pluck)\\n  => 38:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     39:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   40:     assert_equal([], candidate.call([]))\\n     41:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005457804 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n183.22 tests/s, 183.22 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpwkmdl90z\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpwkmdl90z.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004752055 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n210.44 tests/s, 210.44 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpn4de5m_i\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpn4de5m_i.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010476078 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n95.46 tests/s, 95.46 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmppjg_bwf1\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmppjg_bwf1.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004805257 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n208.11 tests/s, 208.11 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpfr0k8uwh\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpfr0k8uwh.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.011164744 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n89.57 tests/s, 89.57 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node,index|\n   \
    \ if node.even?\n      smallest_value = node\n      smallest_index = index\n \
    \   end\n  end\n  return [smallest_value, smallest_index]\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpr9bm3wp7\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `smallest_value' for #<TestHumanEval:0x0000556c876e68d0>\\n/tmp/tmpr9bm3wp7.rb:33:in\
    \ `pluck'\\n/tmp/tmpr9bm3wp7.rb:39:in `call'\\n/tmp/tmpr9bm3wp7.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.026804732 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n37.31 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.each do |x|\n    arr.delete_at(x)\n  end\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp2dhnqqj1.rb:113: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp2dhnqqj1.rb:125: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    even = arr.select { |x| x % 2 == 0 }\n\
    \    even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpwhy5nj2f\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpwhy5nj2f.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004637431 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n215.64 tests/s, 215.64 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.sort!\n\
    \  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmply91391o\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmply91391o.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004674801 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n213.91 tests/s, 213.91 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node.value, index]\n    end\n  end\n\
    \  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpk2vejzue\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `value' for\
    \ 2:Integer\\n/tmp/tmpk2vejzue.rb:30:in `block in pluck'\\n/tmp/tmpk2vejzue.rb:28:in\
    \ `each'\\n/tmp/tmpk2vejzue.rb:28:in `each_with_index'\\n/tmp/tmpk2vejzue.rb:28:in\
    \ `pluck'\\n/tmp/tmpk2vejzue.rb:39:in `call'\\n/tmp/tmpk2vejzue.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.008408791 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n118.92 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp6e3etlls.rb:105: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp6e3etlls.rb:117: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmprzemp074\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmprzemp074.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.028764979 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n34.76 tests/s, 34.76 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,index|\n\
    \    if node.even?\n      arr[index] = node\n    end\n  end\n  arr.compact!\n\
    \  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n     \
    \ arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpvkcxpsbn.rb:128: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpvkcxpsbn.rb:140: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpf0ixyd16\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpf0ixyd16.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005764801 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n173.47 tests/s, 173.47 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index] :\
    \ even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpxitrgjhh\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmpxitrgjhh.rb:29:in `pluck'\\n/tmp/tmpxitrgjhh.rb:35:in `call'\\\
    n/tmp/tmpxitrgjhh.rb:35:in `test_pluck'\\n     32: class TestHumanEval < Test::Unit::TestCase\\\
    n     33:   def test_pluck\\n     34:     candidate = method(:pluck)\\n  => 35:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     36:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     37:     assert_equal([], candidate.call([]))\\\
    n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002351833 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n425.20 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp8kfztw2u.rb:34: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp8kfztw2u.rb:46: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min\n  end\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3_9yk3bv\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp3_9yk3bv.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.017316501 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n57.75 tests/s, 57.75 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpy3bactis\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpy3bactis.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004864237 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n205.58 tests/s, 205.58 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp5ej0dgg5\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp5ej0dgg5.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.029268867 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n34.17 tests/s, 34.17 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.find { |x| x % 2 == 0 }\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpve02jl_e\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpve02jl_e.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009796661 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n102.08 tests/s, 102.08 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpx101gk9v\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpx101gk9v.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005873866 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n170.25 tests/s, 170.25 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpf7gko_ug\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpf7gko_ug.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00474383 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n210.80 tests/s, 210.80 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.each do |x|\n        arr.delete_at(x) \n    end\n   \
    \ arr.delete_at(arr.index(even.min))\n    arr\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpc05w1ayr\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpc05w1ayr.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[3]>\\\
    n\\ndiff:\\n? [2, 1]\\n?  3    \\n===============================================================================\\\
    n\\nFinished in 0.005413851 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n184.71 tests/s, 184.71 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x.even? }\n    even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmphujc55ly\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmphujc55ly.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009630279 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n103.84 tests/s, 103.84 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpzdlbyt11\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpzdlbyt11.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00438773 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n227.91 tests/s, 227.91 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.min_by\
    \ { |x| x }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpybdcge2g\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpybdcge2g.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00503099 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n198.77 tests/s, 198.77 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpau039f6e\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpau039f6e.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.024015038 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n41.64 tests/s, 41.64 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each_with_index {|x,\
    \ i| arr[i] = x}\n    even.min\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmprcjd3ipv\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmprcjd3ipv.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005340833 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n187.24 tests/s, 187.24 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.each_with_index do |n, i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uni\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpwlh6qeak.rb:106: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpwlh6qeak.rb:118: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpdjp6dttz\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpdjp6dttz.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.013420224 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n74.51 tests/s, 74.51 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpxhi030gb.rb:34: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpxhi030gb.rb:46: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.min\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp9tn7yn9j\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp9tn7yn9j.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.007598378 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n131.61 tests/s, 131.61 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp8877_0mx.rb:138: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp8877_0mx.rb:150: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.min\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp2x_bykcg\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp2x_bykcg.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004468682 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n223.78 tests/s, 223.78 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp5sg6ixgy\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp5sg6ixgy.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004290116 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n233.09 tests/s, 233.09 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpf0rjysri\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpf0rjysri.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.016262079 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n61.49 tests/s, 61.49 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpr2dw4_ys\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpr2dw4_ys.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004597656 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n217.50 tests/s, 217.50 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3inuga3g\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp3inuga3g.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00432364 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n231.29 tests/s, 231.29 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp9rw80s_8\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp9rw80s_8.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00447278 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n223.57 tests/s, 223.57 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpcy795xnw\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpcy795xnw.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005805236 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n172.26 tests/s, 172.26 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp2ft8wrpj\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp2ft8wrpj.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004745123 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n210.74 tests/s, 210.74 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.sort!\n\
    \  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpxdtavtxd\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpxdtavtxd.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010132192 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n98.70 tests/s, 98.70 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index] :\
    \ even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpj_tkj_yt\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmpj_tkj_yt.rb:29:in `pluck'\\n/tmp/tmpj_tkj_yt.rb:35:in `call'\\\
    n/tmp/tmpj_tkj_yt.rb:35:in `test_pluck'\\n     32: class TestHumanEval < Test::Unit::TestCase\\\
    n     33:   def test_pluck\\n     34:     candidate = method(:pluck)\\n  => 35:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     36:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     37:     assert_equal([], candidate.call([]))\\\
    n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.009012346 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n110.96 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmplb2vrswf\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmplb2vrswf.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009995134 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n100.05 tests/s, 100.05 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.each_with_index do |x, i|\n    if x==even[0]\n \
    \     return [x] if even.size != 1\n      return [x] if even.size == 1\n    end\n\
    \  end\n  return []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp4aqh0v9d\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp4aqh0v9d.rb:42:in `test_pluck'\\\
    n     39: class TestHumanEval < Test::Unit::TestCase\\n     40:   def test_pluck\\\
    n     41:     candidate = method(:pluck)\\n  => 42:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     43:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   44:     assert_equal([], candidate.call([]))\\n     45:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2]>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.024528904 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n40.77 tests/s, 40.77 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp7iu7fgqv\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp7iu7fgqv.rb:45:in `test_pluck'\\\
    n     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005358346 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n186.62 tests/s, 186.62 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpx1oydzk3\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `smallest_value' for #<TestHumanEval:0x000055a144fc2d90>\\n/tmp/tmpx1oydzk3.rb:33:in\
    \ `pluck'\\n/tmp/tmpx1oydzk3.rb:39:in `call'\\n/tmp/tmpx1oydzk3.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.021331211 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n46.88 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpw3oy5bve\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpw3oy5bve.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004289716 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n233.12 tests/s, 233.12 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpluimp99n\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpluimp99n.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004251656 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n235.20 tests/s, 235.20 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index] :\
    \ even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpzwfz0wlw\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmpzwfz0wlw.rb:29:in `pluck'\\n/tmp/tmpzwfz0wlw.rb:35:in `call'\\\
    n/tmp/tmpzwfz0wlw.rb:35:in `test_pluck'\\n     32: class TestHumanEval < Test::Unit::TestCase\\\
    n     33:   def test_pluck\\n     34:     candidate = method(:pluck)\\n  => 35:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     36:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     37:     assert_equal([], candidate.call([]))\\\
    n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.018398205 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n54.35 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpuy4n98g3\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpuy4n98g3.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010208066 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n97.96 tests/s, 97.96 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpma60m4ih\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpma60m4ih.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.013838572 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n72.26 tests/s, 72.26 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpi2hxqab8\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpi2hxqab8.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009869748 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n101.32 tests/s, 101.32 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.each do |x|\n    arr.delete_at(x)\n  end\n  if arr.empty?\n  \
    \  return []\n  end\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp1w4q4ffd.rb:114: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp1w4q4ffd.rb:126: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even_values = arr.select { |x| x.even? }\n\
    \  even_values.sort.each_with_index { |x, i| return [x, i] if x.even? }\n  even_values.sort.each_with_index\
    \ { |x, i| return [x, i] if x.even? }.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpfnlebdds\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpfnlebdds.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005379475 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n185.89 tests/s, 185.89 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpt267j0zu\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpt267j0zu.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009509952 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n105.15 tests/s, 105.15 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp9tmly35c\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp9tmly35c.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004487899 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n222.82 tests/s, 222.82 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.sort!\n    even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp0toy7kag\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp0toy7kag.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.01219957 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n81.97 tests/s, 81.97 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp36_9hhz_\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp36_9hhz_.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.023669568 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n42.25 tests/s, 42.25 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp1il1ay6_.rb:30: syntax error, unexpected string literal, expecting\
    \ `end'\\nrequire 'test/unit'\\n        ^\\n/tmp/tmp1il1ay6_.rb:31: class definition\
    \ in method body\\nclass TestHumanEval < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\\
    n/tmp/tmp1il1ay6_.rb:43: syntax error, unexpected end-of-input, expecting `end'\\\
    n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    next if n.even?\n    arr[i] = n\n  end\n  arr.uniq!\n  arr.sort!\n  arr.first\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpym2kebd0\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpym2kebd0.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004467831 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n223.82 tests/s, 223.82 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpgyt6vpl4\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpgyt6vpl4.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.020588865 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n48.57 tests/s, 48.57 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmppj3z7hr4\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmppj3z7hr4.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005288285 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n189.10 tests/s, 189.10 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpvt2hemet\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpvt2hemet.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.012228806 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n81.77 tests/s, 81.77 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpmml9fwap\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpmml9fwap.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004423818 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n226.05 tests/s, 226.05 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n\
    \  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2\
    \ == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n\
    \  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2\
    \ == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n\
    \  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2\
    \ == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      \nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmphb0_zs90.rb:130: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmphb0_zs90.rb:142: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min.even?,\
    \ even.min.index] : []\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n   \
    \ assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1,\
    \ 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1],\
    \ candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpe5xb_bdz\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmpe5xb_bdz.rb:32:in `pluck'\\n/tmp/tmpe5xb_bdz.rb:39:in `call'\\\
    n/tmp/tmpe5xb_bdz.rb:39:in `test_pluck'\\n     36: class TestHumanEval < Test::Unit::TestCase\\\
    n     37:   def test_pluck\\n     38:     candidate = method(:pluck)\\n  => 39:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     40:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     41:     assert_equal([], candidate.call([]))\\\
    n     42:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002505031 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n399.20 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpbyu1ggt7\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpbyu1ggt7.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004549344 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n219.81 tests/s, 219.81 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index]\
    \ : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpxlovjeri\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmpxlovjeri.rb:29:in `pluck'\\n/tmp/tmpxlovjeri.rb:35:in `call'\\\
    n/tmp/tmpxlovjeri.rb:35:in `test_pluck'\\n     32: class TestHumanEval < Test::Unit::TestCase\\\
    n     33:   def test_pluck\\n     34:     candidate = method(:pluck)\\n  => 35:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     36:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     37:     assert_equal([], candidate.call([]))\\\
    n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002319832 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n431.07 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpz98ase0e\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpz98ase0e.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004672536 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n214.02 tests/s, 214.02 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpwjr5ydj_\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpwjr5ydj_.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004296739 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n232.73 tests/s, 232.73 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3f82l5yh\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp3f82l5yh.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.021213029 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n47.14 tests/s, 47.14 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpj4riv0b7.rb:33: syntax error, unexpected string literal, expecting\
    \ `do' or '{' or '('\\nrequire 'test/unit'\\n        ^\\n/tmp/tmpj4riv0b7.rb:34:\
    \ class definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\\
    n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpj4riv0b7.rb:46: syntax error, unexpected end-of-input,\
    \ expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpvh0cum2w\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpvh0cum2w.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00479154 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n208.70 tests/s, 208.70 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp2cwz0bz0.rb:119: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp2cwz0bz0.rb:131: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\n</cell>\n<cell>\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp85br0sr8.rb:41: syntax error, unexpected '<', expecting end-of-input\\\
    n</cell>\\n^\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index]\
    \ : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp31z7h2wh\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmp31z7h2wh.rb:29:in `pluck'\\n/tmp/tmp31z7h2wh.rb:35:in `call'\\\
    n/tmp/tmp31z7h2wh.rb:35:in `test_pluck'\\n     32: class TestHumanEval < Test::Unit::TestCase\\\
    n     33:   def test_pluck\\n     34:     candidate = method(:pluck)\\n  => 35:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     36:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     37:     assert_equal([], candidate.call([]))\\\
    n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.00231297 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n432.34 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpq_9r27ew\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpq_9r27ew.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010037173 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n99.63 tests/s, 99.63 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp68fx6u8x\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp68fx6u8x.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00547241 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n182.73 tests/s, 182.73 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n  \
    \    if even.index(x) == even.index(x + 1)\n        return [x] + even.index(x)\
    \ + 1\n      else\n        return [x] + even.index(x + 1)\n      end\n    end\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3nm8de9c\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): TypeError: no implicit conversion of nil into\
    \ Array\\n/tmp/tmp3nm8de9c.rb:36:in `+'\\n/tmp/tmp3nm8de9c.rb:36:in `block in\
    \ pluck'\\n/tmp/tmp3nm8de9c.rb:32:in `each'\\n/tmp/tmp3nm8de9c.rb:32:in `pluck'\\\
    n/tmp/tmp3nm8de9c.rb:45:in `call'\\n/tmp/tmp3nm8de9c.rb:45:in `test_pluck'\\n\
    \     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.00068589 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n1457.96 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n     \
    \ index = even.index(x)\n      break if index == 0\n    end\n    [ even.first,\
    \ index ]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpqed3w1en\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `index' for #<TestHumanEval:0x0000556fd922f008>\\n/tmp/tmpqed3w1en.rb:36:in\
    \ `pluck'\\n/tmp/tmpqed3w1en.rb:43:in `call'\\n/tmp/tmpqed3w1en.rb:43:in `test_pluck'\\\
    n     40: class TestHumanEval < Test::Unit::TestCase\\n     41:   def test_pluck\\\
    n     42:     candidate = method(:pluck)\\n  => 43:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     44:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   45:     assert_equal([], candidate.call([]))\\n     46:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.010991908 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n90.98 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpb5ktcy7v\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpb5ktcy7v.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004412076 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n226.65 tests/s, 226.65 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  next if node.even?\n    smallest_value = node\n    smallest_index = index\n\
    \    smallest_value.downto(smallest_value.length - 1) do |i|\n      next if i.even?\n\
    \      smallest_value = i if smallest_value < i\n    end\n    smallest_value\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp056qv51y\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `length' for\
    \ 3:Integer\\n/tmp/tmp056qv51y.rb:31:in `block in pluck'\\n/tmp/tmp056qv51y.rb:27:in\
    \ `each'\\n/tmp/tmp056qv51y.rb:27:in `each_with_index'\\n/tmp/tmp056qv51y.rb:27:in\
    \ `pluck'\\n/tmp/tmp056qv51y.rb:42:in `call'\\n/tmp/tmp056qv51y.rb:42:in `test_pluck'\\\
    n     39: class TestHumanEval < Test::Unit::TestCase\\n     40:   def test_pluck\\\
    n     41:     candidate = method(:pluck)\\n  => 42:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     43:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   44:     assert_equal([], candidate.call([]))\\n     45:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002590571 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n386.02 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpxc30z87m\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpxc30z87m.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005061718 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n197.56 tests/s, 197.56 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? even.min : [even.min.even? ?\
    \ even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpfo6nvv3i.rb:30: syntax error, unexpected string literal, expecting\
    \ `do' or '{' or '('\\nrequire 'test/unit'\\n        ^\\n/tmp/tmpfo6nvv3i.rb:31:\
    \ class definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\\
    n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpfo6nvv3i.rb:43: syntax error, unexpected end-of-input,\
    \ expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.sort!\n    even.first\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp6de4y3u8\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp6de4y3u8.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009988924 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n100.11 tests/s, 100.11 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  return arr\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp4_aj_82i\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp4_aj_82i.rb:45:in `test_pluck'\\\
    n     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 3,\
    \ 4]>\\n\\ndiff:\\n? [2, 1   ]\\n?     3, 4 \\n===============================================================================\\\
    n\\nFinished in 0.005542432 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n180.43 tests/s, 180.43 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node.value, index]\n    end\n  end\n\
    \  []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpvi_23jbl\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `value' for\
    \ 2:Integer\\n/tmp/tmpvi_23jbl.rb:30:in `block in pluck'\\n/tmp/tmpvi_23jbl.rb:28:in\
    \ `each'\\n/tmp/tmpvi_23jbl.rb:28:in `each_with_index'\\n/tmp/tmpvi_23jbl.rb:28:in\
    \ `pluck'\\n/tmp/tmpvi_23jbl.rb:39:in `call'\\n/tmp/tmpvi_23jbl.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002675011 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n373.83 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp5vk49wh5\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `smallest_value' for #<TestHumanEval:0x000055e0728d6be0>\\n/tmp/tmp5vk49wh5.rb:33:in\
    \ `pluck'\\n/tmp/tmp5vk49wh5.rb:39:in `call'\\n/tmp/tmp5vk49wh5.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.010942646 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n91.39 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpyk7n0djp\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpyk7n0djp.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009615923 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n103.99 tests/s, 103.99 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp6b60z1j9\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp6b60z1j9.rb:41:in `test_pluck'\\\
    n     38: class TestHumanEval < Test::Unit::TestCase\\n     39:   def test_pluck\\\
    n     40:     candidate = method(:pluck)\\n  => 41:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     42:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   43:     assert_equal([], candidate.call([]))\\n     44:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004508567 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n221.80 tests/s, 221.80 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp3fjrqaj6.rb:119: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp3fjrqaj6.rb:131: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpk58989hs\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpk58989hs.rb:38:in `test_pluck'\\\
    n     35: class TestHumanEval < Test::Unit::TestCase\\n     36:   def test_pluck\\\
    n     37:     candidate = method(:pluck)\\n  => 38:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     39:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   40:     assert_equal([], candidate.call([]))\\n     41:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.00503599 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n198.57 tests/s, 198.57 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpfgjla1h6\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpfgjla1h6.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.020502212 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n48.78 tests/s, 48.78 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp09j0bhpj.rb:34: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp09j0bhpj.rb:46: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp84oyng9j\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp84oyng9j.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005853245 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n170.85 tests/s, 170.85 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpirkk1wvk\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpirkk1wvk.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009478272 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n105.50 tests/s, 105.50 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpo0f6c55l\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpo0f6c55l.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004441682 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n225.14 tests/s, 225.14 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  return arr\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n   \
    \ assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1,\
    \ 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1],\
    \ candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpjhtv51f5\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpjhtv51f5.rb:47:in `test_pluck'\\\
    n     44: class TestHumanEval < Test::Unit::TestCase\\n     45:   def test_pluck\\\
    n     46:     candidate = method(:pluck)\\n  => 47:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     48:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   49:     assert_equal([], candidate.call([]))\\n     50:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 3,\
    \ 4]>\\n\\ndiff:\\n? [2, 1   ]\\n?     3, 4 \\n===============================================================================\\\
    n\\nFinished in 0.004849518 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n206.21 tests/s, 206.21 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.each do |x|\n        smallest = x\n        smallest_index\
    \ = -1\n        arr.each do |y|\n            if y % 2 == 0\n                if\
    \ y < smallest\n                    smallest = y\n                    smallest_index\
    \ = y\n                end\n            end\n        end\n        return [ smallest,\
    \ smallest_index ]\n    end\n    return []\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp331g5mt5\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp331g5mt5.rb:48:in `test_pluck'\\\
    n     45: class TestHumanEval < Test::Unit::TestCase\\n     46:   def test_pluck\\\
    n     47:     candidate = method(:pluck)\\n  => 48:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     49:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   50:     assert_equal([], candidate.call([]))\\n     51:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, -1]>\\\
    n\\ndiff:\\n? [2, -1]\\n===============================================================================\\\
    n\\nFinished in 0.007294776 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n137.08 tests/s, 137.08 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n     \
    \ index = even.index(x)\n      if even.count(x) == 1 && index == 0\n        return\
    \ [x] # return [x] if even.count(x) == 1 and index == 0\n      elsif even.count(x)\
    \ == 1 && index != 0\n        return [x] # return [x] if even.count(x) == 1 and\
    \ index != 0\n      elsif even.count(x) > 1 && index == 0\n        return [x]\
    \ # return [x] if even.count(x) > 1 and index == 0\n      elsif even.count(x)\
    \ > 1 && index != 0\n        return [x] # return [x] if even.count(x) > 1 and\
    \ index != 0\n      end\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpbmc0ciz0\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpbmc0ciz0.rb:50:in `test_pluck'\\\
    n     47: class TestHumanEval < Test::Unit::TestCase\\n     48:   def test_pluck\\\
    n     49:     candidate = method(:pluck)\\n  => 50:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     51:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   52:     assert_equal([], candidate.call([]))\\n     53:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2]>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.02060235 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n48.54 tests/s, 48.54 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n, i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp81ygoss8.rb:105: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmp81ygoss8.rb:117: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n\
    \  end\n  return []\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpob6yadn8\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpob6yadn8.rb:46:in `test_pluck'\\\
    n     43: class TestHumanEval < Test::Unit::TestCase\\n     44:   def test_pluck\\\
    n     45:     candidate = method(:pluck)\\n  => 46:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     47:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   48:     assert_equal([], candidate.call([]))\\n     49:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.009451242 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n105.81 tests/s, 105.81 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n     \
    \ index = even.index(x)\n      return [x, index]\n    end\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpkss1_1s4\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpkss1_1s4.rb:42:in `test_pluck'\\\
    n     39: class TestHumanEval < Test::Unit::TestCase\\n     40:   def test_pluck\\\
    n     41:     candidate = method(:pluck)\\n  => 42:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     43:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   44:     assert_equal([], candidate.call([]))\\n     45:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.004643202 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n215.37 tests/s, 215.37 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpg2ujb6mb\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpg2ujb6mb.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004428006 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n225.84 tests/s, 225.84 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpzetlyfwz\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpzetlyfwz.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010728894 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n93.21 tests/s, 93.21 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % \nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpaxy5rhgp.rb:134: syntax error, unexpected string literal, expecting\
    \ `do' or '{' or '('\\nrequire 'test/unit'\\n        ^\\n/tmp/tmpaxy5rhgp.rb:135:\
    \ class definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\\
    n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpaxy5rhgp.rb:147: syntax error, unexpected end-of-input,\
    \ expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp2bm3cyu_\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp2bm3cyu_.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010793446 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n92.65 tests/s, 92.65 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.min.even? ? even.min\
    \ : [even.min.even? ? even.min : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmp6ntaeuvi.rb:33: syntax error, unexpected local variable or method,\
    \ expecting ']'\\nrequire 'test/unit'\\n^~~~~~~\\n/tmp/tmp6ntaeuvi.rb:34: class\
    \ definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\\
    n/tmp/tmp6ntaeuvi.rb:46: syntax error, unexpected end-of-input, expecting `end'\\\
    n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? even.min : [even.min]\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpftt47yc7\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpftt47yc7.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004564773 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n219.07 tests/s, 219.07 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpq_w86kdf.rb:34: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpq_w86kdf.rb:46: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpdfpp3ax2\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpdfpp3ax2.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.008809746 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n113.51 tests/s, 113.51 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  if even.empty?\n    return []\n  else\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpm_4uc970\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpm_4uc970.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004247026 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n235.46 tests/s, 235.46 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    even = arr.select { |x| x % 2 == 0 }\n\
    \    even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpwlycjtgw\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpwlycjtgw.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004609909 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n216.92 tests/s, 216.92 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.sort!\n    even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpzknbknny\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpzknbknny.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.0055943 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n178.75 tests/s, 178.75 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpigfhh10l\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpigfhh10l.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.009951093 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n100.49 tests/s, 100.49 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpr2z1jdw9\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpr2z1jdw9.rb:45:in `test_pluck'\\\
    n     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005242798 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n190.74 tests/s, 190.74 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpqnk6vffp\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpqnk6vffp.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.006089069 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n164.23 tests/s, 164.23 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n  \
    \    arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n\
    \    arr.sort!\n    even = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n\
    \      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n\
    \    arr.sort!\n    even = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n\
    \      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n\
    \    arr.sort!\n    even = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n\
    \      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpqlnm7_sx.rb:103: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpqlnm7_sx.rb:115: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.sort!\n\
    \  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp027qdsgi\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp027qdsgi.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.010160557 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n98.42 tests/s, 98.42 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.first\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp0x5z20ev\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp0x5z20ev.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004327578 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n231.08 tests/s, 231.08 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.min\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmplj5gi055\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmplj5gi055.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009752478 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n102.54 tests/s, 102.54 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp7wlp_wws\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp7wlp_wws.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.005326536 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n187.74 tests/s, 187.74 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpw7ree9cw\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpw7ree9cw.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.018347711 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n54.50 tests/s, 54.50 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    arr.each_with_index do |node,\
    \ index|\n        if node.even?\n            arr[index] = node\n            arr.delete_at(index)\n\
    \        end\n    end\n    arr.sort!\n    arr.first\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp1aq8fe97\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp1aq8fe97.rb:41:in `test_pluck'\\\
    n     38: class TestHumanEval < Test::Unit::TestCase\\n     39:   def test_pluck\\\
    n     40:     candidate = method(:pluck)\\n  => 41:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     42:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   43:     assert_equal([], candidate.call([]))\\n     44:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<3>\\\
    n===============================================================================\\\
    n\\nFinished in 0.004508658 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n221.80 tests/s, 221.80 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  next if node.even?\n    smallest_value = node\n    smallest_index = index\n\
    \    smallest_value.downto(smallest_index) do |value|\n      next if value.even?\n\
    \      smallest_value = value if value < smallest_value\n    end\n    smallest_value\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpoej7_pry\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpoej7_pry.rb:42:in `test_pluck'\\\
    n     39: class TestHumanEval < Test::Unit::TestCase\\n     40:   def test_pluck\\\
    n     41:     candidate = method(:pluck)\\n  => 42:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     43:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   44:     assert_equal([], candidate.call([]))\\n     45:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[4, 2,\
    \ 3]>\\n\\ndiff:\\n? [   2, 1]\\n?  4,    3 \\n===============================================================================\\\
    n\\nFinished in 0.033879516 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n29.52 tests/s, 29.52 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      return [n, i]\n    end\n  end\n  return []\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpyg7_vdu0\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpyg7_vdu0.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.010262668 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n97.44 tests/s, 97.44 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpz93du33o\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpz93du33o.rb:36:in `test_pluck'\\\
    n     33: class TestHumanEval < Test::Unit::TestCase\\n     34:   def test_pluck\\\
    n     35:     candidate = method(:pluck)\\n  => 36:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     37:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   38:     assert_equal([], candidate.call([]))\\n     39:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.011831097 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n84.52 tests/s, 84.52 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpokrv40h1\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpokrv40h1.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.009750645 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n102.56 tests/s, 102.56 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpax6eu1x4\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpax6eu1x4.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.00529714 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n188.78 tests/s, 188.78 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3y2fw4z2\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp3y2fw4z2.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004847115 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n206.31 tests/s, 206.31 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpz52uoel4\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpz52uoel4.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004651226 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n215.00 tests/s, 215.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index]\
    \ : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpsm_9b0ps\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `index' for\
    \ 2:Integer\\n/tmp/tmpsm_9b0ps.rb:29:in `pluck'\\n/tmp/tmpsm_9b0ps.rb:35:in `call'\\\
    n/tmp/tmpsm_9b0ps.rb:35:in `test_pluck'\\n     32: class TestHumanEval < Test::Unit::TestCase\\\
    n     33:   def test_pluck\\n     34:     candidate = method(:pluck)\\n  => 35:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     36:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     37:     assert_equal([], candidate.call([]))\\\
    n     38:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002566666 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n389.61 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp74r8bb8_\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp74r8bb8_.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004772312 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n209.54 tests/s, 209.54 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    next if node.even?\n    arr[index] = node\n  end\n  arr.delete_if\
    \ { |node| node.even? }\n  arr.sort!\n  arr.first\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpsh_8pqhi\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpsh_8pqhi.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<3>\\\
    n===============================================================================\\\
    n\\nFinished in 0.009682247 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n103.28 tests/s, 103.28 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.each_with_index do |x, i|\n    if x == 2\n     \
    \ return [x, i]\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpet0dh8ir\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpet0dh8ir.rb:40:in `test_pluck'\\\
    n     37: class TestHumanEval < Test::Unit::TestCase\\n     38:   def test_pluck\\\
    n     39:     candidate = method(:pluck)\\n  => 40:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     41:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   42:     assert_equal([], candidate.call([]))\\n     43:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.021886615 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n45.69 tests/s, 45.69 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min\n  end\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpb3sa7avn\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpb3sa7avn.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004440951 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n225.18 tests/s, 225.18 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpfrddj5_s\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpfrddj5_s.rb:45:in `test_pluck'\\\
    n     42: class TestHumanEval < Test::Unit::TestCase\\n     43:   def test_pluck\\\
    n     44:     candidate = method(:pluck)\\n  => 45:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     46:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   47:     assert_equal([], candidate.call([]))\\n     48:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.005971188 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n167.47 tests/s, 167.47 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n\
    \    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmps_3wckvz\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmps_3wckvz.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004702252 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n212.66 tests/s, 212.66 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpm6pd30k7\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpm6pd30k7.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004340011 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n230.41 tests/s, 230.41 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even_values = arr.select { |x| x % 2 == 0\
    \ }\n  even_values.sort.each_with_index { |x, i| return [x, i] if even_values.include?(x)\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp9c4shfs6\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp9c4shfs6.rb:34:in `test_pluck'\\\
    n     31: class TestHumanEval < Test::Unit::TestCase\\n     32:   def test_pluck\\\
    n     33:     candidate = method(:pluck)\\n  => 34:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     35:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   36:     assert_equal([], candidate.call([]))\\n     37:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.012722834 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n78.60 tests/s, 78.60 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpzo5d4wlr\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpzo5d4wlr.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.020360374 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n49.12 tests/s, 49.12 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ [even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmps385mll7.rb:33: syntax error, unexpected local variable or method,\
    \ expecting ']'\\nrequire 'test/unit'\\n^~~~~~~\\n/tmp/tmps385mll7.rb:34: class\
    \ definition in method body\\nclass TestHumanEval < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\\
    n/tmp/tmps385mll7.rb:46: syntax error, unexpected end-of-input, expecting `end'\\\
    n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmplf3m_pov\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmplf3m_pov.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004965116 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n201.41 tests/s, 201.41 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    next if n % 2 == 0\n    arr[i] = n\n  end\n  arr.uniq.sort!\n  arr.first\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp4_mawac6\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp4_mawac6.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.021048799 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n47.51 tests/s, 47.51 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp89ckkl37\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp89ckkl37.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004497126 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n222.36 tests/s, 222.36 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp0m46bpit\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmp0m46bpit.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004532974 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n220.61 tests/s, 220.61 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpyi051o7b\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpyi051o7b.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004410724 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n226.72 tests/s, 226.72 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? \nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: b''
  stderr: "b\"/tmp/tmpf_bbzs0o.rb:34: class definition in method body\\nclass TestHumanEval\
    \ < Test::Unit::TestCase\\n^~~~~~~~~~~~~~~~~~~\\n/tmp/tmpf_bbzs0o.rb:46: syntax\
    \ error, unexpected end-of-input, expecting `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.first\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpfpxevc6m\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpfpxevc6m.rb:35:in `test_pluck'\\\
    n     32: class TestHumanEval < Test::Unit::TestCase\\n     33:   def test_pluck\\\
    n     34:     candidate = method(:pluck)\\n  => 35:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     36:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   37:     assert_equal([], candidate.call([]))\\n     38:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004444809 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n224.98 tests/s, 224.98 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node.value, index]\n    end\n  end\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp50qnlp7s\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `value' for\
    \ 2:Integer\\n/tmp/tmp50qnlp7s.rb:30:in `block in pluck'\\n/tmp/tmp50qnlp7s.rb:28:in\
    \ `each'\\n/tmp/tmp50qnlp7s.rb:28:in `each_with_index'\\n/tmp/tmp50qnlp7s.rb:28:in\
    \ `pluck'\\n/tmp/tmp50qnlp7s.rb:38:in `call'\\n/tmp/tmp50qnlp7s.rb:38:in `test_pluck'\\\
    n     35: class TestHumanEval < Test::Unit::TestCase\\n     36:   def test_pluck\\\
    n     37:     candidate = method(:pluck)\\n  => 38:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     39:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   40:     assert_equal([], candidate.call([]))\\n     41:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002478651 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n403.45 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
    \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
    \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
    \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4,\
    \ 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
    \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
    \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpjz1w2qhe\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpjz1w2qhe.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<2>\\\
    n\\ndiff:\\n? [2, 1]\\n===============================================================================\\\
    n\\nFinished in 0.004205498 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n237.78 tests/s, 237.78 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    even_values = []\n    smallest_value =\
    \ 0\n    smallest_index = 0\n    arr.each do |node|\n        if node.even?\n \
    \           even_values << node.value\n            if node.value < smallest_value\n\
    \                smallest_value = node.value\n                smallest_index =\
    \ even_values.index{|x| x.even?}\n            end\n        end\n    end\n    return\
    \ smallest_value, smallest_index\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpvdhcqk34\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NoMethodError: undefined method `value' for\
    \ 4:Integer\\n/tmp/tmpvdhcqk34.rb:32:in `block in pluck'\\n/tmp/tmpvdhcqk34.rb:30:in\
    \ `each'\\n/tmp/tmpvdhcqk34.rb:30:in `pluck'\\n/tmp/tmpvdhcqk34.rb:45:in `call'\\\
    n/tmp/tmpvdhcqk34.rb:45:in `test_pluck'\\n     42: class TestHumanEval < Test::Unit::TestCase\\\
    n     43:   def test_pluck\\n     44:     candidate = method(:pluck)\\n  => 45:\
    \     assert_equal([2, 1], candidate.call([4, 2, 3]))\\n     46:     assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\\n     47:     assert_equal([], candidate.call([]))\\\
    n     48:     assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.002352052 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n425.16 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node,index|\n   \
    \ if node.even?\n      smallest_value = node\n      smallest_index = index\n \
    \   end\n  end\n  return [smallest_value, smallest_index]\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate =\
    \ method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2,\
    \ 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n \
    \   assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0,\
    \ 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5,\
    \ 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmp3ppq92d5\\nStarted\\nE\\n===============================================================================\\\
    nError: test_pluck(TestHumanEval): NameError: undefined local variable or method\
    \ `smallest_value' for #<TestHumanEval:0x000056352af92968>\\n/tmp/tmp3ppq92d5.rb:33:in\
    \ `pluck'\\n/tmp/tmp3ppq92d5.rb:39:in `call'\\n/tmp/tmp3ppq92d5.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n===============================================================================\\\
    n\\nFinished in 0.010271685 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n97.36 tests/s, 0.00 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n \
    \   assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1],\
    \ candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1,\
    \ 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n\
    \    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([],\
    \ candidate.call([7, 9, 7, 1]))\n  end\nend\n"
  stdout: "b\"Loaded suite /tmp/tmpf963klol\\nStarted\\nF\\n===============================================================================\\\
    nFailure: test_pluck(TestHumanEval)\\n/tmp/tmpf963klol.rb:39:in `test_pluck'\\\
    n     36: class TestHumanEval < Test::Unit::TestCase\\n     37:   def test_pluck\\\
    n     38:     candidate = method(:pluck)\\n  => 39:     assert_equal([2, 1], candidate.call([4,\
    \ 2, 3]))\\n     40:     assert_equal([2, 1], candidate.call([1, 2, 3]))\\n  \
    \   41:     assert_equal([], candidate.call([]))\\n     42:     assert_equal([0,\
    \ 1], candidate.call([5, 0, 3, 0, 4, 2]))\\n<[2, 1]> expected but was\\n<[2, 0]>\\\
    n\\ndiff:\\n? [2, 1]\\n?     0 \\n===============================================================================\\\
    n\\nFinished in 0.004530389 seconds.\\n-------------------------------------------------------------------------------\\\
    n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\\\
    n0% passed\\n-------------------------------------------------------------------------------\\\
    n220.73 tests/s, 220.73 assertions/s\\n\""
  stderr: b''
  exit_code: 1
  status: OK
