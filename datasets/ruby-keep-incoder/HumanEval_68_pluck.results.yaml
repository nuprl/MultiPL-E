name: HumanEval_68_pluck
language: ruby
results:
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.sort!\n    even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.empty?\
    \ ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? even.min : even.min.even? ?\
    \ even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : "
  stdout: b''
  stderr: "b'/tmp/tmpsk88x5au.rb:29: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.sort!\n    even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.empty?\
    \ ? [] : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even"
  stdout: b''
  stderr: "b\"/tmp/tmpzz6rl5vb.rb:28: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmp0eoti406.rb:32: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.each_with_index do |x, i|\n    if x==even[0]\n \
    \     return [x, i]\n    end\n  end\n  return []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    next if n.even?\n    arr[i] = n\n  end\n  arr.uniq.sort!\n  arr.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? even.min : [even.min]\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even"
  stdout: b''
  stderr: "b\"/tmp/tmpemlr8j7n.rb:29: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.each do |x|\n    arr.delete_at(x)\n  end\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_"
  stdout: b''
  stderr: "b\"/tmp/tmp4zquih6h.rb:111: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\n  []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.index, even.min.even] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index, even.min.even]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index,\
    \ even.min.even] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.index, even.min.even] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index, even.min.even]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.index,\
    \ even.min.even] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.index, even.min.even] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.index, even.min.even] : even.min.even?\
    \ ? [even.min.even, even."
  stdout: b''
  stderr: "b'/tmp/tmpwxmgnsyr.rb:29: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ [even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmpquqnp4ds.rb:32: syntax error, unexpected end-of-input, expecting\
    \ ']'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.each do |x|\n        arr.delete_at(x)\n    end\n    arr.delete_at(arr.index(even.min))\n\
    \    arr\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>"
  stdout: b''
  stderr: "b\"/tmp/tmphoarr3kz.rb:35: syntax error, unexpected '<', expecting end-of-input\\\
    n</code>\\n^\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.sort!\n\
    \  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n, i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\n  []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node,index|\n   \
    \ if node.even?\n      smallest_value = node\n      smallest_index = index\n \
    \   end\n  end\n  return [smallest_value, smallest_index]\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.each do |x|\n    arr.delete_at(x)\n  end\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_"
  stdout: b''
  stderr: "b\"/tmp/tmpaeegng3m.rb:111: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    even = arr.select { |x| x % 2 == 0 }\n\
    \    even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.sort!\n\
    \  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node.value, index]\n    end\n  end\n\
    \  []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr."
  stdout: b''
  stderr: "b'/tmp/tmph8s8tegg.rb:103: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,index|\n\
    \    if node.even?\n      arr[index] = node\n    end\n  end\n  arr.compact!\n\
    \  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n     \
    \ arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_with_index\
    \ do |node,index|\n    if node.even?\n      arr[index] = node\n    end\n  end\n\
    \  arr.compact!\n  arr.sort!\n  arr.each_with_index do |node,index|\n    if node.even?\n\
    \      arr[index] = node\n    end\n  end\n  arr.compact!\n  arr.sort!\n  arr.each_"
  stdout: b''
  stderr: "b\"/tmp/tmpots_vgqa.rb:126: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index] :\
    \ even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmp8vtewpzl.rb:32: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.find { |x| x % 2 == 0 }\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.each do |x|\n        arr.delete_at(x) \n    end\n   \
    \ arr.delete_at(arr.index(even.min))\n    arr\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x.even? }\n    even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.min_by\
    \ { |x| x }\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each_with_index {|x,\
    \ i| arr[i] = x}\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.each_with_index do |n, i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uni"
  stdout: b''
  stderr: "b\"/tmp/tmpdenyqryn.rb:104: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmpjhiae9ff.rb:32: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.min\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.each_with_index do |n,i|\n    if n %\
    \ 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.each_"
  stdout: b''
  stderr: "b\"/tmp/tmprzk1bda6.rb:136: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.min\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select {|x| x % 2 == 0}\n  even.sort!\n\
    \  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index] :\
    \ even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.each_with_index do |x, i|\n    if x==even[0]\n \
    \     return [x] if even.size != 1\n      return [x] if even.size == 1\n    end\n\
    \  end\n  return []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index] :\
    \ even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.each do |x|\n    arr.delete_at(x)\n  end\n  if arr.empty?\n  \
    \  return []\n  end\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)"
  stdout: b''
  stderr: "b\"/tmp/tmprwhni277.rb:112: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even_values = arr.select { |x| x.even? }\n\
    \  even_values.sort.each_with_index { |x, i| return [x, i] if x.even? }\n  even_values.sort.each_with_index\
    \ { |x, i| return [x, i] if x.even? }.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.sort!\n    even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min.even?\
    \ ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even, even.min.index]\
    \ : even.min.even? ? [even.min.even, even.min.index] : even.min.even? ? [even.min.even,\
    \ even.min.index] : even.min.even? ? [even.min.even, even.min.index] : even.min."
  stdout: b''
  stderr: "b'/tmp/tmpfvtrxsjq.rb:29: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    next if n.even?\n    arr[i] = n\n  end\n  arr.uniq!\n  arr.sort!\n  arr.first\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n\
    \  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2\
    \ == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n\
    \  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2\
    \ == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n\
    \  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2\
    \ == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      "
  stdout: b''
  stderr: "b'/tmp/tmp6x9je1nf.rb:128: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min.even?,\
    \ even.min.index] : []\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index]\
    \ : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x.even?\
    \ }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? "
  stdout: b''
  stderr: "b'/tmp/tmpgnq_wq3i.rb:32: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!"
  stdout: b''
  stderr: "b\"/tmp/tmpf4wxte66.rb:117: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end\n</cell>\n<cell>"
  stdout: b''
  stderr: "b\"/tmp/tmpegpmfdyz.rb:41: syntax error, unexpected '<', expecting end-of-input\\\
    n</cell>\\n^\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index]\
    \ : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n  \
    \    if even.index(x) == even.index(x + 1)\n        return [x] + even.index(x)\
    \ + 1\n      else\n        return [x] + even.index(x + 1)\n      end\n    end\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n     \
    \ index = even.index(x)\n      break if index == 0\n    end\n    [ even.first,\
    \ index ]\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  next if node.even?\n    smallest_value = node\n    smallest_index = index\n\
    \    smallest_value.downto(smallest_value.length - 1) do |i|\n      next if i.even?\n\
    \      smallest_value = i if smallest_value < i\n    end\n    smallest_value\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? even.min : [even.min.even? ?\
    \ even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even?\
    \ ? even.min : "
  stdout: b''
  stderr: "b'/tmp/tmpgucpy3ud.rb:29: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.sort!\n    even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  return arr\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node.value, index]\n    end\n  end\n\
    \  []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  if node.even?\n      smallest_value = node\n      smallest_index = index\n\
    \    end\n  end\n  return smallest_value, smallest_index\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index do |n,i|\n    if n\
    \ % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.uniq.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n  \
    \  end\n  end\n  arr.uniq.sort!"
  stdout: b''
  stderr: "b\"/tmp/tmpebiwjt_h.rb:117: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node, index]\n    end\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmp0htqerau.rb:32: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n\
    \    end\n  end\n  return arr\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.each do |x|\n        smallest = x\n        smallest_index\
    \ = -1\n        arr.each do |y|\n            if y % 2 == 0\n                if\
    \ y < smallest\n                    smallest = y\n                    smallest_index\
    \ = y\n                end\n            end\n        end\n        return [ smallest,\
    \ smallest_index ]\n    end\n    return []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n     \
    \ index = even.index(x)\n      if even.count(x) == 1 && index == 0\n        return\
    \ [x] # return [x] if even.count(x) == 1 and index == 0\n      elsif even.count(x)\
    \ == 1 && index != 0\n        return [x] # return [x] if even.count(x) == 1 and\
    \ index != 0\n      elsif even.count(x) > 1 && index == 0\n        return [x]\
    \ # return [x] if even.count(x) > 1 and index == 0\n      elsif even.count(x)\
    \ > 1 && index != 0\n        return [x] # return [x] if even.count(x) > 1 and\
    \ index != 0\n      end\n    end\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n, i|\n    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n\
    \  arr.uniq.sort!\n  arr.uniq.sort!\n  arr.uniq.sort!\n  arr."
  stdout: b''
  stderr: "b'/tmp/tmpplzk3q21.rb:103: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq.sort!\n\
    \  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n\
    \  end\n  return []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n     \
    \ index = even.index(x)\n      return [x, index]\n    end\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n\
    \  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n      arr[i]\
    \ = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % 2 == 0\n\
    \      arr[i] = n\n      break\n    end\n  end\n  arr.uniq!\n  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      arr[i] = n\n      break\n    end\n  end\n\
    \  arr.uniq!\n  arr.sort!\n  arr.each_with_index do |n,i|\n    if n % "
  stdout: b''
  stderr: "b'/tmp/tmpmmzt3njm.rb:133: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.min.even? ? even.min\
    \ : [even.min.even? ? even.min : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even? ? even.min.index : even.min.even?\
    \ ? even.min.index : even.min.even? ? even.min.index : even.min.even? ? even.min.index\
    \ : even.min.even? ? even.min.index : even.min.even"
  stdout: b''
  stderr: "b\"/tmp/tmphp893i9h.rb:32: syntax error, unexpected end-of-input, expecting\
    \ ']'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? even.min : [even.min]\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmpk60b83ui.rb:32: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  if even.empty?\n    return []\n  else\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    even = arr.select { |x| x % 2 == 0 }\n\
    \    even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select {|x| x\
    \ % 2 == 0}\n    even.sort!\n    even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.each do |x|\n  \
    \    arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n\
    \    arr.sort!\n    even = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n\
    \      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n\
    \    arr.sort!\n    even = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n\
    \      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n\
    \    arr.sort!\n    even = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n\
    \      arr.delete_at(x)\n    end\n    arr.delete_at(0)\n    arr.sort!\n    even\
    \ = arr.select { |x| x % 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n\
    \    end\n    arr.delete_at(0)\n    arr.sort!\n    even = arr.select { |x| x %\
    \ 2 == 0 }\n    even.each do |x|\n      arr.delete_at(x)\n    end\n    arr."
  stdout: b''
  stderr: "b'/tmp/tmp2hfsh1io.rb:101: syntax error, unexpected end-of-input\\n'"
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.sort!\n\
    \  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.first\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even = arr.select { |x| x % 2 == 0 }\n  even.min\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    arr.each_with_index do |node,\
    \ index|\n        if node.even?\n            arr[index] = node\n            arr.delete_at(index)\n\
    \        end\n    end\n    arr.sort!\n    arr.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node, index|\n  \
    \  next if node.even?\n    smallest_value = node\n    smallest_index = index\n\
    \    smallest_value.downto(smallest_index) do |value|\n      next if value.even?\n\
    \      smallest_value = value if value < smallest_value\n    end\n    smallest_value\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    if n % 2 == 0\n      return [n, i]\n    end\n  end\n  return []\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min.even? ? [even.min.even?, even.min.index]\
    \ : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.sort!\n    even.first\n\
    \  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    next if node.even?\n    arr[index] = node\n  end\n  arr.delete_if\
    \ { |node| node.even? }\n  arr.sort!\n  arr.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.sort!\n  even.each_with_index do |x, i|\n    if x == 2\n     \
    \ return [x, i]\n    end\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n,i|\n\
    \    if n % 2 == 0\n      arr[i] = n\n    end\n  end\n  arr.uniq.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if n % 2 == 0\n      return [n,i]\n    end\n  end\n  return []\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    arr.sort!\n    even = arr.select { |x|\
    \ x % 2 == 0 }\n    even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  even_values = arr.select { |x| x % 2 == 0\
    \ }\n  even_values.sort.each_with_index { |x, i| return [x, i] if even_values.include?(x)\
    \ }\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ [even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmpitv5n7an.rb:32: syntax error, unexpected end-of-input, expecting\
    \ ']'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |n, i|\n\
    \    next if n % 2 == 0\n    arr[i] = n\n  end\n  arr.uniq.sort!\n  arr.first\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  even.empty? ? [] : even.min\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? even.min :\
    \ even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? ? even.min : even.min.even? ? even.min : even.min.even? ? even.min\
    \ : even.min.even? "
  stdout: b''
  stderr: "b\"/tmp/tmpjf32qh65.rb:32: syntax error, unexpected end-of-input, expecting\
    \ `end'\\n\""
  exit_code: 1
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select {|x| x % 2\
    \ == 0}\n  even.empty? ? [] : even.first\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  arr.each_with_index do |node,\
    \ index|\n    if node.even?\n      return [node.value, index]\n    end\n  end\n\
    end"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    return []\n  else\n    even.min\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n    even_values = []\n    smallest_value =\
    \ 0\n    smallest_index = 0\n    arr.each do |node|\n        if node.even?\n \
    \           even_values << node.value\n            if node.value < smallest_value\n\
    \                smallest_value = node.value\n                smallest_index =\
    \ even_values.index{|x| x.even?}\n            end\n        end\n    end\n    return\
    \ smallest_value, smallest_index\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.each_with_index do |node,index|\n   \
    \ if node.even?\n      smallest_value = node\n      smallest_index = index\n \
    \   end\n  end\n  return [smallest_value, smallest_index]\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\ndef pluck(arr)\n  arr.sort!\n  even = arr.select { |x| x %\
    \ 2 == 0 }\n  if even.empty?\n    []\n  else\n    even.min.even? ? [even.min,\
    \ even.index(even.min)] : []\n  end\nend"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
