#lang racket

;; Given an array of integers, sort the integers that are between 1 and 9 inclusive,
;; reverse the resulting array, and then replace each digit by its corresponding name from
;; "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
;; For example:
;; arr = [2, 1, 1, 4, 5, 8, 2, 3]   
;; -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] 
;; -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]
;; return ["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"]
;; If the array is empty, return an empty array:
;; arr = []
;; return []
;; If the array has any strange number ignore it:
;; arr = [1, -1 , 55] 
;; -> sort arr -> [-1, 1, 55]
;; -> reverse arr -> [55, 1, -1]
;; return = ['One']
(define (by_length arr)
  (cond [(null? arr) '()]
        [else
         (define (by_length_helper arr acc)
           (cond [(null? arr) (reverse acc)]
                 [(and (>= (car arr) 1) (<= (car arr) 9))
                  (by_length_helper (cdr arr) (cons (string-append "One" (number->string (car arr))) acc))]
                 [else (by_length_helper (cdr arr) acc)]))
         (by_length_helper arr '())]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate by_length))
    (check-equal? (candidate (list 2 1 1 4 5 8 2 3)) (list "Eight" "Five" "Four" "Three" "Two" "Two" "One" "One"))
    (check-equal? (candidate (list )) (list ))
    (check-equal? (candidate (list 1 -1 55)) (list "One"))
    (check-equal? (candidate (list 1 -1 3 2)) (list "Three" "Two" "One"))
    (check-equal? (candidate (list 9 4 8)) (list "Nine" "Eight" "Four"))
))

(test-humaneval)