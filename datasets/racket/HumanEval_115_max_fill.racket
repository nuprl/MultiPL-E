#lang racket

;; You are given a rectangular grid of wells. Each row represents a single well,
;; and each 1 in a row represents a single unit of water.
;; Each well has a corresponding bucket that can be used to extract water from it, 
;; and all buckets have the same capacity.
;; Your task is to use the buckets to empty the wells.
;; Output the number of times you need to lower the buckets.
;; Example 1:
;; Input: 
;; grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
;; bucket_capacity : 1
;; Output: 6
;; Example 2:
;; Input: 
;; grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
;; bucket_capacity : 2
;; Output: 5
;; Example 3:
;; Input: 
;; grid : [[0,0,0], [0,0,0]]
;; bucket_capacity : 5
;; Output: 0
;; Constraints:
;; * all wells have the same length
;; * 1 <= grid.length <= 10^2
;; * 1 <= grid[:,1].length <= 10^2
;; * grid[i][j] -> 0 | 1
;; * 1 <= capacity <= 10
(define (max_fill grid, capacity)
  (define (fill_well well)
    (define (fill_well_helper well)
      (define (fill_well_helper_helper well)
        (if (null? well)
            0
            (let ((next (cdr well)))
              (if (null? next)
                  (if (zero? (car well))
                      0
                      1)
                  (+ (fill_well_helper_helper next)
                     (if (zero? (car well))
                         0
                         (fill_well_helper_helper next)))))))
      (if (zero? (car well))
          0
          (+ (fill_well_helper (cdr well))
             (fill_well_helper_helper well))))
    (fill_well_helper well))
  (define (max_fill_helper well)
    (if (null? well)
        0
        (let ((next (cdr well)))
          (if (null? next)
              (if (zero? (car well))
                  0
                  1)
              (+ (max_fill_helper next)
                 (if (zero? (car well))
                     0
                     (max_fill_helper next)))))))
  (define (max_fill_helper_helper well)
    (if (zero? (car well))
        0
        (+ (max_fill_helper (cdr well))
           (max_fill_helper well))))
  (define (max_fill_helper_helper_helper well)
    (if (null? well)
        0
        (let ((next (cdr well)))
          (if (null? next)
              (if (zero? (car well))
                  0
                  1)
              (+ (max_fill_helper_helper_helper next)
                 (if (zero? (car well))
                     0
                     (max_fill_helper_helper_helper next)))))))
  (define (max_fill_helper_helper_helper_helper well)
    (if (zero? (car well))
        0


(require rackunit)

(define (test-humaneval) 

  (let (( candidate max_fill))
    (check-equal? (candidate '('(0 0 1 0) '(0 1 0 0) '(1 1 1 1)) 1) 6)
    (check-equal? (candidate '('(0 0 1 1) '(0 0 0 0) '(1 1 1 1) '(0 1 1 1)) 2) 5)
    (check-equal? (candidate '('(0 0 0) '(0 0 0)) 5) 0)
    (check-equal? (candidate '('(1 1 1 1) '(1 1 1 1)) 2) 4)
    (check-equal? (candidate '('(1 1 1 1) '(1 1 1 1)) 9) 2)
))

(test-humaneval)