#lang racket

;; Your task is to implement a function that will simplify the expression
;; x * n. The function returns True if x * n evaluates to a whole number and False
;; otherwise. Both x and n, are string representation of a fraction, and have the following format,
;; <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
;; You can assume that x, and n are valid fractions, and do not have zero as denominator.
;; simplify("1/5", "5/1") = True
;; simplify("1/6", "2/1") = False
;; simplify("7/10", "10/2") = False
(define (simplify x, n)
  ; your code here
  )

# Problem 3
# 
# Implement a function that will return a list of all the factors of an integer.
# 
# factors(12) = [1, 2, 3, 4, 6, 12]
# factors(11) = [1, 11]
# factors(10) = [1, 2, 5, 10]
# factors(9) = [1, 3, 9]
# factors(8) = [1, 2, 4, 8]
# factors(7) = [1, 7]
# factors(6) = [1, 2, 3, 6]
# factors(5) = [1, 5]
# factors(4) = [1, 2, 4]
# factors(3) = [1, 3]
# factors(2) = [1, 2]
# factors(1) = [1]
# 
# You can assume that the input is a positive integer.
# 
# Hint: You can use the modulo operator to find the remainder of division.

(require rackunit)

(define (test-humaneval) 

  (let (( candidate simplify))
    (check-equal? (candidate "1/5" "5/1") #t)
    (check-equal? (candidate "1/6" "2/1") #f)
    (check-equal? (candidate "5/1" "3/1") #t)
    (check-equal? (candidate "7/10" "10/2") #f)
    (check-equal? (candidate "2/10" "50/10") #t)
    (check-equal? (candidate "7/2" "4/2") #t)
    (check-equal? (candidate "11/6" "6/1") #t)
    (check-equal? (candidate "2/3" "5/2") #f)
    (check-equal? (candidate "5/2" "3/5") #f)
    (check-equal? (candidate "2/4" "8/4") #t)
    (check-equal? (candidate "2/4" "4/2") #t)
    (check-equal? (candidate "1/5" "5/1") #t)
    (check-equal? (candidate "1/5" "1/5") #f)
))

(test-humaneval)