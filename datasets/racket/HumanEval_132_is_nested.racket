#lang racket

;; Create a function that takes a string as input which contains only square brackets.
;; The function should return True if and only if there is a valid subsequence of brackets 
;; where at least one bracket in the subsequence is nested.
;; is_nested('[[]]') ➞ True
;; is_nested('[]]]]]]][[[[[]') ➞ False
;; is_nested('[][]') ➞ False
;; is_nested('[]') ➞ False
;; is_nested('[[][]]') ➞ True
;; is_nested('[[]][[') ➞ True
(define (is_nested string)
  (define (is_nested_rec string)
    (cond
     ((string-empty? string) #f)
     ((string-empty? (string-drop string 1)) #t)
     ((char=? (string-head string) (string-head (string-drop string 1)))
      (is_nested_rec (string-drop string 1)))
     ((char=? (string-head string) '[')
      (is_nested_rec (string-drop string 1)))
     ((char=? (string-head string) ']')
      (is_nested_rec (string-drop string 1)))
     (else #f)))
  (is_nested_rec string))


(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_nested))
    (check-equal? (candidate "[[]]") #t)
    (check-equal? (candidate "[]]]]]]][[[[[]") #f)
    (check-equal? (candidate "[][]") #f)
    (check-equal? (candidate "[]") #f)
    (check-equal? (candidate "[[[[]]]]") #t)
    (check-equal? (candidate "[]]]]]]]]]]") #f)
    (check-equal? (candidate "[][][[]]") #t)
    (check-equal? (candidate "[[]") #f)
    (check-equal? (candidate "[]]") #f)
    (check-equal? (candidate "[[]][[") #t)
    (check-equal? (candidate "[[][]]") #t)
    (check-equal? (candidate "") #f)
    (check-equal? (candidate "[[[[[[[[") #f)
    (check-equal? (candidate "]]]]]]]]") #f)
))

(test-humaneval)