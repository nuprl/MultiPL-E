#lang racket

;; You are given two intervals,
;; where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
;; The given intervals are closed which means that the interval (start, end)
;; includes both start and end.
;; For each given interval, it is assumed that its start is less or equal its end.
;; Your task is to determine whether the length of intersection of these two 
;; intervals is a prime number.
;; Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
;; which its length is 1, which not a prime number.
;; If the length of the intersection is a prime number, return "YES",
;; otherwise, return "NO".
;; If the two intervals don't intersect, return "NO".
;; [input/output] samples:
;; intersection((1, 2), (2, 3)) ==> "NO"
;; intersection((-1, 1), (0, 4)) ==> "NO"
;; intersection((-3, -1), (-5, 5)) ==> "YES"
(define (intersection interval1, interval2)
  (let ((start1 (car interval1))
        (end1 (cdr interval1))
        (start2 (car interval2))
        (end2 (cdr interval2)))
    (if (<= start1 end2)
        (if (<= start2 end1)
            (if (= (abs (- start1 start2))
                   (abs (- end1 end2)))
                (if (is-prime (abs (- start1 start2)))
                    "YES"
                    "NO")
                "NO")
            "NO")
        "NO")))


(require rackunit)

(define (test-humaneval) 

  (let (( candidate intersection))
    (check-equal? (candidate '(1 2) '(2 3)) "NO")
    (check-equal? (candidate '(-1 1) '(0 4)) "NO")
    (check-equal? (candidate '(-3 -1) '(-5 5)) "YES")
    (check-equal? (candidate '(-2 2) '(-4 0)) "YES")
    (check-equal? (candidate '(-11 2) '(-1 -1)) "NO")
    (check-equal? (candidate '(1 2) '(3 5)) "NO")
    (check-equal? (candidate '(1 2) '(1 2)) "NO")
    (check-equal? (candidate '(-2 -2) '(-3 -2)) "NO")
))

(test-humaneval)