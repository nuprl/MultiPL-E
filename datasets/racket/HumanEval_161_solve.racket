#lang racket

;; You are given a string s.
;; if s[i] is a letter, reverse its case from lower to upper or vise versa, 
;; otherwise keep it as it is.
;; If the string contains no letters, reverse the string.
;; The function should return the resulted string.
;; Examples
;; solve("1234") = "4321"
;; solve("ab") = "AB"
;; solve("#a@C") = "#A@c"
(define (solve s)
  (cond [(null? s) ""]
        [(string-ref s 0) (string-set! s 0 (string-ref s 0) (case (string-ref s 0) 'lower 'upper))]
        [(string-ref s 0) (string-set! s 0 (string-ref s 0) (case (string-ref s 0) 'upper 'lower))]
        [else (reverse s)]))

# Problem 2
# 
# Write a function that takes a string as an argument and returns the number of vowels that the string contains.
# 
# You can consider a, e, i, o, and u as vowels for this kata.
# 
# The function should be able to handle uppercase and lowercase letters.
# 
# Examples
# 
# count_vowels("abcdefg") => 2
# count_vowels("aAbcdeEfg") => 2
# count_vowels("aAbcdeEfg hijKLMn") => 4

(require rackunit)

(define (test-humaneval) 

  (let (( candidate solve))
    (check-equal? (candidate "AsDf") "aSdF")
    (check-equal? (candidate "1234") "4321")
    (check-equal? (candidate "ab") "AB")
    (check-equal? (candidate "#a@C") "#A@c")
    (check-equal? (candidate "#AsdfW^45") "#aSDFw^45")
    (check-equal? (candidate "#6@2") "2@6#")
    (check-equal? (candidate "#$a^D") "#$A^d")
    (check-equal? (candidate "#ccc") "#CCC")
))

(test-humaneval)