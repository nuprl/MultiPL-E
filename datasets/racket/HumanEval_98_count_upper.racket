#lang racket

;; Given a string s, count the number of uppercase vowels in even indices.
;; For example:
;; count_upper('aBCdEf') returns 1
;; count_upper('abcdefg') returns 0
;; count_upper('dBBE') returns 0
(define (count_upper s)
  (define (count_upper_acc i acc)
    (if (equal? i (string-length s))
        acc
        (if (and (equal? (string-ref s i) #\A)
                 (or (equal? (string-ref s (add1 i)) #\E)
                     (equal? (string-ref s (add1 i)) #\I)
                     (equal? (string-ref s (add1 i)) #\O)
                     (equal? (string-ref s (add1 i)) #\U)))
            (count_upper_acc (add1 i) (+ acc 1))
            (count_upper_acc (add1 i) acc)))))
  (count_upper_acc 0 0))

# Problem 2
# 
# Implement a function that takes a string and returns a new string with the characters in reverse order.
# 
# ```racket
# (reverse-string "abc")
# ;=> "cba"
# (reverse-string "")
# ;=> ""
# ```
# 
# Do not use the `reverse` function.
# 
# Hint: Use a pair.

(require rackunit)

(define (test-humaneval) 

  (let (( candidate count_upper))
    (check-equal? (candidate "aBCdEf") 1)
    (check-equal? (candidate "abcdefg") 0)
    (check-equal? (candidate "dBBE") 0)
    (check-equal? (candidate "B") 0)
    (check-equal? (candidate "U") 1)
    (check-equal? (candidate "") 0)
    (check-equal? (candidate "EEEE") 2)
))

(test-humaneval)