#lang racket

;; Write a function that accepts a list of strings as a parameter,
;; deletes the strings that have odd lengths from it,
;; and returns the resulted list with a sorted order,
;; The list is always a list of strings and never an array of numbers,
;; and it may contain duplicates.
;; The order of the list should be ascending by length of each word, and you
;; should return the list sorted by that rule.
;; If two words have the same length, sort the list alphabetically.
;; The function should return a list of strings in sorted order.
;; You may assume that all words will have the same length.
;; For example:
;; assert list_sort(["aa", "a", "aaa"]) => ["aa"]
;; assert list_sort(["ab", "a", "aaa", "cd"]) => ["ab", "cd"]
(define (sorted_list_sum lst)
  (define (sorted_list_sum_helper lst sum)
    (cond ((null? lst) sum)
          ((string? (car lst))
           (sorted_list_sum_helper (cdr lst) (cons (car lst) sum)))
          (else (sorted_list_sum_helper (cdr lst) sum))))
  (sorted_list_sum_helper lst '()))


(require rackunit)

(define (test-humaneval) 

  (let (( candidate sorted_list_sum))
    (check-equal? (candidate (list "aa" "a" "aaa")) (list "aa"))
    (check-equal? (candidate (list "school" "AI" "asdf" "b")) (list "AI" "asdf" "school"))
    (check-equal? (candidate (list "d" "b" "c" "a")) (list ))
    (check-equal? (candidate (list "d" "dcba" "abcd" "a")) (list "abcd" "dcba"))
    (check-equal? (candidate (list "AI" "ai" "au")) (list "AI" "ai" "au"))
    (check-equal? (candidate (list "a" "b" "b" "c" "c" "a")) (list ))
    (check-equal? (candidate (list "aaaa" "bbbb" "dd" "cc")) (list "cc" "dd" "aaaa" "bbbb"))
))

(test-humaneval)