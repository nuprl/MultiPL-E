#lang racket

;; Create a function that returns a tuple (a, b), where 'a' is
;; the largest of negative integers, and 'b' is the smallest
;; of positive integers in a list.
;; If there is no negative or positive integers, return them as None.
;; Examples:
;; largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
;; largest_smallest_integers([]) == (None, None)
;; largest_smallest_integers([0]) == (None, None)
(define (largest_smallest_integers lst)
  (cond [(null? lst) (values None None)]
        [(= (length lst) 1) (values None (car lst))]
        [else (define (find_max_min lst)
                (define (find_max lst)
                  (cond [(null? lst) -1000000]
                        [else (max (car lst) (find_max (cdr lst)))]))
                (define (find_min lst)
                  (cond [(null? lst) 1000000]
                        [else (min (car lst) (find_min (cdr lst)))]))
                (values (find_max lst) (find_min lst)))
          (find_max_min lst)]))

# Test:

(require rackunit)

(define (test-humaneval) 

  (let (( candidate largest_smallest_integers))
    (check-equal? (candidate '(2 4 1 3 5 7)) '(#f 1))
    (check-equal? (candidate '(2 4 1 3 5 7 0)) '(#f 1))
    (check-equal? (candidate '(1 3 2 4 5 6 -2)) '(-2 1))
    (check-equal? (candidate '(4 5 3 6 2 7 -7)) '(-7 2))
    (check-equal? (candidate '(7 3 8 4 9 2 5 -9)) '(-9 2))
    (check-equal? (candidate '()) '(#f #f))
    (check-equal? (candidate '(0)) '(#f #f))
    (check-equal? (candidate '(-1 -3 -5 -6)) '(-1 #f))
    (check-equal? (candidate '(-1 -3 -5 -6 0)) '(-1 #f))
    (check-equal? (candidate '(-6 -4 -4 -3 1)) '(-3 1))
    (check-equal? (candidate '(-6 -4 -4 -3 -100 1)) '(-3 1))
))

(test-humaneval)