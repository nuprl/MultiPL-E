#lang racket

;; Given a list of numbers, return whether or not they are sorted
;; in ascending order. If list has more than 1 duplicate of the same
;; number, return False. Assume no negative numbers and only integers.
;; Examples
;; is_sorted([5]) ➞ True
;; is_sorted([1, 2, 3, 4, 5]) ➞ True
;; is_sorted([1, 3, 2, 4, 5]) ➞ False
;; is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
;; is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
;; is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
;; is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
;; is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
(define (is_sorted lst)
  (if (null? lst)
      #t
      (if (or (null? (cdr lst))
              (and (not (eq? (car lst) (cadr lst)))
                   (is_sorted (cdr lst))))
          #t
          #f)))


(require rackunit)

(define (test-humaneval) 

  (let (( candidate is_sorted))
    (check-equal? (candidate (list 5)) #t)
    (check-equal? (candidate (list 1 2 3 4 5)) #t)
    (check-equal? (candidate (list 1 3 2 4 5)) #f)
    (check-equal? (candidate (list 1 2 3 4 5 6)) #t)
    (check-equal? (candidate (list 1 2 3 4 5 6 7)) #t)
    (check-equal? (candidate (list 1 3 2 4 5 6 7)) #f)
    (check-equal? (candidate (list )) #t)
    (check-equal? (candidate (list 1)) #t)
    (check-equal? (candidate (list 3 2 1)) #f)
    (check-equal? (candidate (list 1 2 2 2 3 4)) #f)
    (check-equal? (candidate (list 1 2 3 3 3 4)) #f)
    (check-equal? (candidate (list 1 2 2 3 3 4)) #t)
    (check-equal? (candidate (list 1 2 3 4)) #t)
))

(test-humaneval)