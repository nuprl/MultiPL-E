#lang racket

;; You are given a positive integer n. You have to create an integer array a of length n.
;; For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
;; Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
;; and a[i] + a[j] + a[k] is a multiple of 3.
;; Example :
;; Input: n = 5
;; Output: 1
;; Explanation: 
;; a = [1, 3, 7, 13, 21]
;; The only valid triple is (1, 7, 13).
(define (get_max_triples n)
  (define (get_triples a)
    (define (get_triples_aux a i j k)
      (cond [(and (= i j) (= j k)) (list (list i j k))]
            [(and (= i j) (< j k)) (get_triples_aux a i (+ j 1) k)]
            [(and (< i j) (= j k)) (get_triples_aux a (+ i 1) j k)]
            [(and (< i j) (< j k)) (append (get_triples_aux a i (+ j 1) k)
                                            (get_triples_aux a (+ i 1) j k))]))
    (get_triples_aux a 0 1 2))
  (define (get_triples_sum_multiple a i j k)
    (let ([sum (+ (list-ref a i) (list-ref a j) (list-ref a k))])
      (cond [(= (% sum 3) 0) sum]
            [else 0])))
  (define (get_triples_sum_multiple_aux a i j k)
    (cond [(= i j) (get_triples_sum_multiple a i j k)]
          [(= j k) (get_triples_sum_multiple a i j k)]
          [(= i k) (get_triples_sum_multiple a i j k)]
          [(and (< i j) (< j k)) (append (get_triples_sum_multiple a i j k)
                                          (get_triples_sum_multiple a i (+ j 1) k))]))
  (define (get_triples_sum_multiple_aux_aux a i j k)
    (cond [(= i j) (get_triples_sum_multiple_aux a i j k)]
          [(= j k) (get_triples_sum_multiple_aux a i j k)]
          [(= i k) (get_triples_sum_multiple_aux a i j k)]
          [(and (< i j) (< j k)) (append (get_triples_sum_multiple_aux a i j k)
                                          (

(require rackunit)

(define (test-humaneval) 

  (let (( candidate get_max_triples))
    (check-equal? (candidate 5) 1)
    (check-equal? (candidate 6) 4)
    (check-equal? (candidate 10) 36)
    (check-equal? (candidate 100) 53361)
))

(test-humaneval)