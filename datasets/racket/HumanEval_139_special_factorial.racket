#lang racket

;; The Brazilian factorial is defined as:
;; brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
;; where n > 0
;; For example:
;; >>> special_factorial(4)
;; 288
;; The function will receive an integer as input and should return the special
;; factorial of this integer.
(define (special_factorial n)
  (cond [(zero? n) 1]
        [else (* n (special_factorial (- n 1)))]))

# Problem 3
# 
# Implement the following functions using recursion:
# 
# - `count_up`: Given an integer `n`, print all the numbers from `1` to `n`.
# - `count_down`: Given an integer `n`, print all the numbers from `n` to `1`.
# - `sum_up`: Given an integer `n`, print the sum of all numbers from `1` to `n`.
# - `sum_down`: Given an integer `n`, print the sum of all numbers from `n` to `1`.
# - `factorial`: Given an integer `n`, print the factorial of `n`.
# - `special_factorial`: Given an integer `n`, print the special factorial of `n`.
# 
# You may use the functions you defined in the previous problems.
# 
# **Hint:** You may find the function `range` useful.
# 
# **Example:**
# 
# ```scheme
# (count_up 3)
# 1
# 2
# 3
# 
# (count_down 3)
# 3
# 2
# 1
# 
# (sum_up 3)
# 6
# 
# (sum_down 3)
# 6
# 
# (factorial 3)
# 6
# 
# (special_factorial 3)
# 6
# ```
# 
# **Challenge:** Solve the previous problems using only tail recursion.
# 
# **Hint:** You may find the function `accumulate` from the `prelude` useful.
# 
# **Example:**
# 
# ```scheme
# (count_up 3)
# 1
# 2
# 3
# 
# (count_down 3)
# 3
# 2
# 1
# 
# (sum_up 3)
# 6
# 
# (sum_down 3)
# 6
# 
# (fact

(require rackunit)

(define (test-humaneval) 

  (let (( candidate special_factorial))
    (check-equal? (candidate 4) 288)
    (check-equal? (candidate 5) 34560)
    (check-equal? (candidate 7) 125411328000)
    (check-equal? (candidate 1) 1)
))

(test-humaneval)