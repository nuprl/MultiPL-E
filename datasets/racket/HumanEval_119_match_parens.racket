#lang racket

;; You are given a list of two strings, both strings consist of open
;; parentheses '(' or close parentheses ')' only.
;; Your job is to check if it is possible to concatenate the two strings in
;; some order, that the resulting string will be good.
;; A string S is considered to be good if and only if all parentheses in S
;; are balanced. For example: the string '(())()' is good, while the string
;; '())' is not.
;; Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
;; Examples:
;; match_parens(['()(', ')']) == 'Yes'
;; match_parens([')', ')']) == 'No'
(define (match_parens lst)
  (cond [(null? lst) #t]
        [(and (null? (cdr lst)) (eq? (car lst) '(')) #f]
        [(and (null? (cdr lst)) (eq? (car lst) ')')) #t]
        [(and (eq? (car lst) ')') (eq? (cadr lst) '(')) #t]
        [(and (eq? (car lst) ')') (eq? (cadr lst) ')')) #f]
        [(and (eq? (car lst) '(') (eq? (cadr lst) '(')) #t]
        [(and (eq? (car lst) '(') (eq? (cadr lst) ')')) #f]
        [(and (eq? (car lst) '(') (eq? (cadr lst) '(')) #t]
        [(and (eq? (car lst) '(') (eq? (cadr lst) ')')) #f]))

(require rackunit)

(define (test-humaneval) 

  (let (( candidate match_parens))
    (check-equal? (candidate (list "()(" ")")) "Yes")
    (check-equal? (candidate (list ")" ")")) "No")
    (check-equal? (candidate (list "(()(())" "())())")) "No")
    (check-equal? (candidate (list ")())" "(()()(")) "Yes")
    (check-equal? (candidate (list "(())))" "(()())((")) "Yes")
    (check-equal? (candidate (list "()" "())")) "No")
    (check-equal? (candidate (list "(()(" "()))()")) "Yes")
    (check-equal? (candidate (list "((((" "((())")) "No")
    (check-equal? (candidate (list ")(()" "(()(")) "No")
    (check-equal? (candidate (list ")(" ")(")) "No")
    (check-equal? (candidate (list "(" ")")) "Yes")
    (check-equal? (candidate (list ")" "(")) "Yes")
))

(test-humaneval)